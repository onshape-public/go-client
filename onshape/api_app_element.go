/*
Onshape REST API

The Onshape REST API consumed by all client. # Authorization The simplest way to authorize and enable the **Try it out** functionality is to sign in to Onshape and use the current session. The **Authorize** button enables other authorization techniques. To ensure the current session isn't used when trying other authentication techniques, make sure to remove the Onshape cookie as per the instructions for your particular browser. Alternatively, a private or incognito window may be used. Here's [how to remove a specific cookie on Chrome](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site). - **Current Session** authorization is enabled by default if the browser is already signed in to [Onshape](/). - **OAuth2** authorization uses an Onshape OAuth2 app created on the [Onshape Developer Portal](https://dev-portal.onshape.com/oauthApps). The redirect URL field should include `https://cad.onshape.com/glassworks/explorer/oauth2-redirect.html`. - **API Key** authorization using basic authentication is also available. The keys can be generated in the [Onshape Developer Portal](https://dev-portal.onshape.com/keys). In the authentication dialog, enter the access key in the `Username` field, and enter the secret key in the `Password` field. Basic authentication should only be used during the development process since sharing API Keys provides the same level of access as a username and password.

API version: 1.163.15808-38acf80dff96
Contact: api-support@onshape.zendesk.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package onshape

import (
	"context"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// AppElementApiService AppElementApi service
type AppElementApiService service

type ApiAbortTransactionRequest struct {
	ctx         context.Context
	ApiService  *AppElementApiService
	did         string
	eid         string
	wid         string
	tid         string
	returnError *bool
}

func (r ApiAbortTransactionRequest) ReturnError(returnError bool) ApiAbortTransactionRequest {
	r.returnError = &returnError
	return r
}

func (r ApiAbortTransactionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AbortTransactionExecute(r)
}

/*
AbortTransaction Abort transaction by document ID, workspace ID, tab ID, and transaction ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param eid
 @param wid
 @param tid
 @return ApiAbortTransactionRequest
*/
func (a *AppElementApiService) AbortTransaction(ctx context.Context, did string, eid string, wid string, tid string) ApiAbortTransactionRequest {
	return ApiAbortTransactionRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wid:        wid,
		tid:        tid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AppElementApiService) AbortTransactionExecute(r ApiAbortTransactionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.AbortTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/w/{wid}/e/{eid}/transactions/{tid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tid"+"}", url.PathEscape(parameterToString(r.tid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returnError != nil {
		localVarQueryParams.Add("returnError", parameterToString(*r.returnError, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkCreateElementRequest struct {
	ctx                          context.Context
	ApiService                   *AppElementApiService
	did                          string
	wid                          string
	bTAppElementBulkCreateParams *BTAppElementBulkCreateParams
	linkDocumentId               *string
}

func (r ApiBulkCreateElementRequest) BTAppElementBulkCreateParams(bTAppElementBulkCreateParams BTAppElementBulkCreateParams) ApiBulkCreateElementRequest {
	r.bTAppElementBulkCreateParams = &bTAppElementBulkCreateParams
	return r
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiBulkCreateElementRequest) LinkDocumentId(linkDocumentId string) ApiBulkCreateElementRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiBulkCreateElementRequest) Execute() (*BTAppElementBulkCreateInfo, *http.Response, error) {
	return r.ApiService.BulkCreateElementExecute(r)
}

/*
BulkCreateElement Create multiple empty application tabs by document ID and workspace ID.

Creates several new empty application elements in the document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wid The id of the workspace in which to perform the operation.
 @return ApiBulkCreateElementRequest
*/
func (a *AppElementApiService) BulkCreateElement(ctx context.Context, did string, wid string) ApiBulkCreateElementRequest {
	return ApiBulkCreateElementRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
	}
}

// Execute executes the request
//  @return BTAppElementBulkCreateInfo
func (a *AppElementApiService) BulkCreateElementExecute(r ApiBulkCreateElementRequest) (*BTAppElementBulkCreateInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementBulkCreateInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.BulkCreateElement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/w/{wid}/bulkcreate"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTAppElementBulkCreateParams == nil {
		return localVarReturnValue, nil, reportError("bTAppElementBulkCreateParams is required and must be specified")
	}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAppElementBulkCreateParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementBulkCreateInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommitTransactionsRequest struct {
	ctx                                 context.Context
	ApiService                          *AppElementApiService
	did                                 string
	wid                                 string
	bTAppElementCommitTransactionParams *BTAppElementCommitTransactionParams
	linkDocumentId                      *string
}

func (r ApiCommitTransactionsRequest) BTAppElementCommitTransactionParams(bTAppElementCommitTransactionParams BTAppElementCommitTransactionParams) ApiCommitTransactionsRequest {
	r.bTAppElementCommitTransactionParams = &bTAppElementCommitTransactionParams
	return r
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiCommitTransactionsRequest) LinkDocumentId(linkDocumentId string) ApiCommitTransactionsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiCommitTransactionsRequest) Execute() (*BTAppElementModifyInfo, *http.Response, error) {
	return r.ApiService.CommitTransactionsExecute(r)
}

/*
CommitTransactions Commit transactions by document ID and workspace ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wid The id of the workspace in which to perform the operation.
 @return ApiCommitTransactionsRequest
*/
func (a *AppElementApiService) CommitTransactions(ctx context.Context, did string, wid string) ApiCommitTransactionsRequest {
	return ApiCommitTransactionsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
	}
}

// Execute executes the request
//  @return BTAppElementModifyInfo
func (a *AppElementApiService) CommitTransactionsExecute(r ApiCommitTransactionsRequest) (*BTAppElementModifyInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementModifyInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.CommitTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/w/{wid}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTAppElementCommitTransactionParams == nil {
		return localVarReturnValue, nil, reportError("bTAppElementCommitTransactionParams is required and must be specified")
	}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAppElementCommitTransactionParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementModifyInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCompareAppElementJsonRequest struct {
	ctx                  context.Context
	ApiService           *AppElementApiService
	did                  string
	wvm                  string
	wvmid                string
	eid                  string
	workspaceId          *string
	versionId            *string
	microversionId       *string
	linkDocumentId       *string
	jsonDifferenceFormat *string
}

func (r ApiCompareAppElementJsonRequest) WorkspaceId(workspaceId string) ApiCompareAppElementJsonRequest {
	r.workspaceId = &workspaceId
	return r
}

func (r ApiCompareAppElementJsonRequest) VersionId(versionId string) ApiCompareAppElementJsonRequest {
	r.versionId = &versionId
	return r
}

func (r ApiCompareAppElementJsonRequest) MicroversionId(microversionId string) ApiCompareAppElementJsonRequest {
	r.microversionId = &microversionId
	return r
}

func (r ApiCompareAppElementJsonRequest) LinkDocumentId(linkDocumentId string) ApiCompareAppElementJsonRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiCompareAppElementJsonRequest) JsonDifferenceFormat(jsonDifferenceFormat string) ApiCompareAppElementJsonRequest {
	r.jsonDifferenceFormat = &jsonDifferenceFormat
	return r
}

func (r ApiCompareAppElementJsonRequest) Execute() (*BTDiffJsonResponse2725, *http.Response, error) {
	return r.ApiService.CompareAppElementJsonExecute(r)
}

/*
CompareAppElementJson Compare JSON by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wvm
 @param wvmid
 @param eid
 @return ApiCompareAppElementJsonRequest
*/
func (a *AppElementApiService) CompareAppElementJson(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiCompareAppElementJsonRequest {
	return ApiCompareAppElementJsonRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTDiffJsonResponse2725
func (a *AppElementApiService) CompareAppElementJsonExecute(r ApiCompareAppElementJsonRequest) (*BTDiffJsonResponse2725, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTDiffJsonResponse2725
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.CompareAppElementJson")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/compare"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.workspaceId != nil {
		localVarQueryParams.Add("workspaceId", parameterToString(*r.workspaceId, ""))
	}
	if r.versionId != nil {
		localVarQueryParams.Add("versionId", parameterToString(*r.versionId, ""))
	}
	if r.microversionId != nil {
		localVarQueryParams.Add("microversionId", parameterToString(*r.microversionId, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.jsonDifferenceFormat != nil {
		localVarQueryParams.Add("jsonDifferenceFormat", parameterToString(*r.jsonDifferenceFormat, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTDiffJsonResponse2725
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateElementRequest struct {
	ctx                context.Context
	ApiService         *AppElementApiService
	did                string
	wid                string
	bTAppElementParams *BTAppElementParams
	linkDocumentId     *string
}

func (r ApiCreateElementRequest) BTAppElementParams(bTAppElementParams BTAppElementParams) ApiCreateElementRequest {
	r.bTAppElementParams = &bTAppElementParams
	return r
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiCreateElementRequest) LinkDocumentId(linkDocumentId string) ApiCreateElementRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiCreateElementRequest) Execute() (*BTAppElementModifyInfo, *http.Response, error) {
	return r.ApiService.CreateElementExecute(r)
}

/*
CreateElement Create application tab by document ID and workspace ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wid The id of the workspace in which to perform the operation.
 @return ApiCreateElementRequest
*/
func (a *AppElementApiService) CreateElement(ctx context.Context, did string, wid string) ApiCreateElementRequest {
	return ApiCreateElementRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
	}
}

// Execute executes the request
//  @return BTAppElementModifyInfo
func (a *AppElementApiService) CreateElementExecute(r ApiCreateElementRequest) (*BTAppElementModifyInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementModifyInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.CreateElement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/w/{wid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTAppElementParams == nil {
		return localVarReturnValue, nil, reportError("bTAppElementParams is required and must be specified")
	}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAppElementParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementModifyInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateReferenceRequest struct {
	ctx                         context.Context
	ApiService                  *AppElementApiService
	did                         string
	eid                         string
	wvm                         string
	wvmid                       string
	bTAppElementReferenceParams *BTAppElementReferenceParams
}

func (r ApiCreateReferenceRequest) BTAppElementReferenceParams(bTAppElementReferenceParams BTAppElementReferenceParams) ApiCreateReferenceRequest {
	r.bTAppElementReferenceParams = &bTAppElementReferenceParams
	return r
}

func (r ApiCreateReferenceRequest) Execute() (*BTAppElementReferenceInfo, *http.Response, error) {
	return r.ApiService.CreateReferenceExecute(r)
}

/*
CreateReference Create referencesby document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param eid
 @param wvm
 @param wvmid
 @return ApiCreateReferenceRequest
*/
func (a *AppElementApiService) CreateReference(ctx context.Context, did string, eid string, wvm string, wvmid string) ApiCreateReferenceRequest {
	return ApiCreateReferenceRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wvm:        wvm,
		wvmid:      wvmid,
	}
}

// Execute executes the request
//  @return BTAppElementReferenceInfo
func (a *AppElementApiService) CreateReferenceExecute(r ApiCreateReferenceRequest) (*BTAppElementReferenceInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementReferenceInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.CreateReference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/references"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTAppElementReferenceParams == nil {
		return localVarReturnValue, nil, reportError("bTAppElementReferenceParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAppElementReferenceParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementReferenceInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAppElementContentRequest struct {
	ctx            context.Context
	ApiService     *AppElementApiService
	did            string
	eid            string
	wvm            string
	wvmid          string
	sid            string
	transactionId  *string
	parentChangeId *string
	description    *string
}

func (r ApiDeleteAppElementContentRequest) TransactionId(transactionId string) ApiDeleteAppElementContentRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiDeleteAppElementContentRequest) ParentChangeId(parentChangeId string) ApiDeleteAppElementContentRequest {
	r.parentChangeId = &parentChangeId
	return r
}

func (r ApiDeleteAppElementContentRequest) Description(description string) ApiDeleteAppElementContentRequest {
	r.description = &description
	return r
}

func (r ApiDeleteAppElementContentRequest) Execute() (*BTAppElementModifyInfo, *http.Response, error) {
	return r.ApiService.DeleteAppElementContentExecute(r)
}

/*
DeleteAppElementContent Delete subelement array by document ID, workspace or version or microversion ID, tab ID, and subelement ID. A Subelement is used to store and organize data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param eid
 @param wvm
 @param wvmid
 @param sid
 @return ApiDeleteAppElementContentRequest
*/
func (a *AppElementApiService) DeleteAppElementContent(ctx context.Context, did string, eid string, wvm string, wvmid string, sid string) ApiDeleteAppElementContentRequest {
	return ApiDeleteAppElementContentRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wvm:        wvm,
		wvmid:      wvmid,
		sid:        sid,
	}
}

// Execute executes the request
//  @return BTAppElementModifyInfo
func (a *AppElementApiService) DeleteAppElementContentExecute(r ApiDeleteAppElementContentRequest) (*BTAppElementModifyInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementModifyInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.DeleteAppElementContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/subelements/{sid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.parentChangeId != nil {
		localVarQueryParams.Add("parentChangeId", parameterToString(*r.parentChangeId, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementModifyInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBlobSubelementRequest struct {
	ctx           context.Context
	ApiService    *AppElementApiService
	did           string
	wid           string
	eid           string
	bid           string
	transactionId *string
	changeId      *string
}

func (r ApiDeleteBlobSubelementRequest) TransactionId(transactionId string) ApiDeleteBlobSubelementRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiDeleteBlobSubelementRequest) ChangeId(changeId string) ApiDeleteBlobSubelementRequest {
	r.changeId = &changeId
	return r
}

func (r ApiDeleteBlobSubelementRequest) Execute() (*BTAppElementModifyInfo, *http.Response, error) {
	return r.ApiService.DeleteBlobSubelementExecute(r)
}

/*
DeleteBlobSubelement Delete blob subelement file by document ID, workspace ID, tab ID, and blob ID. A Subelement is used to store and organize data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wid
 @param eid
 @param bid
 @return ApiDeleteBlobSubelementRequest
*/
func (a *AppElementApiService) DeleteBlobSubelement(ctx context.Context, did string, wid string, eid string, bid string) ApiDeleteBlobSubelementRequest {
	return ApiDeleteBlobSubelementRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
		bid:        bid,
	}
}

// Execute executes the request
//  @return BTAppElementModifyInfo
func (a *AppElementApiService) DeleteBlobSubelementExecute(r ApiDeleteBlobSubelementRequest) (*BTAppElementModifyInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementModifyInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.DeleteBlobSubelement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/w/{wid}/e/{eid}/blob/{bid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bid"+"}", url.PathEscape(parameterToString(r.bid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.changeId != nil {
		localVarQueryParams.Add("changeId", parameterToString(*r.changeId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementModifyInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteReferenceRequest struct {
	ctx            context.Context
	ApiService     *AppElementApiService
	did            string
	eid            string
	wvm            string
	wvmid          string
	rid            string
	transactionId  *string
	parentChangeId *string
	description    *string
}

func (r ApiDeleteReferenceRequest) TransactionId(transactionId string) ApiDeleteReferenceRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiDeleteReferenceRequest) ParentChangeId(parentChangeId string) ApiDeleteReferenceRequest {
	r.parentChangeId = &parentChangeId
	return r
}

func (r ApiDeleteReferenceRequest) Description(description string) ApiDeleteReferenceRequest {
	r.description = &description
	return r
}

func (r ApiDeleteReferenceRequest) Execute() (*BTAppElementReferenceInfo, *http.Response, error) {
	return r.ApiService.DeleteReferenceExecute(r)
}

/*
DeleteReference Delete references by document ID, workspace or version or microversion ID, tab ID, and resolve ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param eid
 @param wvm
 @param wvmid
 @param rid
 @return ApiDeleteReferenceRequest
*/
func (a *AppElementApiService) DeleteReference(ctx context.Context, did string, eid string, wvm string, wvmid string, rid string) ApiDeleteReferenceRequest {
	return ApiDeleteReferenceRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wvm:        wvm,
		wvmid:      wvmid,
		rid:        rid,
	}
}

// Execute executes the request
//  @return BTAppElementReferenceInfo
func (a *AppElementApiService) DeleteReferenceExecute(r ApiDeleteReferenceRequest) (*BTAppElementReferenceInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementReferenceInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.DeleteReference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/references/{rid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rid"+"}", url.PathEscape(parameterToString(r.rid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.parentChangeId != nil {
		localVarQueryParams.Add("parentChangeId", parameterToString(*r.parentChangeId, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementReferenceInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadBlobSubelementRequest struct {
	ctx                context.Context
	ApiService         *AppElementApiService
	did                string
	vm                 string
	vmid               string
	eid                string
	bid                string
	contentDisposition *string
	ifNoneMatch        *string
	transactionId      *string
	changeId           *string
	linkDocumentId     *string
}

func (r ApiDownloadBlobSubelementRequest) ContentDisposition(contentDisposition string) ApiDownloadBlobSubelementRequest {
	r.contentDisposition = &contentDisposition
	return r
}

func (r ApiDownloadBlobSubelementRequest) IfNoneMatch(ifNoneMatch string) ApiDownloadBlobSubelementRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r ApiDownloadBlobSubelementRequest) TransactionId(transactionId string) ApiDownloadBlobSubelementRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiDownloadBlobSubelementRequest) ChangeId(changeId string) ApiDownloadBlobSubelementRequest {
	r.changeId = &changeId
	return r
}

func (r ApiDownloadBlobSubelementRequest) LinkDocumentId(linkDocumentId string) ApiDownloadBlobSubelementRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiDownloadBlobSubelementRequest) Execute() (*HttpFile, *http.Response, error) {
	return r.ApiService.DownloadBlobSubelementExecute(r)
}

/*
DownloadBlobSubelement Download blob subelement file by document ID, version or microversion ID, tab ID, and blob ID. A Subelement is used to store and organize data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param vm
 @param vmid
 @param eid
 @param bid
 @return ApiDownloadBlobSubelementRequest
*/
func (a *AppElementApiService) DownloadBlobSubelement(ctx context.Context, did string, vm string, vmid string, eid string, bid string) ApiDownloadBlobSubelementRequest {
	return ApiDownloadBlobSubelementRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		vm:         vm,
		vmid:       vmid,
		eid:        eid,
		bid:        bid,
	}
}

// Execute executes the request
//  @return HttpFile
func (a *AppElementApiService) DownloadBlobSubelementExecute(r ApiDownloadBlobSubelementRequest) (*HttpFile, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *HttpFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.DownloadBlobSubelement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{vm}/{vmid}/e/{eid}/blob/{bid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vm"+"}", url.PathEscape(parameterToString(r.vm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterToString(r.vmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bid"+"}", url.PathEscape(parameterToString(r.bid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contentDisposition != nil {
		localVarQueryParams.Add("contentDisposition", parameterToString(*r.contentDisposition, ""))
	}
	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.changeId != nil {
		localVarQueryParams.Add("changeId", parameterToString(*r.changeId, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v HttpFile
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadBlobSubelementWorkspaceRequest struct {
	ctx                context.Context
	ApiService         *AppElementApiService
	did                string
	wid                string
	eid                string
	bid                string
	contentDisposition *string
	ifNoneMatch        *string
	transactionId      *string
	changeId           *string
}

func (r ApiDownloadBlobSubelementWorkspaceRequest) ContentDisposition(contentDisposition string) ApiDownloadBlobSubelementWorkspaceRequest {
	r.contentDisposition = &contentDisposition
	return r
}

func (r ApiDownloadBlobSubelementWorkspaceRequest) IfNoneMatch(ifNoneMatch string) ApiDownloadBlobSubelementWorkspaceRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r ApiDownloadBlobSubelementWorkspaceRequest) TransactionId(transactionId string) ApiDownloadBlobSubelementWorkspaceRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiDownloadBlobSubelementWorkspaceRequest) ChangeId(changeId string) ApiDownloadBlobSubelementWorkspaceRequest {
	r.changeId = &changeId
	return r
}

func (r ApiDownloadBlobSubelementWorkspaceRequest) Execute() (*HttpFile, *http.Response, error) {
	return r.ApiService.DownloadBlobSubelementWorkspaceExecute(r)
}

/*
DownloadBlobSubelementWorkspace Download blob subelement as a file by document ID, workspace ID, tab ID, and blob ID. A Subelement is used to store and organize data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wid
 @param eid
 @param bid
 @return ApiDownloadBlobSubelementWorkspaceRequest
*/
func (a *AppElementApiService) DownloadBlobSubelementWorkspace(ctx context.Context, did string, wid string, eid string, bid string) ApiDownloadBlobSubelementWorkspaceRequest {
	return ApiDownloadBlobSubelementWorkspaceRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
		bid:        bid,
	}
}

// Execute executes the request
//  @return HttpFile
func (a *AppElementApiService) DownloadBlobSubelementWorkspaceExecute(r ApiDownloadBlobSubelementWorkspaceRequest) (*HttpFile, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *HttpFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.DownloadBlobSubelementWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/w/{wid}/e/{eid}/blob/{bid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bid"+"}", url.PathEscape(parameterToString(r.bid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contentDisposition != nil {
		localVarQueryParams.Add("contentDisposition", parameterToString(*r.contentDisposition, ""))
	}
	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.changeId != nil {
		localVarQueryParams.Add("changeId", parameterToString(*r.changeId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v HttpFile
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAppElementHistoryRequest struct {
	ctx        context.Context
	ApiService *AppElementApiService
	did        string
	eid        string
	wvm        string
	wvmid      string
}

func (r ApiGetAppElementHistoryRequest) Execute() (*BTAppElementHistoryInfo, *http.Response, error) {
	return r.ApiService.GetAppElementHistoryExecute(r)
}

/*
GetAppElementHistory Retrieve history by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param eid
 @param wvm
 @param wvmid
 @return ApiGetAppElementHistoryRequest
*/
func (a *AppElementApiService) GetAppElementHistory(ctx context.Context, did string, eid string, wvm string, wvmid string) ApiGetAppElementHistoryRequest {
	return ApiGetAppElementHistoryRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wvm:        wvm,
		wvmid:      wvmid,
	}
}

// Execute executes the request
//  @return BTAppElementHistoryInfo
func (a *AppElementApiService) GetAppElementHistoryExecute(r ApiGetAppElementHistoryRequest) (*BTAppElementHistoryInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementHistoryInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.GetAppElementHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/history"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementHistoryInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlobSubelementIdsRequest struct {
	ctx           context.Context
	ApiService    *AppElementApiService
	did           string
	eid           string
	wvm           string
	wvmid         string
	transactionId *string
	changeId      *string
}

func (r ApiGetBlobSubelementIdsRequest) TransactionId(transactionId string) ApiGetBlobSubelementIdsRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiGetBlobSubelementIdsRequest) ChangeId(changeId string) ApiGetBlobSubelementIdsRequest {
	r.changeId = &changeId
	return r
}

func (r ApiGetBlobSubelementIdsRequest) Execute() (*BTAppElementIdsInfo, *http.Response, error) {
	return r.ApiService.GetBlobSubelementIdsExecute(r)
}

/*
GetBlobSubelementIds Retrieve an array of blob subelement IDs by document ID and workspace or microversion ID. A Subelement is used to store and organize data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param eid
 @param wvm
 @param wvmid
 @return ApiGetBlobSubelementIdsRequest
*/
func (a *AppElementApiService) GetBlobSubelementIds(ctx context.Context, did string, eid string, wvm string, wvmid string) ApiGetBlobSubelementIdsRequest {
	return ApiGetBlobSubelementIdsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wvm:        wvm,
		wvmid:      wvmid,
	}
}

// Execute executes the request
//  @return BTAppElementIdsInfo
func (a *AppElementApiService) GetBlobSubelementIdsExecute(r ApiGetBlobSubelementIdsRequest) (*BTAppElementIdsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementIdsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.GetBlobSubelementIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/blob"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.changeId != nil {
		localVarQueryParams.Add("changeId", parameterToString(*r.changeId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementIdsInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetElementTransactionsRequest struct {
	ctx        context.Context
	ApiService *AppElementApiService
	did        string
	eid        string
	wid        string
}

func (r ApiGetElementTransactionsRequest) Execute() (*BTAppElementTransactionsInfo, *http.Response, error) {
	return r.ApiService.GetElementTransactionsExecute(r)
}

/*
GetElementTransactions Retrieve an array of tab transactions by document ID, workspace ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param eid
 @param wid
 @return ApiGetElementTransactionsRequest
*/
func (a *AppElementApiService) GetElementTransactions(ctx context.Context, did string, eid string, wid string) ApiGetElementTransactionsRequest {
	return ApiGetElementTransactionsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wid:        wid,
	}
}

// Execute executes the request
//  @return BTAppElementTransactionsInfo
func (a *AppElementApiService) GetElementTransactionsExecute(r ApiGetElementTransactionsRequest) (*BTAppElementTransactionsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementTransactionsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.GetElementTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/w/{wid}/e/{eid}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementTransactionsInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJsonRequest struct {
	ctx            context.Context
	ApiService     *AppElementApiService
	did            string
	wvm            string
	wvmid          string
	eid            string
	linkDocumentId *string
	transactionId  *string
	changeId       *string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetJsonRequest) LinkDocumentId(linkDocumentId string) ApiGetJsonRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// The id of the transaction in which this operation should take place. Transaction ids can be generated through the AppElement startTransaction API.
func (r ApiGetJsonRequest) TransactionId(transactionId string) ApiGetJsonRequest {
	r.transactionId = &transactionId
	return r
}

// The id of the last change made to this application element. This can be retrieved from the response for any app element modification endpoint.
func (r ApiGetJsonRequest) ChangeId(changeId string) ApiGetJsonRequest {
	r.changeId = &changeId
	return r
}

func (r ApiGetJsonRequest) Execute() (*BTGetJsonResponse2137, *http.Response, error) {
	return r.ApiService.GetJsonExecute(r)
}

/*
GetJson Retrieve JSON by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
 @param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @return ApiGetJsonRequest
*/
func (a *AppElementApiService) GetJson(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetJsonRequest {
	return ApiGetJsonRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTGetJsonResponse2137
func (a *AppElementApiService) GetJsonExecute(r ApiGetJsonRequest) (*BTGetJsonResponse2137, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTGetJsonResponse2137
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.GetJson")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/json"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.changeId != nil {
		localVarQueryParams.Add("changeId", parameterToString(*r.changeId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTGetJsonResponse2137
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJsonPathsRequest struct {
	ctx                context.Context
	ApiService         *AppElementApiService
	did                string
	eid                string
	wvm                string
	wvmid              string
	transactionId      *string
	changeId           *string
	bTGetJsonPaths1697 *BTGetJsonPaths1697
}

func (r ApiGetJsonPathsRequest) TransactionId(transactionId string) ApiGetJsonPathsRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiGetJsonPathsRequest) ChangeId(changeId string) ApiGetJsonPathsRequest {
	r.changeId = &changeId
	return r
}

func (r ApiGetJsonPathsRequest) BTGetJsonPaths1697(bTGetJsonPaths1697 BTGetJsonPaths1697) ApiGetJsonPathsRequest {
	r.bTGetJsonPaths1697 = &bTGetJsonPaths1697
	return r
}

func (r ApiGetJsonPathsRequest) Execute() (*BTGetJsonPathsResponse1544, *http.Response, error) {
	return r.ApiService.GetJsonPathsExecute(r)
}

/*
GetJsonPaths Retrieve JSON paths by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param eid
 @param wvm
 @param wvmid
 @return ApiGetJsonPathsRequest
*/
func (a *AppElementApiService) GetJsonPaths(ctx context.Context, did string, eid string, wvm string, wvmid string) ApiGetJsonPathsRequest {
	return ApiGetJsonPathsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wvm:        wvm,
		wvmid:      wvmid,
	}
}

// Execute executes the request
//  @return BTGetJsonPathsResponse1544
func (a *AppElementApiService) GetJsonPathsExecute(r ApiGetJsonPathsRequest) (*BTGetJsonPathsResponse1544, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTGetJsonPathsResponse1544
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.GetJsonPaths")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/jsonpaths"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.changeId != nil {
		localVarQueryParams.Add("changeId", parameterToString(*r.changeId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTGetJsonPaths1697
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTGetJsonPathsResponse1544
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubElementContentRequest struct {
	ctx            context.Context
	ApiService     *AppElementApiService
	did            string
	wvm            string
	wvmid          string
	eid            string
	linkDocumentId *string
	transactionId  *string
	changeId       *string
	baseChangeId   *string
	subelementId   *string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetSubElementContentRequest) LinkDocumentId(linkDocumentId string) ApiGetSubElementContentRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetSubElementContentRequest) TransactionId(transactionId string) ApiGetSubElementContentRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiGetSubElementContentRequest) ChangeId(changeId string) ApiGetSubElementContentRequest {
	r.changeId = &changeId
	return r
}

func (r ApiGetSubElementContentRequest) BaseChangeId(baseChangeId string) ApiGetSubElementContentRequest {
	r.baseChangeId = &baseChangeId
	return r
}

func (r ApiGetSubElementContentRequest) SubelementId(subelementId string) ApiGetSubElementContentRequest {
	r.subelementId = &subelementId
	return r
}

func (r ApiGetSubElementContentRequest) Execute() (*BTAppElementContentInfo, *http.Response, error) {
	return r.ApiService.GetSubElementContentExecute(r)
}

/*
GetSubElementContent Retrieve subelement content by document ID, tab ID, and workspace or version or microversion ID. A Subelement is used to store and organize data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
 @param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @return ApiGetSubElementContentRequest
*/
func (a *AppElementApiService) GetSubElementContent(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetSubElementContentRequest {
	return ApiGetSubElementContentRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTAppElementContentInfo
func (a *AppElementApiService) GetSubElementContentExecute(r ApiGetSubElementContentRequest) (*BTAppElementContentInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementContentInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.GetSubElementContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.changeId != nil {
		localVarQueryParams.Add("changeId", parameterToString(*r.changeId, ""))
	}
	if r.baseChangeId != nil {
		localVarQueryParams.Add("baseChangeId", parameterToString(*r.baseChangeId, ""))
	}
	if r.subelementId != nil {
		localVarQueryParams.Add("subelementId", parameterToString(*r.subelementId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementContentInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubelementIdsRequest struct {
	ctx           context.Context
	ApiService    *AppElementApiService
	did           string
	eid           string
	wvm           string
	wvmid         string
	transactionId *string
	changeId      *string
}

func (r ApiGetSubelementIdsRequest) TransactionId(transactionId string) ApiGetSubelementIdsRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiGetSubelementIdsRequest) ChangeId(changeId string) ApiGetSubelementIdsRequest {
	r.changeId = &changeId
	return r
}

func (r ApiGetSubelementIdsRequest) Execute() (*BTAppElementIdsInfo, *http.Response, error) {
	return r.ApiService.GetSubelementIdsExecute(r)
}

/*
GetSubelementIds Retrieve subelement IDs by document ID, workspace or version or microversion ID, and tab ID. A Subelement is used to store and organize data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param eid
 @param wvm
 @param wvmid
 @return ApiGetSubelementIdsRequest
*/
func (a *AppElementApiService) GetSubelementIds(ctx context.Context, did string, eid string, wvm string, wvmid string) ApiGetSubelementIdsRequest {
	return ApiGetSubelementIdsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wvm:        wvm,
		wvmid:      wvmid,
	}
}

// Execute executes the request
//  @return BTAppElementIdsInfo
func (a *AppElementApiService) GetSubelementIdsExecute(r ApiGetSubelementIdsRequest) (*BTAppElementIdsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementIdsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.GetSubelementIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/ids"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.changeId != nil {
		localVarQueryParams.Add("changeId", parameterToString(*r.changeId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementIdsInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResolveReferenceRequest struct {
	ctx             context.Context
	ApiService      *AppElementApiService
	did             string
	eid             string
	wvm             string
	wvmid           string
	rid             string
	transactionId   *string
	parentChangeId  *string
	includeInternal *bool
	linkDocumentId  *string
}

func (r ApiResolveReferenceRequest) TransactionId(transactionId string) ApiResolveReferenceRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiResolveReferenceRequest) ParentChangeId(parentChangeId string) ApiResolveReferenceRequest {
	r.parentChangeId = &parentChangeId
	return r
}

func (r ApiResolveReferenceRequest) IncludeInternal(includeInternal bool) ApiResolveReferenceRequest {
	r.includeInternal = &includeInternal
	return r
}

func (r ApiResolveReferenceRequest) LinkDocumentId(linkDocumentId string) ApiResolveReferenceRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiResolveReferenceRequest) Execute() (*BTAppElementReferenceResolveInfo, *http.Response, error) {
	return r.ApiService.ResolveReferenceExecute(r)
}

/*
ResolveReference Resolve references by document ID, workspace or version or microversion ID, tab ID and resolve ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param eid
 @param wvm
 @param wvmid
 @param rid
 @return ApiResolveReferenceRequest
*/
func (a *AppElementApiService) ResolveReference(ctx context.Context, did string, eid string, wvm string, wvmid string, rid string) ApiResolveReferenceRequest {
	return ApiResolveReferenceRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wvm:        wvm,
		wvmid:      wvmid,
		rid:        rid,
	}
}

// Execute executes the request
//  @return BTAppElementReferenceResolveInfo
func (a *AppElementApiService) ResolveReferenceExecute(r ApiResolveReferenceRequest) (*BTAppElementReferenceResolveInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementReferenceResolveInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.ResolveReference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/references/{rid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rid"+"}", url.PathEscape(parameterToString(r.rid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.parentChangeId != nil {
		localVarQueryParams.Add("parentChangeId", parameterToString(*r.parentChangeId, ""))
	}
	if r.includeInternal != nil {
		localVarQueryParams.Add("includeInternal", parameterToString(*r.includeInternal, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementReferenceResolveInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResolveReferencesRequest struct {
	ctx             context.Context
	ApiService      *AppElementApiService
	did             string
	wvm             string
	wvmid           string
	eid             string
	linkDocumentId  *string
	transactionId   *string
	parentChangeId  *string
	includeInternal *bool
	referenceIds    *string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiResolveReferencesRequest) LinkDocumentId(linkDocumentId string) ApiResolveReferencesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiResolveReferencesRequest) TransactionId(transactionId string) ApiResolveReferencesRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiResolveReferencesRequest) ParentChangeId(parentChangeId string) ApiResolveReferencesRequest {
	r.parentChangeId = &parentChangeId
	return r
}

func (r ApiResolveReferencesRequest) IncludeInternal(includeInternal bool) ApiResolveReferencesRequest {
	r.includeInternal = &includeInternal
	return r
}

func (r ApiResolveReferencesRequest) ReferenceIds(referenceIds string) ApiResolveReferencesRequest {
	r.referenceIds = &referenceIds
	return r
}

func (r ApiResolveReferencesRequest) Execute() (*BTAppElementReferencesResolveInfo, *http.Response, error) {
	return r.ApiService.ResolveReferencesExecute(r)
}

/*
ResolveReferences Resolve references by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
 @param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @return ApiResolveReferencesRequest
*/
func (a *AppElementApiService) ResolveReferences(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiResolveReferencesRequest {
	return ApiResolveReferencesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTAppElementReferencesResolveInfo
func (a *AppElementApiService) ResolveReferencesExecute(r ApiResolveReferencesRequest) (*BTAppElementReferencesResolveInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementReferencesResolveInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.ResolveReferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/resolvereferences"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.parentChangeId != nil {
		localVarQueryParams.Add("parentChangeId", parameterToString(*r.parentChangeId, ""))
	}
	if r.includeInternal != nil {
		localVarQueryParams.Add("includeInternal", parameterToString(*r.includeInternal, ""))
	}
	if r.referenceIds != nil {
		localVarQueryParams.Add("referenceIds", parameterToString(*r.referenceIds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementReferencesResolveInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartTransactionRequest struct {
	ctx                                context.Context
	ApiService                         *AppElementApiService
	did                                string
	eid                                string
	wid                                string
	bTAppElementStartTransactionParams *BTAppElementStartTransactionParams
}

func (r ApiStartTransactionRequest) BTAppElementStartTransactionParams(bTAppElementStartTransactionParams BTAppElementStartTransactionParams) ApiStartTransactionRequest {
	r.bTAppElementStartTransactionParams = &bTAppElementStartTransactionParams
	return r
}

func (r ApiStartTransactionRequest) Execute() (*BTAppElementModifyInfo, *http.Response, error) {
	return r.ApiService.StartTransactionExecute(r)
}

/*
StartTransaction Start application tab transaction by document ID, workspace ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param eid
 @param wid
 @return ApiStartTransactionRequest
*/
func (a *AppElementApiService) StartTransaction(ctx context.Context, did string, eid string, wid string) ApiStartTransactionRequest {
	return ApiStartTransactionRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wid:        wid,
	}
}

// Execute executes the request
//  @return BTAppElementModifyInfo
func (a *AppElementApiService) StartTransactionExecute(r ApiStartTransactionRequest) (*BTAppElementModifyInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementModifyInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.StartTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/w/{wid}/e/{eid}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTAppElementStartTransactionParams == nil {
		return localVarReturnValue, nil, reportError("bTAppElementStartTransactionParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAppElementStartTransactionParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementModifyInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAppElementRequest struct {
	ctx                      context.Context
	ApiService               *AppElementApiService
	did                      string
	eid                      string
	wvm                      string
	wvmid                    string
	bTAppElementUpdateParams *BTAppElementUpdateParams
}

func (r ApiUpdateAppElementRequest) BTAppElementUpdateParams(bTAppElementUpdateParams BTAppElementUpdateParams) ApiUpdateAppElementRequest {
	r.bTAppElementUpdateParams = &bTAppElementUpdateParams
	return r
}

func (r ApiUpdateAppElementRequest) Execute() (*BTAppElementModifyInfo, *http.Response, error) {
	return r.ApiService.UpdateAppElementExecute(r)
}

/*
UpdateAppElement Update application tab by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param eid
 @param wvm
 @param wvmid
 @return ApiUpdateAppElementRequest
*/
func (a *AppElementApiService) UpdateAppElement(ctx context.Context, did string, eid string, wvm string, wvmid string) ApiUpdateAppElementRequest {
	return ApiUpdateAppElementRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wvm:        wvm,
		wvmid:      wvmid,
	}
}

// Execute executes the request
//  @return BTAppElementModifyInfo
func (a *AppElementApiService) UpdateAppElementExecute(r ApiUpdateAppElementRequest) (*BTAppElementModifyInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementModifyInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.UpdateAppElement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAppElementUpdateParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementModifyInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateReferenceRequest struct {
	ctx                         context.Context
	ApiService                  *AppElementApiService
	did                         string
	eid                         string
	wvm                         string
	wvmid                       string
	rid                         string
	bTAppElementReferenceParams *BTAppElementReferenceParams
}

func (r ApiUpdateReferenceRequest) BTAppElementReferenceParams(bTAppElementReferenceParams BTAppElementReferenceParams) ApiUpdateReferenceRequest {
	r.bTAppElementReferenceParams = &bTAppElementReferenceParams
	return r
}

func (r ApiUpdateReferenceRequest) Execute() (*BTAppElementReferenceInfo, *http.Response, error) {
	return r.ApiService.UpdateReferenceExecute(r)
}

/*
UpdateReference Update references by document ID, workspace or version or microversion ID, tab ID, and resolve ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param eid
 @param wvm
 @param wvmid
 @param rid
 @return ApiUpdateReferenceRequest
*/
func (a *AppElementApiService) UpdateReference(ctx context.Context, did string, eid string, wvm string, wvmid string, rid string) ApiUpdateReferenceRequest {
	return ApiUpdateReferenceRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wvm:        wvm,
		wvmid:      wvmid,
		rid:        rid,
	}
}

// Execute executes the request
//  @return BTAppElementReferenceInfo
func (a *AppElementApiService) UpdateReferenceExecute(r ApiUpdateReferenceRequest) (*BTAppElementReferenceInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementReferenceInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.UpdateReference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/references/{rid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rid"+"}", url.PathEscape(parameterToString(r.rid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTAppElementReferenceParams == nil {
		return localVarReturnValue, nil, reportError("bTAppElementReferenceParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAppElementReferenceParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementReferenceInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadBlobSubelementRequest struct {
	ctx               context.Context
	ApiService        *AppElementApiService
	did               string
	wid               string
	eid               string
	bid               string
	transactionId     *string
	parentChangeId    *string
	description       *string
	file              *HttpFile
	fileContentLength *int64
}

func (r ApiUploadBlobSubelementRequest) TransactionId(transactionId string) ApiUploadBlobSubelementRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiUploadBlobSubelementRequest) ParentChangeId(parentChangeId string) ApiUploadBlobSubelementRequest {
	r.parentChangeId = &parentChangeId
	return r
}

func (r ApiUploadBlobSubelementRequest) Description(description string) ApiUploadBlobSubelementRequest {
	r.description = &description
	return r
}

// File to upload.
func (r ApiUploadBlobSubelementRequest) File(file HttpFile) ApiUploadBlobSubelementRequest {
	r.file = &file
	return r
}

func (r ApiUploadBlobSubelementRequest) FileContentLength(fileContentLength int64) ApiUploadBlobSubelementRequest {
	r.fileContentLength = &fileContentLength
	return r
}

func (r ApiUploadBlobSubelementRequest) Execute() (*BTAppElementModifyInfo, *http.Response, error) {
	return r.ApiService.UploadBlobSubelementExecute(r)
}

/*
UploadBlobSubelement Upload blob subelement file by document ID, workspace ID, tab ID, and blob ID. A Subelement is used to store and organize data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wid
 @param eid
 @param bid
 @return ApiUploadBlobSubelementRequest
*/
func (a *AppElementApiService) UploadBlobSubelement(ctx context.Context, did string, wid string, eid string, bid string) ApiUploadBlobSubelementRequest {
	return ApiUploadBlobSubelementRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
		bid:        bid,
	}
}

// Execute executes the request
//  @return BTAppElementModifyInfo
func (a *AppElementApiService) UploadBlobSubelementExecute(r ApiUploadBlobSubelementRequest) (*BTAppElementModifyInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementModifyInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.UploadBlobSubelement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/w/{wid}/e/{eid}/blob/{bid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bid"+"}", url.PathEscape(parameterToString(r.bid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.transactionId != nil {
		localVarFormParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.parentChangeId != nil {
		localVarFormParams.Add("parentChangeId", parameterToString(*r.parentChangeId, ""))
	}
	if r.description != nil {
		localVarFormParams.Add("description", parameterToString(*r.description, ""))
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName string
	var fileLocalVarFileBytes io.Reader

	fileLocalVarFormFileName = "file"

	var fileLocalVarFile *HttpFile
	if r.file != nil {
		fileLocalVarFile = r.file
	}
	if fileLocalVarFile != nil {
		fileLocalVarFileBytes = fileLocalVarFile.Data
		fileLocalVarFileName = fileLocalVarFile.Name
	}
	formFiles = append(formFiles, formFile{fileData: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	if r.fileContentLength != nil {
		localVarFormParams.Add("fileContentLength", parameterToString(*r.fileContentLength, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementModifyInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
