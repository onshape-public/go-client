/*
Onshape REST API

## Welcome to the Onshape REST API Explorer  To use this API explorer, sign in to your [Onshape](https://cad.onshape.com) account in another tab, then click the **Try it out** button below (it toggles to a **Cancel** button when selected).  See the **[API Explorer Guide](https://onshape-public.github.io/docs/api-intro/explorer/)** for help navigating this API Explorer, including **[authentication](https://onshape-public.github.io/docs/api-intro/explorer/#authentication)**.  **Tip:** To ensure the current session isn't used when trying other authentication techniques, make sure to [remove the Onshape cookie](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site) as per the instructions for your browser. Alternatively, you can use a private or incognito window.  ## See Also  * [Onshape API Guide](https://onshape-public.github.io/docs/): Our full suite of developer guides, to be used as an accompaniment to this API Explorer. * [Onshape Developer Portal](https://dev-portal.onshape.com/): The Onshape portal for managing your API keys, OAuth2 credentials, your Onshape applications, and your Onshape App Store entries. * [Authentication Guide](https://onshape-public.github.io/docs/auth/): Our guide to using API keys, request signatures, and OAuth2 in  your Onshape applications.

Contact: api-support@onshape.zendesk.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package onshape

import (
	"context"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// AppElementApiService AppElementApi service
type AppElementApiService service

type ApiAbortTransactionRequest struct {
	ctx         context.Context
	ApiService  *AppElementApiService
	did         string
	eid         string
	wid         string
	tid         string
	returnError *bool
}

func (r ApiAbortTransactionRequest) ReturnError(returnError bool) ApiAbortTransactionRequest {
	r.returnError = &returnError
	return r
}

func (r ApiAbortTransactionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AbortTransactionExecute(r)
}

/*
AbortTransaction Abort a transaction.

Deletes a microbranch (i.e., the branch with the microversion for the transaction).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param eid
	@param wid
	@param tid
	@return ApiAbortTransactionRequest
*/
func (a *AppElementApiService) AbortTransaction(ctx context.Context, did string, eid string, wid string, tid string) ApiAbortTransactionRequest {
	return ApiAbortTransactionRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wid:        wid,
		tid:        tid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *AppElementApiService) AbortTransactionExecute(r ApiAbortTransactionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.AbortTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/w/{wid}/e/{eid}/transactions/{tid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tid"+"}", url.PathEscape(parameterToString(r.tid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returnError != nil {
		localVarQueryParams.Add("returnError", parameterToString(*r.returnError, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkCreateElementRequest struct {
	ctx                          context.Context
	ApiService                   *AppElementApiService
	did                          string
	wid                          string
	bTAppElementBulkCreateParams *BTAppElementBulkCreateParams
	linkDocumentId               *string
}

func (r ApiBulkCreateElementRequest) BTAppElementBulkCreateParams(bTAppElementBulkCreateParams BTAppElementBulkCreateParams) ApiBulkCreateElementRequest {
	r.bTAppElementBulkCreateParams = &bTAppElementBulkCreateParams
	return r
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiBulkCreateElementRequest) LinkDocumentId(linkDocumentId string) ApiBulkCreateElementRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiBulkCreateElementRequest) Execute() (*BTAppElementBulkCreateInfo, *http.Response, error) {
	return r.ApiService.BulkCreateElementExecute(r)
}

/*
BulkCreateElement Create multiple empty application elements at once.

Call this faster API instead of creating multiple app elements one at a time or in parallel.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wid The id of the workspace in which to perform the operation.
	@return ApiBulkCreateElementRequest
*/
func (a *AppElementApiService) BulkCreateElement(ctx context.Context, did string, wid string) ApiBulkCreateElementRequest {
	return ApiBulkCreateElementRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
	}
}

// Execute executes the request
//
//	@return BTAppElementBulkCreateInfo
func (a *AppElementApiService) BulkCreateElementExecute(r ApiBulkCreateElementRequest) (*BTAppElementBulkCreateInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementBulkCreateInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.BulkCreateElement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/w/{wid}/bulkcreate"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTAppElementBulkCreateParams == nil {
		return localVarReturnValue, nil, reportError("bTAppElementBulkCreateParams is required and must be specified")
	}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAppElementBulkCreateParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementBulkCreateInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCommitTransactionsRequest struct {
	ctx                                 context.Context
	ApiService                          *AppElementApiService
	did                                 string
	wid                                 string
	bTAppElementCommitTransactionParams *BTAppElementCommitTransactionParams
	linkDocumentId                      *string
}

func (r ApiCommitTransactionsRequest) BTAppElementCommitTransactionParams(bTAppElementCommitTransactionParams BTAppElementCommitTransactionParams) ApiCommitTransactionsRequest {
	r.bTAppElementCommitTransactionParams = &bTAppElementCommitTransactionParams
	return r
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiCommitTransactionsRequest) LinkDocumentId(linkDocumentId string) ApiCommitTransactionsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiCommitTransactionsRequest) Execute() (*BTAppElementModifyInfo, *http.Response, error) {
	return r.ApiService.CommitTransactionsExecute(r)
}

/*
CommitTransactions Merge multiple transactions into one microversion.

If successful, all transactions will be committed to a single microversion. If the call raises an error, nothing will be committed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wid The id of the workspace in which to perform the operation.
	@return ApiCommitTransactionsRequest
*/
func (a *AppElementApiService) CommitTransactions(ctx context.Context, did string, wid string) ApiCommitTransactionsRequest {
	return ApiCommitTransactionsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
	}
}

// Execute executes the request
//
//	@return BTAppElementModifyInfo
func (a *AppElementApiService) CommitTransactionsExecute(r ApiCommitTransactionsRequest) (*BTAppElementModifyInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementModifyInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.CommitTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/w/{wid}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTAppElementCommitTransactionParams == nil {
		return localVarReturnValue, nil, reportError("bTAppElementCommitTransactionParams is required and must be specified")
	}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAppElementCommitTransactionParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementModifyInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCompareAppElementJsonRequest struct {
	ctx                  context.Context
	ApiService           *AppElementApiService
	did                  string
	wvm                  string
	wvmid                string
	eid                  string
	workspaceId          *string
	versionId            *string
	microversionId       *string
	linkDocumentId       *string
	jsonDifferenceFormat *string
}

func (r ApiCompareAppElementJsonRequest) WorkspaceId(workspaceId string) ApiCompareAppElementJsonRequest {
	r.workspaceId = &workspaceId
	return r
}

func (r ApiCompareAppElementJsonRequest) VersionId(versionId string) ApiCompareAppElementJsonRequest {
	r.versionId = &versionId
	return r
}

func (r ApiCompareAppElementJsonRequest) MicroversionId(microversionId string) ApiCompareAppElementJsonRequest {
	r.microversionId = &microversionId
	return r
}

func (r ApiCompareAppElementJsonRequest) LinkDocumentId(linkDocumentId string) ApiCompareAppElementJsonRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiCompareAppElementJsonRequest) JsonDifferenceFormat(jsonDifferenceFormat string) ApiCompareAppElementJsonRequest {
	r.jsonDifferenceFormat = &jsonDifferenceFormat
	return r
}

func (r ApiCompareAppElementJsonRequest) Execute() (*BTDiffJsonResponse2725, *http.Response, error) {
	return r.ApiService.CompareAppElementJsonExecute(r)
}

/*
CompareAppElementJson Compare app element JSON trees between workspaces/versions/microversions in a document.

Specify the source workspace/version/microversion in the URL and specify the target workspace/version/microversion in the query parameters.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param wvm
	@param wvmid
	@param eid
	@return ApiCompareAppElementJsonRequest
*/
func (a *AppElementApiService) CompareAppElementJson(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiCompareAppElementJsonRequest {
	return ApiCompareAppElementJsonRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTDiffJsonResponse2725
func (a *AppElementApiService) CompareAppElementJsonExecute(r ApiCompareAppElementJsonRequest) (*BTDiffJsonResponse2725, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTDiffJsonResponse2725
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.CompareAppElementJson")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/compare"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.workspaceId != nil {
		localVarQueryParams.Add("workspaceId", parameterToString(*r.workspaceId, ""))
	}
	if r.versionId != nil {
		localVarQueryParams.Add("versionId", parameterToString(*r.versionId, ""))
	}
	if r.microversionId != nil {
		localVarQueryParams.Add("microversionId", parameterToString(*r.microversionId, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.jsonDifferenceFormat != nil {
		localVarQueryParams.Add("jsonDifferenceFormat", parameterToString(*r.jsonDifferenceFormat, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTDiffJsonResponse2725
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateElementRequest struct {
	ctx                context.Context
	ApiService         *AppElementApiService
	did                string
	wid                string
	bTAppElementParams *BTAppElementParams
	linkDocumentId     *string
}

func (r ApiCreateElementRequest) BTAppElementParams(bTAppElementParams BTAppElementParams) ApiCreateElementRequest {
	r.bTAppElementParams = &bTAppElementParams
	return r
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiCreateElementRequest) LinkDocumentId(linkDocumentId string) ApiCreateElementRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiCreateElementRequest) Execute() (*BTAppElementModifyInfo, *http.Response, error) {
	return r.ApiService.CreateElementExecute(r)
}

/*
CreateElement Create a new application element.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wid The id of the workspace in which to perform the operation.
	@return ApiCreateElementRequest
*/
func (a *AppElementApiService) CreateElement(ctx context.Context, did string, wid string) ApiCreateElementRequest {
	return ApiCreateElementRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
	}
}

// Execute executes the request
//
//	@return BTAppElementModifyInfo
func (a *AppElementApiService) CreateElementExecute(r ApiCreateElementRequest) (*BTAppElementModifyInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementModifyInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.CreateElement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/w/{wid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTAppElementParams == nil {
		return localVarReturnValue, nil, reportError("bTAppElementParams is required and must be specified")
	}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAppElementParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementModifyInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateReferenceRequest struct {
	ctx                         context.Context
	ApiService                  *AppElementApiService
	did                         string
	eid                         string
	wvm                         string
	wvmid                       string
	bTAppElementReferenceParams *BTAppElementReferenceParams
}

func (r ApiCreateReferenceRequest) BTAppElementReferenceParams(bTAppElementReferenceParams BTAppElementReferenceParams) ApiCreateReferenceRequest {
	r.bTAppElementReferenceParams = &bTAppElementReferenceParams
	return r
}

func (r ApiCreateReferenceRequest) Execute() (*BTAppElementReferenceInfo, *http.Response, error) {
	return r.ApiService.CreateReferenceExecute(r)
}

/*
CreateReference Creates a reference to an app element.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param eid
	@param wvm
	@param wvmid
	@return ApiCreateReferenceRequest
*/
func (a *AppElementApiService) CreateReference(ctx context.Context, did string, eid string, wvm string, wvmid string) ApiCreateReferenceRequest {
	return ApiCreateReferenceRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wvm:        wvm,
		wvmid:      wvmid,
	}
}

// Execute executes the request
//
//	@return BTAppElementReferenceInfo
func (a *AppElementApiService) CreateReferenceExecute(r ApiCreateReferenceRequest) (*BTAppElementReferenceInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementReferenceInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.CreateReference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/references"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTAppElementReferenceParams == nil {
		return localVarReturnValue, nil, reportError("bTAppElementReferenceParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAppElementReferenceParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementReferenceInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAppElementContentRequest struct {
	ctx            context.Context
	ApiService     *AppElementApiService
	did            string
	eid            string
	wvm            string
	wvmid          string
	sid            string
	transactionId  *string
	parentChangeId *string
	description    *string
}

func (r ApiDeleteAppElementContentRequest) TransactionId(transactionId string) ApiDeleteAppElementContentRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiDeleteAppElementContentRequest) ParentChangeId(parentChangeId string) ApiDeleteAppElementContentRequest {
	r.parentChangeId = &parentChangeId
	return r
}

func (r ApiDeleteAppElementContentRequest) Description(description string) ApiDeleteAppElementContentRequest {
	r.description = &description
	return r
}

func (r ApiDeleteAppElementContentRequest) Execute() (*BTAppElementModifyInfo, *http.Response, error) {
	return r.ApiService.DeleteAppElementContentExecute(r)
}

/*
DeleteAppElementContent Deletes the content from the specified app element.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param eid
	@param wvm
	@param wvmid
	@param sid
	@return ApiDeleteAppElementContentRequest
*/
func (a *AppElementApiService) DeleteAppElementContent(ctx context.Context, did string, eid string, wvm string, wvmid string, sid string) ApiDeleteAppElementContentRequest {
	return ApiDeleteAppElementContentRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wvm:        wvm,
		wvmid:      wvmid,
		sid:        sid,
	}
}

// Execute executes the request
//
//	@return BTAppElementModifyInfo
func (a *AppElementApiService) DeleteAppElementContentExecute(r ApiDeleteAppElementContentRequest) (*BTAppElementModifyInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementModifyInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.DeleteAppElementContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/subelements/{sid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.parentChangeId != nil {
		localVarQueryParams.Add("parentChangeId", parameterToString(*r.parentChangeId, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementModifyInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAppElementContentBatchRequest struct {
	ctx            context.Context
	ApiService     *AppElementApiService
	did            string
	eid            string
	wvm            string
	wvmid          string
	subelementIds  *[]string
	transactionId  *string
	parentChangeId *string
	description    *string
}

func (r ApiDeleteAppElementContentBatchRequest) SubelementIds(subelementIds []string) ApiDeleteAppElementContentBatchRequest {
	r.subelementIds = &subelementIds
	return r
}

func (r ApiDeleteAppElementContentBatchRequest) TransactionId(transactionId string) ApiDeleteAppElementContentBatchRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiDeleteAppElementContentBatchRequest) ParentChangeId(parentChangeId string) ApiDeleteAppElementContentBatchRequest {
	r.parentChangeId = &parentChangeId
	return r
}

func (r ApiDeleteAppElementContentBatchRequest) Description(description string) ApiDeleteAppElementContentBatchRequest {
	r.description = &description
	return r
}

func (r ApiDeleteAppElementContentBatchRequest) Execute() (*BTAppElementModifyInfo, *http.Response, error) {
	return r.ApiService.DeleteAppElementContentBatchExecute(r)
}

/*
DeleteAppElementContentBatch Delete multiple subelements array by document ID, workspace or version or microversion ID, tab ID, and subelement IDs.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param eid
	@param wvm
	@param wvmid
	@return ApiDeleteAppElementContentBatchRequest
*/
func (a *AppElementApiService) DeleteAppElementContentBatch(ctx context.Context, did string, eid string, wvm string, wvmid string) ApiDeleteAppElementContentBatchRequest {
	return ApiDeleteAppElementContentBatchRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wvm:        wvm,
		wvmid:      wvmid,
	}
}

// Execute executes the request
//
//	@return BTAppElementModifyInfo
func (a *AppElementApiService) DeleteAppElementContentBatchExecute(r ApiDeleteAppElementContentBatchRequest) (*BTAppElementModifyInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementModifyInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.DeleteAppElementContentBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/subelements"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.subelementIds != nil {
		t := *r.subelementIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("subelementIds", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("subelementIds", parameterToString(t, "multi"))
		}
	}
	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.parentChangeId != nil {
		localVarQueryParams.Add("parentChangeId", parameterToString(*r.parentChangeId, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementModifyInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBlobSubelementRequest struct {
	ctx           context.Context
	ApiService    *AppElementApiService
	did           string
	wid           string
	eid           string
	bid           string
	transactionId *string
	changeId      *string
}

func (r ApiDeleteBlobSubelementRequest) TransactionId(transactionId string) ApiDeleteBlobSubelementRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiDeleteBlobSubelementRequest) ChangeId(changeId string) ApiDeleteBlobSubelementRequest {
	r.changeId = &changeId
	return r
}

func (r ApiDeleteBlobSubelementRequest) Execute() (*BTAppElementModifyInfo, *http.Response, error) {
	return r.ApiService.DeleteBlobSubelementExecute(r)
}

/*
DeleteBlobSubelement Delete a blob subelement from an app element.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param wid
	@param eid
	@param bid
	@return ApiDeleteBlobSubelementRequest
*/
func (a *AppElementApiService) DeleteBlobSubelement(ctx context.Context, did string, wid string, eid string, bid string) ApiDeleteBlobSubelementRequest {
	return ApiDeleteBlobSubelementRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
		bid:        bid,
	}
}

// Execute executes the request
//
//	@return BTAppElementModifyInfo
func (a *AppElementApiService) DeleteBlobSubelementExecute(r ApiDeleteBlobSubelementRequest) (*BTAppElementModifyInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementModifyInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.DeleteBlobSubelement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/w/{wid}/e/{eid}/blob/{bid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bid"+"}", url.PathEscape(parameterToString(r.bid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.changeId != nil {
		localVarQueryParams.Add("changeId", parameterToString(*r.changeId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementModifyInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteReferenceRequest struct {
	ctx            context.Context
	ApiService     *AppElementApiService
	did            string
	eid            string
	wvm            string
	wvmid          string
	rid            string
	transactionId  *string
	parentChangeId *string
	description    *string
}

func (r ApiDeleteReferenceRequest) TransactionId(transactionId string) ApiDeleteReferenceRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiDeleteReferenceRequest) ParentChangeId(parentChangeId string) ApiDeleteReferenceRequest {
	r.parentChangeId = &parentChangeId
	return r
}

func (r ApiDeleteReferenceRequest) Description(description string) ApiDeleteReferenceRequest {
	r.description = &description
	return r
}

func (r ApiDeleteReferenceRequest) Execute() (*BTAppElementReferenceInfo, *http.Response, error) {
	return r.ApiService.DeleteReferenceExecute(r)
}

/*
DeleteReference Delete an app element reference.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param eid
	@param wvm
	@param wvmid
	@param rid
	@return ApiDeleteReferenceRequest
*/
func (a *AppElementApiService) DeleteReference(ctx context.Context, did string, eid string, wvm string, wvmid string, rid string) ApiDeleteReferenceRequest {
	return ApiDeleteReferenceRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wvm:        wvm,
		wvmid:      wvmid,
		rid:        rid,
	}
}

// Execute executes the request
//
//	@return BTAppElementReferenceInfo
func (a *AppElementApiService) DeleteReferenceExecute(r ApiDeleteReferenceRequest) (*BTAppElementReferenceInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementReferenceInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.DeleteReference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/references/{rid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rid"+"}", url.PathEscape(parameterToString(r.rid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.parentChangeId != nil {
		localVarQueryParams.Add("parentChangeId", parameterToString(*r.parentChangeId, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementReferenceInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadBlobSubelementRequest struct {
	ctx                context.Context
	ApiService         *AppElementApiService
	did                string
	vm                 string
	vmid               string
	eid                string
	bid                string
	contentDisposition *string
	ifNoneMatch        *string
	transactionId      *string
	changeId           *string
	linkDocumentId     *string
}

func (r ApiDownloadBlobSubelementRequest) ContentDisposition(contentDisposition string) ApiDownloadBlobSubelementRequest {
	r.contentDisposition = &contentDisposition
	return r
}

func (r ApiDownloadBlobSubelementRequest) IfNoneMatch(ifNoneMatch string) ApiDownloadBlobSubelementRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r ApiDownloadBlobSubelementRequest) TransactionId(transactionId string) ApiDownloadBlobSubelementRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiDownloadBlobSubelementRequest) ChangeId(changeId string) ApiDownloadBlobSubelementRequest {
	r.changeId = &changeId
	return r
}

func (r ApiDownloadBlobSubelementRequest) LinkDocumentId(linkDocumentId string) ApiDownloadBlobSubelementRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiDownloadBlobSubelementRequest) Execute() (*HttpFile, *http.Response, error) {
	return r.ApiService.DownloadBlobSubelementExecute(r)
}

/*
DownloadBlobSubelement Download a blob subelement from the specified app element.

Download a blob subelement as a file.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param vm
	@param vmid
	@param eid
	@param bid
	@return ApiDownloadBlobSubelementRequest
*/
func (a *AppElementApiService) DownloadBlobSubelement(ctx context.Context, did string, vm string, vmid string, eid string, bid string) ApiDownloadBlobSubelementRequest {
	return ApiDownloadBlobSubelementRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		vm:         vm,
		vmid:       vmid,
		eid:        eid,
		bid:        bid,
	}
}

// Execute executes the request
//
//	@return HttpFile
func (a *AppElementApiService) DownloadBlobSubelementExecute(r ApiDownloadBlobSubelementRequest) (*HttpFile, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *HttpFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.DownloadBlobSubelement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{vm}/{vmid}/e/{eid}/blob/{bid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vm"+"}", url.PathEscape(parameterToString(r.vm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterToString(r.vmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bid"+"}", url.PathEscape(parameterToString(r.bid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contentDisposition != nil {
		localVarQueryParams.Add("contentDisposition", parameterToString(*r.contentDisposition, ""))
	}
	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.changeId != nil {
		localVarQueryParams.Add("changeId", parameterToString(*r.changeId, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09", "application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v HttpFile
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadBlobSubelementWorkspaceRequest struct {
	ctx                context.Context
	ApiService         *AppElementApiService
	did                string
	wid                string
	eid                string
	bid                string
	contentDisposition *string
	ifNoneMatch        *string
	transactionId      *string
	changeId           *string
}

func (r ApiDownloadBlobSubelementWorkspaceRequest) ContentDisposition(contentDisposition string) ApiDownloadBlobSubelementWorkspaceRequest {
	r.contentDisposition = &contentDisposition
	return r
}

func (r ApiDownloadBlobSubelementWorkspaceRequest) IfNoneMatch(ifNoneMatch string) ApiDownloadBlobSubelementWorkspaceRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r ApiDownloadBlobSubelementWorkspaceRequest) TransactionId(transactionId string) ApiDownloadBlobSubelementWorkspaceRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiDownloadBlobSubelementWorkspaceRequest) ChangeId(changeId string) ApiDownloadBlobSubelementWorkspaceRequest {
	r.changeId = &changeId
	return r
}

func (r ApiDownloadBlobSubelementWorkspaceRequest) Execute() (*HttpFile, *http.Response, error) {
	return r.ApiService.DownloadBlobSubelementWorkspaceExecute(r)
}

/*
DownloadBlobSubelementWorkspace Download the blob element (i.e., a file) stored in an app element in a document's workspace.

The downloaded file can be used to retrieve stored subelements.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param wid
	@param eid
	@param bid
	@return ApiDownloadBlobSubelementWorkspaceRequest
*/
func (a *AppElementApiService) DownloadBlobSubelementWorkspace(ctx context.Context, did string, wid string, eid string, bid string) ApiDownloadBlobSubelementWorkspaceRequest {
	return ApiDownloadBlobSubelementWorkspaceRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
		bid:        bid,
	}
}

// Execute executes the request
//
//	@return HttpFile
func (a *AppElementApiService) DownloadBlobSubelementWorkspaceExecute(r ApiDownloadBlobSubelementWorkspaceRequest) (*HttpFile, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *HttpFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.DownloadBlobSubelementWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/w/{wid}/e/{eid}/blob/{bid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bid"+"}", url.PathEscape(parameterToString(r.bid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contentDisposition != nil {
		localVarQueryParams.Add("contentDisposition", parameterToString(*r.contentDisposition, ""))
	}
	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.changeId != nil {
		localVarQueryParams.Add("changeId", parameterToString(*r.changeId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09", "application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v HttpFile
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAppElementHistoryRequest struct {
	ctx        context.Context
	ApiService *AppElementApiService
	did        string
	eid        string
	wvm        string
	wvmid      string
}

func (r ApiGetAppElementHistoryRequest) Execute() (*BTAppElementHistoryInfo, *http.Response, error) {
	return r.ApiService.GetAppElementHistoryExecute(r)
}

/*
GetAppElementHistory Get the history of the specified all element.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param eid
	@param wvm
	@param wvmid
	@return ApiGetAppElementHistoryRequest
*/
func (a *AppElementApiService) GetAppElementHistory(ctx context.Context, did string, eid string, wvm string, wvmid string) ApiGetAppElementHistoryRequest {
	return ApiGetAppElementHistoryRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wvm:        wvm,
		wvmid:      wvmid,
	}
}

// Execute executes the request
//
//	@return BTAppElementHistoryInfo
func (a *AppElementApiService) GetAppElementHistoryExecute(r ApiGetAppElementHistoryRequest) (*BTAppElementHistoryInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementHistoryInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.GetAppElementHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/history"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementHistoryInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlobSubelementIdsRequest struct {
	ctx           context.Context
	ApiService    *AppElementApiService
	did           string
	eid           string
	wvm           string
	wvmid         string
	transactionId *string
	changeId      *string
}

func (r ApiGetBlobSubelementIdsRequest) TransactionId(transactionId string) ApiGetBlobSubelementIdsRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiGetBlobSubelementIdsRequest) ChangeId(changeId string) ApiGetBlobSubelementIdsRequest {
	r.changeId = &changeId
	return r
}

func (r ApiGetBlobSubelementIdsRequest) Execute() (*BTAppElementIdsInfo, *http.Response, error) {
	return r.ApiService.GetBlobSubelementIdsExecute(r)
}

/*
GetBlobSubelementIds Get a list of all blob subelement IDs for the specified workspace, version, or microversion.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param eid
	@param wvm
	@param wvmid
	@return ApiGetBlobSubelementIdsRequest
*/
func (a *AppElementApiService) GetBlobSubelementIds(ctx context.Context, did string, eid string, wvm string, wvmid string) ApiGetBlobSubelementIdsRequest {
	return ApiGetBlobSubelementIdsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wvm:        wvm,
		wvmid:      wvmid,
	}
}

// Execute executes the request
//
//	@return BTAppElementIdsInfo
func (a *AppElementApiService) GetBlobSubelementIdsExecute(r ApiGetBlobSubelementIdsRequest) (*BTAppElementIdsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementIdsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.GetBlobSubelementIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/blob"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.changeId != nil {
		localVarQueryParams.Add("changeId", parameterToString(*r.changeId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementIdsInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetElementTransactionsRequest struct {
	ctx        context.Context
	ApiService *AppElementApiService
	did        string
	eid        string
	wid        string
}

func (r ApiGetElementTransactionsRequest) Execute() (*BTAppElementTransactionsInfo, *http.Response, error) {
	return r.ApiService.GetElementTransactionsExecute(r)
}

/*
GetElementTransactions Get a list of all transactions performed on an element.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param eid
	@param wid
	@return ApiGetElementTransactionsRequest
*/
func (a *AppElementApiService) GetElementTransactions(ctx context.Context, did string, eid string, wid string) ApiGetElementTransactionsRequest {
	return ApiGetElementTransactionsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wid:        wid,
	}
}

// Execute executes the request
//
//	@return BTAppElementTransactionsInfo
func (a *AppElementApiService) GetElementTransactionsExecute(r ApiGetElementTransactionsRequest) (*BTAppElementTransactionsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementTransactionsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.GetElementTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/w/{wid}/e/{eid}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementTransactionsInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJsonRequest struct {
	ctx            context.Context
	ApiService     *AppElementApiService
	did            string
	wvm            string
	wvmid          string
	eid            string
	linkDocumentId *string
	transactionId  *string
	changeId       *string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetJsonRequest) LinkDocumentId(linkDocumentId string) ApiGetJsonRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// The id of the transaction in which this operation should take place. Transaction ids can be generated through the AppElement startTransaction API.
func (r ApiGetJsonRequest) TransactionId(transactionId string) ApiGetJsonRequest {
	r.transactionId = &transactionId
	return r
}

// The id of the last change made to this application element. This can be retrieved from the response for any app element modification endpoint.
func (r ApiGetJsonRequest) ChangeId(changeId string) ApiGetJsonRequest {
	r.changeId = &changeId
	return r
}

func (r ApiGetJsonRequest) Execute() (*BTGetJsonResponse2137, *http.Response, error) {
	return r.ApiService.GetJsonExecute(r)
}

/*
GetJson Get the full JSON tree for the specified workspace/version/microversion.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiGetJsonRequest
*/
func (a *AppElementApiService) GetJson(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetJsonRequest {
	return ApiGetJsonRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTGetJsonResponse2137
func (a *AppElementApiService) GetJsonExecute(r ApiGetJsonRequest) (*BTGetJsonResponse2137, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTGetJsonResponse2137
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.GetJson")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/json"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.changeId != nil {
		localVarQueryParams.Add("changeId", parameterToString(*r.changeId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTGetJsonResponse2137
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJsonPathsRequest struct {
	ctx                context.Context
	ApiService         *AppElementApiService
	did                string
	wvm                string
	wvmid              string
	eid                string
	linkDocumentId     *string
	transactionId      *string
	changeId           *string
	bTGetJsonPaths1697 *BTGetJsonPaths1697
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetJsonPathsRequest) LinkDocumentId(linkDocumentId string) ApiGetJsonPathsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetJsonPathsRequest) TransactionId(transactionId string) ApiGetJsonPathsRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiGetJsonPathsRequest) ChangeId(changeId string) ApiGetJsonPathsRequest {
	r.changeId = &changeId
	return r
}

func (r ApiGetJsonPathsRequest) BTGetJsonPaths1697(bTGetJsonPaths1697 BTGetJsonPaths1697) ApiGetJsonPathsRequest {
	r.bTGetJsonPaths1697 = &bTGetJsonPaths1697
	return r
}

func (r ApiGetJsonPathsRequest) Execute() (*BTGetJsonPathsResponse1544, *http.Response, error) {
	return r.ApiService.GetJsonPathsExecute(r)
}

/*
GetJsonPaths Get the JSON at specified paths for an element.

Use this endpoint to return the JSON at the specified path instead of returning the entire JSON for the element. This POST endpoint does not write any information.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiGetJsonPathsRequest
*/
func (a *AppElementApiService) GetJsonPaths(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetJsonPathsRequest {
	return ApiGetJsonPathsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTGetJsonPathsResponse1544
func (a *AppElementApiService) GetJsonPathsExecute(r ApiGetJsonPathsRequest) (*BTGetJsonPathsResponse1544, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTGetJsonPathsResponse1544
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.GetJsonPaths")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/jsonpaths"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.changeId != nil {
		localVarQueryParams.Add("changeId", parameterToString(*r.changeId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTGetJsonPaths1697
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTGetJsonPathsResponse1544
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubElementContentRequest struct {
	ctx            context.Context
	ApiService     *AppElementApiService
	did            string
	wvm            string
	wvmid          string
	eid            string
	linkDocumentId *string
	transactionId  *string
	changeId       *string
	baseChangeId   *string
	subelementId   *string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetSubElementContentRequest) LinkDocumentId(linkDocumentId string) ApiGetSubElementContentRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetSubElementContentRequest) TransactionId(transactionId string) ApiGetSubElementContentRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiGetSubElementContentRequest) ChangeId(changeId string) ApiGetSubElementContentRequest {
	r.changeId = &changeId
	return r
}

func (r ApiGetSubElementContentRequest) BaseChangeId(baseChangeId string) ApiGetSubElementContentRequest {
	r.baseChangeId = &baseChangeId
	return r
}

func (r ApiGetSubElementContentRequest) SubelementId(subelementId string) ApiGetSubElementContentRequest {
	r.subelementId = &subelementId
	return r
}

func (r ApiGetSubElementContentRequest) Execute() (*BTAppElementContentInfo, *http.Response, error) {
	return r.ApiService.GetSubElementContentExecute(r)
}

/*
GetSubElementContent Get a list of all subelement IDs in a specified workspace/version/microversion.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiGetSubElementContentRequest
*/
func (a *AppElementApiService) GetSubElementContent(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetSubElementContentRequest {
	return ApiGetSubElementContentRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTAppElementContentInfo
func (a *AppElementApiService) GetSubElementContentExecute(r ApiGetSubElementContentRequest) (*BTAppElementContentInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementContentInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.GetSubElementContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.changeId != nil {
		localVarQueryParams.Add("changeId", parameterToString(*r.changeId, ""))
	}
	if r.baseChangeId != nil {
		localVarQueryParams.Add("baseChangeId", parameterToString(*r.baseChangeId, ""))
	}
	if r.subelementId != nil {
		localVarQueryParams.Add("subelementId", parameterToString(*r.subelementId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementContentInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubelementIdsRequest struct {
	ctx           context.Context
	ApiService    *AppElementApiService
	did           string
	eid           string
	wvm           string
	wvmid         string
	transactionId *string
	changeId      *string
}

func (r ApiGetSubelementIdsRequest) TransactionId(transactionId string) ApiGetSubelementIdsRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiGetSubelementIdsRequest) ChangeId(changeId string) ApiGetSubelementIdsRequest {
	r.changeId = &changeId
	return r
}

func (r ApiGetSubelementIdsRequest) Execute() (*BTAppElementIdsInfo, *http.Response, error) {
	return r.ApiService.GetSubelementIdsExecute(r)
}

/*
GetSubelementIds Get a list of all subelement IDs in a specified workspace/version/microversion.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param eid
	@param wvm
	@param wvmid
	@return ApiGetSubelementIdsRequest
*/
func (a *AppElementApiService) GetSubelementIds(ctx context.Context, did string, eid string, wvm string, wvmid string) ApiGetSubelementIdsRequest {
	return ApiGetSubelementIdsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wvm:        wvm,
		wvmid:      wvmid,
	}
}

// Execute executes the request
//
//	@return BTAppElementIdsInfo
func (a *AppElementApiService) GetSubelementIdsExecute(r ApiGetSubelementIdsRequest) (*BTAppElementIdsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementIdsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.GetSubelementIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/ids"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.changeId != nil {
		localVarQueryParams.Add("changeId", parameterToString(*r.changeId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementIdsInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResolveReferenceRequest struct {
	ctx             context.Context
	ApiService      *AppElementApiService
	did             string
	eid             string
	wvm             string
	wvmid           string
	rid             string
	transactionId   *string
	parentChangeId  *string
	includeInternal *bool
	linkDocumentId  *string
}

func (r ApiResolveReferenceRequest) TransactionId(transactionId string) ApiResolveReferenceRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiResolveReferenceRequest) ParentChangeId(parentChangeId string) ApiResolveReferenceRequest {
	r.parentChangeId = &parentChangeId
	return r
}

func (r ApiResolveReferenceRequest) IncludeInternal(includeInternal bool) ApiResolveReferenceRequest {
	r.includeInternal = &includeInternal
	return r
}

func (r ApiResolveReferenceRequest) LinkDocumentId(linkDocumentId string) ApiResolveReferenceRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiResolveReferenceRequest) Execute() (*BTAppElementReferenceResolveInfo, *http.Response, error) {
	return r.ApiService.ResolveReferenceExecute(r)
}

/*
ResolveReference Resolves a single reference to an app element.

For single operations only. Use `resolveReferences` for bulk operations.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param eid
	@param wvm
	@param wvmid
	@param rid
	@return ApiResolveReferenceRequest
*/
func (a *AppElementApiService) ResolveReference(ctx context.Context, did string, eid string, wvm string, wvmid string, rid string) ApiResolveReferenceRequest {
	return ApiResolveReferenceRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wvm:        wvm,
		wvmid:      wvmid,
		rid:        rid,
	}
}

// Execute executes the request
//
//	@return BTAppElementReferenceResolveInfo
func (a *AppElementApiService) ResolveReferenceExecute(r ApiResolveReferenceRequest) (*BTAppElementReferenceResolveInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementReferenceResolveInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.ResolveReference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/references/{rid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rid"+"}", url.PathEscape(parameterToString(r.rid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.parentChangeId != nil {
		localVarQueryParams.Add("parentChangeId", parameterToString(*r.parentChangeId, ""))
	}
	if r.includeInternal != nil {
		localVarQueryParams.Add("includeInternal", parameterToString(*r.includeInternal, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementReferenceResolveInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResolveReferencesRequest struct {
	ctx             context.Context
	ApiService      *AppElementApiService
	did             string
	wvm             string
	wvmid           string
	eid             string
	linkDocumentId  *string
	transactionId   *string
	parentChangeId  *string
	includeInternal *bool
	referenceIds    *string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiResolveReferencesRequest) LinkDocumentId(linkDocumentId string) ApiResolveReferencesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiResolveReferencesRequest) TransactionId(transactionId string) ApiResolveReferencesRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiResolveReferencesRequest) ParentChangeId(parentChangeId string) ApiResolveReferencesRequest {
	r.parentChangeId = &parentChangeId
	return r
}

func (r ApiResolveReferencesRequest) IncludeInternal(includeInternal bool) ApiResolveReferencesRequest {
	r.includeInternal = &includeInternal
	return r
}

func (r ApiResolveReferencesRequest) ReferenceIds(referenceIds string) ApiResolveReferencesRequest {
	r.referenceIds = &referenceIds
	return r
}

func (r ApiResolveReferencesRequest) Execute() (*BTAppElementReferencesResolveInfo, *http.Response, error) {
	return r.ApiService.ResolveReferencesExecute(r)
}

/*
ResolveReferences Resolves bulk app element references.

For bulk operations only. Use `resolveReference` for a single operation.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiResolveReferencesRequest
*/
func (a *AppElementApiService) ResolveReferences(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiResolveReferencesRequest {
	return ApiResolveReferencesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTAppElementReferencesResolveInfo
func (a *AppElementApiService) ResolveReferencesExecute(r ApiResolveReferencesRequest) (*BTAppElementReferencesResolveInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementReferencesResolveInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.ResolveReferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/resolvereferences"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.parentChangeId != nil {
		localVarQueryParams.Add("parentChangeId", parameterToString(*r.parentChangeId, ""))
	}
	if r.includeInternal != nil {
		localVarQueryParams.Add("includeInternal", parameterToString(*r.includeInternal, ""))
	}
	if r.referenceIds != nil {
		localVarQueryParams.Add("referenceIds", parameterToString(*r.referenceIds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementReferencesResolveInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartTransactionRequest struct {
	ctx                                context.Context
	ApiService                         *AppElementApiService
	did                                string
	eid                                string
	wid                                string
	bTAppElementStartTransactionParams *BTAppElementStartTransactionParams
}

func (r ApiStartTransactionRequest) BTAppElementStartTransactionParams(bTAppElementStartTransactionParams BTAppElementStartTransactionParams) ApiStartTransactionRequest {
	r.bTAppElementStartTransactionParams = &bTAppElementStartTransactionParams
	return r
}

func (r ApiStartTransactionRequest) Execute() (*BTAppElementModifyInfo, *http.Response, error) {
	return r.ApiService.StartTransactionExecute(r)
}

/*
StartTransaction Start a transaction

Creates a microbranch (i.e., a branch for a new microversion).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param eid
	@param wid
	@return ApiStartTransactionRequest
*/
func (a *AppElementApiService) StartTransaction(ctx context.Context, did string, eid string, wid string) ApiStartTransactionRequest {
	return ApiStartTransactionRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wid:        wid,
	}
}

// Execute executes the request
//
//	@return BTAppElementModifyInfo
func (a *AppElementApiService) StartTransactionExecute(r ApiStartTransactionRequest) (*BTAppElementModifyInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementModifyInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.StartTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/w/{wid}/e/{eid}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTAppElementStartTransactionParams == nil {
		return localVarReturnValue, nil, reportError("bTAppElementStartTransactionParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAppElementStartTransactionParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementModifyInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAppElementRequest struct {
	ctx                      context.Context
	ApiService               *AppElementApiService
	did                      string
	eid                      string
	wvm                      string
	wvmid                    string
	bTAppElementUpdateParams *BTAppElementUpdateParams
}

func (r ApiUpdateAppElementRequest) BTAppElementUpdateParams(bTAppElementUpdateParams BTAppElementUpdateParams) ApiUpdateAppElementRequest {
	r.bTAppElementUpdateParams = &bTAppElementUpdateParams
	return r
}

func (r ApiUpdateAppElementRequest) Execute() (*BTAppElementModifyInfo, *http.Response, error) {
	return r.ApiService.UpdateAppElementExecute(r)
}

/*
UpdateAppElement Update the content for the specified app element.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param eid
	@param wvm
	@param wvmid
	@return ApiUpdateAppElementRequest
*/
func (a *AppElementApiService) UpdateAppElement(ctx context.Context, did string, eid string, wvm string, wvmid string) ApiUpdateAppElementRequest {
	return ApiUpdateAppElementRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wvm:        wvm,
		wvmid:      wvmid,
	}
}

// Execute executes the request
//
//	@return BTAppElementModifyInfo
func (a *AppElementApiService) UpdateAppElementExecute(r ApiUpdateAppElementRequest) (*BTAppElementModifyInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementModifyInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.UpdateAppElement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAppElementUpdateParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementModifyInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateReferenceRequest struct {
	ctx                         context.Context
	ApiService                  *AppElementApiService
	did                         string
	eid                         string
	wvm                         string
	wvmid                       string
	rid                         string
	bTAppElementReferenceParams *BTAppElementReferenceParams
}

func (r ApiUpdateReferenceRequest) BTAppElementReferenceParams(bTAppElementReferenceParams BTAppElementReferenceParams) ApiUpdateReferenceRequest {
	r.bTAppElementReferenceParams = &bTAppElementReferenceParams
	return r
}

func (r ApiUpdateReferenceRequest) Execute() (*BTAppElementReferenceInfo, *http.Response, error) {
	return r.ApiService.UpdateReferenceExecute(r)
}

/*
UpdateReference Update an app element reference.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param eid
	@param wvm
	@param wvmid
	@param rid
	@return ApiUpdateReferenceRequest
*/
func (a *AppElementApiService) UpdateReference(ctx context.Context, did string, eid string, wvm string, wvmid string, rid string) ApiUpdateReferenceRequest {
	return ApiUpdateReferenceRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wvm:        wvm,
		wvmid:      wvmid,
		rid:        rid,
	}
}

// Execute executes the request
//
//	@return BTAppElementReferenceInfo
func (a *AppElementApiService) UpdateReferenceExecute(r ApiUpdateReferenceRequest) (*BTAppElementReferenceInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementReferenceInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.UpdateReference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/references/{rid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rid"+"}", url.PathEscape(parameterToString(r.rid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTAppElementReferenceParams == nil {
		return localVarReturnValue, nil, reportError("bTAppElementReferenceParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAppElementReferenceParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementReferenceInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadBlobSubelementRequest struct {
	ctx               context.Context
	ApiService        *AppElementApiService
	did               string
	wid               string
	eid               string
	bid               string
	transactionId     *string
	parentChangeId    *string
	description       *string
	file              *HttpFile
	fileContentLength *int64
}

func (r ApiUploadBlobSubelementRequest) TransactionId(transactionId string) ApiUploadBlobSubelementRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiUploadBlobSubelementRequest) ParentChangeId(parentChangeId string) ApiUploadBlobSubelementRequest {
	r.parentChangeId = &parentChangeId
	return r
}

func (r ApiUploadBlobSubelementRequest) Description(description string) ApiUploadBlobSubelementRequest {
	r.description = &description
	return r
}

// File to upload.
func (r ApiUploadBlobSubelementRequest) File(file HttpFile) ApiUploadBlobSubelementRequest {
	r.file = &file
	return r
}

func (r ApiUploadBlobSubelementRequest) FileContentLength(fileContentLength int64) ApiUploadBlobSubelementRequest {
	r.fileContentLength = &fileContentLength
	return r
}

func (r ApiUploadBlobSubelementRequest) Execute() (*BTAppElementModifyInfo, *http.Response, error) {
	return r.ApiService.UploadBlobSubelementExecute(r)
}

/*
UploadBlobSubelement Create a new blob subelement from an uploaded file.

Request body parameters are multipart fields, so you must use `"Content-Type":"multipart/form-data"` in the request header.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param wid
	@param eid
	@param bid
	@return ApiUploadBlobSubelementRequest
*/
func (a *AppElementApiService) UploadBlobSubelement(ctx context.Context, did string, wid string, eid string, bid string) ApiUploadBlobSubelementRequest {
	return ApiUploadBlobSubelementRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
		bid:        bid,
	}
}

// Execute executes the request
//
//	@return BTAppElementModifyInfo
func (a *AppElementApiService) UploadBlobSubelementExecute(r ApiUploadBlobSubelementRequest) (*BTAppElementModifyInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAppElementModifyInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppElementApiService.UploadBlobSubelement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/appelements/d/{did}/w/{wid}/e/{eid}/blob/{bid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bid"+"}", url.PathEscape(parameterToString(r.bid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.transactionId != nil {
		localVarFormParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.parentChangeId != nil {
		localVarFormParams.Add("parentChangeId", parameterToString(*r.parentChangeId, ""))
	}
	if r.description != nil {
		localVarFormParams.Add("description", parameterToString(*r.description, ""))
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName string
	var fileLocalVarFileBytes io.Reader

	fileLocalVarFormFileName = "file"

	if r.file != nil {
		fileLocalVarFile := *r.file
		fileLocalVarFileBytes = fileLocalVarFile.Data
		fileLocalVarFileName = fileLocalVarFile.Name
		formFiles = append(formFiles, formFile{fileData: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	if r.fileContentLength != nil {
		localVarFormParams.Add("fileContentLength", parameterToString(*r.fileContentLength, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAppElementModifyInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
