/*
Onshape REST API

## Welcome to the Onshape REST API Explorer  To use this API explorer, sign in to your [Onshape](https://cad.onshape.com) account in another tab, then click the **Try it out** button below (it toggles to a **Cancel** button when selected).  See the **[API Explorer Guide](https://onshape-public.github.io/docs/api-intro/explorer/)** for help navigating this API Explorer, including **[authentication](https://onshape-public.github.io/docs/api-intro/explorer/#authentication)**.  **Tip:** To ensure the current session isn't used when trying other authentication techniques, make sure to [remove the Onshape cookie](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site) as per the instructions for your browser. Alternatively, you can use a private or incognito window.  ## See Also  * [Onshape API Guide](https://onshape-public.github.io/docs/): Our full suite of developer guides, to be used as an accompaniment to this API Explorer. * [Onshape Developer Portal](https://dev-portal.onshape.com/): The Onshape portal for managing your API keys, OAuth2 credentials, your Onshape applications, and your Onshape App Store entries. * [Authentication Guide](https://onshape-public.github.io/docs/auth/): Our guide to using API keys, request signatures, and OAuth2 in  your Onshape applications.

Contact: api-support@onshape.zendesk.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package onshape

import (
	"context"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// AssemblyApiService AssemblyApi service
type AssemblyApiService service

type ApiAddFeatureRequest struct {
	ctx                         context.Context
	ApiService                  *AssemblyApiService
	did                         string
	wvm                         string
	wvmid                       string
	eid                         string
	bTFeatureDefinitionCall1406 *BTFeatureDefinitionCall1406
}

func (r ApiAddFeatureRequest) BTFeatureDefinitionCall1406(bTFeatureDefinitionCall1406 BTFeatureDefinitionCall1406) ApiAddFeatureRequest {
	r.bTFeatureDefinitionCall1406 = &bTFeatureDefinitionCall1406
	return r
}

func (r ApiAddFeatureRequest) Execute() (*BTFeatureDefinitionResponse1617, *http.Response, error) {
	return r.ApiService.AddFeatureExecute(r)
}

/*
AddFeature Add a feature to the assembly feature list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param wvm
	@param wvmid
	@param eid
	@return ApiAddFeatureRequest
*/
func (a *AssemblyApiService) AddFeature(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiAddFeatureRequest {
	return ApiAddFeatureRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTFeatureDefinitionResponse1617
func (a *AssemblyApiService) AddFeatureExecute(r ApiAddFeatureRequest) (*BTFeatureDefinitionResponse1617, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTFeatureDefinitionResponse1617
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.AddFeature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTFeatureDefinitionCall1406
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTFeatureDefinitionResponse1617
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAssemblyRequest struct {
	ctx                  context.Context
	ApiService           *AssemblyApiService
	did                  string
	wid                  string
	bTModelElementParams *BTModelElementParams
}

func (r ApiCreateAssemblyRequest) BTModelElementParams(bTModelElementParams BTModelElementParams) ApiCreateAssemblyRequest {
	r.bTModelElementParams = &bTModelElementParams
	return r
}

func (r ApiCreateAssemblyRequest) Execute() (*BTDocumentElementInfo, *http.Response, error) {
	return r.ApiService.CreateAssemblyExecute(r)
}

/*
CreateAssembly Create a new assembly tab in the document.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param wid
	@return ApiCreateAssemblyRequest
*/
func (a *AssemblyApiService) CreateAssembly(ctx context.Context, did string, wid string) ApiCreateAssemblyRequest {
	return ApiCreateAssemblyRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
	}
}

// Execute executes the request
//
//	@return BTDocumentElementInfo
func (a *AssemblyApiService) CreateAssemblyExecute(r ApiCreateAssemblyRequest) (*BTDocumentElementInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTDocumentElementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.CreateAssembly")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/w/{wid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTModelElementParams == nil {
		return localVarReturnValue, nil, reportError("bTModelElementParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTModelElementParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTDocumentElementInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateInstanceRequest struct {
	ctx                                context.Context
	ApiService                         *AssemblyApiService
	did                                string
	wid                                string
	eid                                string
	bTAssemblyInstanceDefinitionParams *BTAssemblyInstanceDefinitionParams
}

func (r ApiCreateInstanceRequest) BTAssemblyInstanceDefinitionParams(bTAssemblyInstanceDefinitionParams BTAssemblyInstanceDefinitionParams) ApiCreateInstanceRequest {
	r.bTAssemblyInstanceDefinitionParams = &bTAssemblyInstanceDefinitionParams
	return r
}

func (r ApiCreateInstanceRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateInstanceExecute(r)
}

/*
CreateInstance Insert an instance of a part, sketch, assembly, or Part Studio into an assembly.

Part Studio instances may include multiple parts.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param wid
	@param eid
	@return ApiCreateInstanceRequest
*/
func (a *AssemblyApiService) CreateInstance(ctx context.Context, did string, wid string, eid string) ApiCreateInstanceRequest {
	return ApiCreateInstanceRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *AssemblyApiService) CreateInstanceExecute(r ApiCreateInstanceRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.CreateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/w/{wid}/e/{eid}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAssemblyInstanceDefinitionParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFeatureRequest struct {
	ctx        context.Context
	ApiService *AssemblyApiService
	did        string
	wid        string
	eid        string
	fid        string
}

func (r ApiDeleteFeatureRequest) Execute() (*BTFeatureApiBase1430, *http.Response, error) {
	return r.ApiService.DeleteFeatureExecute(r)
}

/*
DeleteFeature Delete a feature from an assembly.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param wid
	@param eid
	@param fid
	@return ApiDeleteFeatureRequest
*/
func (a *AssemblyApiService) DeleteFeature(ctx context.Context, did string, wid string, eid string, fid string) ApiDeleteFeatureRequest {
	return ApiDeleteFeatureRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
		fid:        fid,
	}
}

// Execute executes the request
//
//	@return BTFeatureApiBase1430
func (a *AssemblyApiService) DeleteFeatureExecute(r ApiDeleteFeatureRequest) (*BTFeatureApiBase1430, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTFeatureApiBase1430
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.DeleteFeature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/w/{wid}/e/{eid}/features/featureid/{fid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fid"+"}", url.PathEscape(parameterToString(r.fid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteInstanceRequest struct {
	ctx        context.Context
	ApiService *AssemblyApiService
	did        string
	eid        string
	wid        string
	nid        string
}

func (r ApiDeleteInstanceRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteInstanceExecute(r)
}

/*
DeleteInstance Delete an instance of an assembly.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param eid
	@param wid
	@param nid
	@return ApiDeleteInstanceRequest
*/
func (a *AssemblyApiService) DeleteInstance(ctx context.Context, did string, eid string, wid string, nid string) ApiDeleteInstanceRequest {
	return ApiDeleteInstanceRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wid:        wid,
		nid:        nid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *AssemblyApiService) DeleteInstanceExecute(r ApiDeleteInstanceRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.DeleteInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/w/{wid}/e/{eid}/instance/nodeid/{nid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nid"+"}", url.PathEscape(parameterToString(r.nid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssemblyBoundingBoxesRequest struct {
	ctx             context.Context
	ApiService      *AssemblyApiService
	did             string
	wvm             string
	wvmid           string
	eid             string
	linkDocumentId  *string
	configuration   *string
	explodedViewId  *string
	includeHidden   *bool
	displayStateId  *string
	namedPositionId *string
	includeSketches *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetAssemblyBoundingBoxesRequest) LinkDocumentId(linkDocumentId string) ApiGetAssemblyBoundingBoxesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;) for the feature definition.
func (r ApiGetAssemblyBoundingBoxesRequest) Configuration(configuration string) ApiGetAssemblyBoundingBoxesRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetAssemblyBoundingBoxesRequest) ExplodedViewId(explodedViewId string) ApiGetAssemblyBoundingBoxesRequest {
	r.explodedViewId = &explodedViewId
	return r
}

func (r ApiGetAssemblyBoundingBoxesRequest) IncludeHidden(includeHidden bool) ApiGetAssemblyBoundingBoxesRequest {
	r.includeHidden = &includeHidden
	return r
}

func (r ApiGetAssemblyBoundingBoxesRequest) DisplayStateId(displayStateId string) ApiGetAssemblyBoundingBoxesRequest {
	r.displayStateId = &displayStateId
	return r
}

func (r ApiGetAssemblyBoundingBoxesRequest) NamedPositionId(namedPositionId string) ApiGetAssemblyBoundingBoxesRequest {
	r.namedPositionId = &namedPositionId
	return r
}

func (r ApiGetAssemblyBoundingBoxesRequest) IncludeSketches(includeSketches bool) ApiGetAssemblyBoundingBoxesRequest {
	r.includeSketches = &includeSketches
	return r
}

func (r ApiGetAssemblyBoundingBoxesRequest) Execute() (*BTBoundingBoxInfo, *http.Response, error) {
	return r.ApiService.GetAssemblyBoundingBoxesExecute(r)
}

/*
GetAssemblyBoundingBoxes Get bounding box information for the specified assembly.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiGetAssemblyBoundingBoxesRequest
*/
func (a *AssemblyApiService) GetAssemblyBoundingBoxes(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetAssemblyBoundingBoxesRequest {
	return ApiGetAssemblyBoundingBoxesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTBoundingBoxInfo
func (a *AssemblyApiService) GetAssemblyBoundingBoxesExecute(r ApiGetAssemblyBoundingBoxesRequest) (*BTBoundingBoxInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTBoundingBoxInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.GetAssemblyBoundingBoxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/boundingboxes"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.explodedViewId != nil {
		localVarQueryParams.Add("explodedViewId", parameterToString(*r.explodedViewId, ""))
	}
	if r.includeHidden != nil {
		localVarQueryParams.Add("includeHidden", parameterToString(*r.includeHidden, ""))
	}
	if r.displayStateId != nil {
		localVarQueryParams.Add("displayStateId", parameterToString(*r.displayStateId, ""))
	}
	if r.namedPositionId != nil {
		localVarQueryParams.Add("namedPositionId", parameterToString(*r.namedPositionId, ""))
	}
	if r.includeSketches != nil {
		localVarQueryParams.Add("includeSketches", parameterToString(*r.includeSketches, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTBoundingBoxInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssemblyDefinitionRequest struct {
	ctx                   context.Context
	ApiService            *AssemblyApiService
	did                   string
	wvm                   string
	wvmid                 string
	eid                   string
	linkDocumentId        *string
	configuration         *string
	explodedViewId        *string
	includeMateFeatures   *bool
	includeNonSolids      *bool
	includeMateConnectors *bool
	excludeSuppressed     *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetAssemblyDefinitionRequest) LinkDocumentId(linkDocumentId string) ApiGetAssemblyDefinitionRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;) for the feature definition.
func (r ApiGetAssemblyDefinitionRequest) Configuration(configuration string) ApiGetAssemblyDefinitionRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetAssemblyDefinitionRequest) ExplodedViewId(explodedViewId string) ApiGetAssemblyDefinitionRequest {
	r.explodedViewId = &explodedViewId
	return r
}

func (r ApiGetAssemblyDefinitionRequest) IncludeMateFeatures(includeMateFeatures bool) ApiGetAssemblyDefinitionRequest {
	r.includeMateFeatures = &includeMateFeatures
	return r
}

func (r ApiGetAssemblyDefinitionRequest) IncludeNonSolids(includeNonSolids bool) ApiGetAssemblyDefinitionRequest {
	r.includeNonSolids = &includeNonSolids
	return r
}

func (r ApiGetAssemblyDefinitionRequest) IncludeMateConnectors(includeMateConnectors bool) ApiGetAssemblyDefinitionRequest {
	r.includeMateConnectors = &includeMateConnectors
	return r
}

// Whether or not to exclude suppressed instances/mate features in response
func (r ApiGetAssemblyDefinitionRequest) ExcludeSuppressed(excludeSuppressed bool) ApiGetAssemblyDefinitionRequest {
	r.excludeSuppressed = &excludeSuppressed
	return r
}

func (r ApiGetAssemblyDefinitionRequest) Execute() (*BTAssemblyDefinitionInfo, *http.Response, error) {
	return r.ApiService.GetAssemblyDefinitionExecute(r)
}

/*
GetAssemblyDefinition Get definition information for the specified assembly.

All coordinates and translation matrix components are in meters (m).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiGetAssemblyDefinitionRequest
*/
func (a *AssemblyApiService) GetAssemblyDefinition(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetAssemblyDefinitionRequest {
	return ApiGetAssemblyDefinitionRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTAssemblyDefinitionInfo
func (a *AssemblyApiService) GetAssemblyDefinitionExecute(r ApiGetAssemblyDefinitionRequest) (*BTAssemblyDefinitionInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAssemblyDefinitionInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.GetAssemblyDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.explodedViewId != nil {
		localVarQueryParams.Add("explodedViewId", parameterToString(*r.explodedViewId, ""))
	}
	if r.includeMateFeatures != nil {
		localVarQueryParams.Add("includeMateFeatures", parameterToString(*r.includeMateFeatures, ""))
	}
	if r.includeNonSolids != nil {
		localVarQueryParams.Add("includeNonSolids", parameterToString(*r.includeNonSolids, ""))
	}
	if r.includeMateConnectors != nil {
		localVarQueryParams.Add("includeMateConnectors", parameterToString(*r.includeMateConnectors, ""))
	}
	if r.excludeSuppressed != nil {
		localVarQueryParams.Add("excludeSuppressed", parameterToString(*r.excludeSuppressed, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAssemblyDefinitionInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssemblyMassPropertiesRequest struct {
	ctx            context.Context
	ApiService     *AssemblyApiService
	did            string
	wvm            string
	wvmid          string
	eid            string
	linkDocumentId *string
	configuration  *string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetAssemblyMassPropertiesRequest) LinkDocumentId(linkDocumentId string) ApiGetAssemblyMassPropertiesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;) for the feature definition.
func (r ApiGetAssemblyMassPropertiesRequest) Configuration(configuration string) ApiGetAssemblyMassPropertiesRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetAssemblyMassPropertiesRequest) Execute() (*BTMassPropertiesInfo, *http.Response, error) {
	return r.ApiService.GetAssemblyMassPropertiesExecute(r)
}

/*
GetAssemblyMassProperties Get the mass properties for the assembly.

The assembly must contain parts that have assigned density or are globally overridden. If three mass properties are returned: the first is the calculated mass, and the second and third are the minimum and maximum possible values, considering tolerance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiGetAssemblyMassPropertiesRequest
*/
func (a *AssemblyApiService) GetAssemblyMassProperties(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetAssemblyMassPropertiesRequest {
	return ApiGetAssemblyMassPropertiesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTMassPropertiesInfo
func (a *AssemblyApiService) GetAssemblyMassPropertiesExecute(r ApiGetAssemblyMassPropertiesRequest) (*BTMassPropertiesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTMassPropertiesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.GetAssemblyMassProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/massproperties"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTMassPropertiesInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssemblyShadedViewsRequest struct {
	ctx             context.Context
	ApiService      *AssemblyApiService
	did             string
	wvm             string
	wvmid           string
	eid             string
	linkDocumentId  *string
	configuration   *string
	explodedViewId  *string
	viewMatrix      *string
	outputHeight    *int32
	outputWidth     *int32
	pixelSize       *float64
	edges           *string
	showAllParts    *bool
	includeSurfaces *bool
	useAntiAliasing *bool
	includeWires    *bool
	displayStateId  *string
	namedPositionId *string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetAssemblyShadedViewsRequest) LinkDocumentId(linkDocumentId string) ApiGetAssemblyShadedViewsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;) for the feature definition.
func (r ApiGetAssemblyShadedViewsRequest) Configuration(configuration string) ApiGetAssemblyShadedViewsRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) ExplodedViewId(explodedViewId string) ApiGetAssemblyShadedViewsRequest {
	r.explodedViewId = &explodedViewId
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) ViewMatrix(viewMatrix string) ApiGetAssemblyShadedViewsRequest {
	r.viewMatrix = &viewMatrix
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) OutputHeight(outputHeight int32) ApiGetAssemblyShadedViewsRequest {
	r.outputHeight = &outputHeight
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) OutputWidth(outputWidth int32) ApiGetAssemblyShadedViewsRequest {
	r.outputWidth = &outputWidth
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) PixelSize(pixelSize float64) ApiGetAssemblyShadedViewsRequest {
	r.pixelSize = &pixelSize
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) Edges(edges string) ApiGetAssemblyShadedViewsRequest {
	r.edges = &edges
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) ShowAllParts(showAllParts bool) ApiGetAssemblyShadedViewsRequest {
	r.showAllParts = &showAllParts
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) IncludeSurfaces(includeSurfaces bool) ApiGetAssemblyShadedViewsRequest {
	r.includeSurfaces = &includeSurfaces
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) UseAntiAliasing(useAntiAliasing bool) ApiGetAssemblyShadedViewsRequest {
	r.useAntiAliasing = &useAntiAliasing
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) IncludeWires(includeWires bool) ApiGetAssemblyShadedViewsRequest {
	r.includeWires = &includeWires
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) DisplayStateId(displayStateId string) ApiGetAssemblyShadedViewsRequest {
	r.displayStateId = &displayStateId
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) NamedPositionId(namedPositionId string) ApiGetAssemblyShadedViewsRequest {
	r.namedPositionId = &namedPositionId
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) Execute() (*BTShadedViewsInfo, *http.Response, error) {
	return r.ApiService.GetAssemblyShadedViewsExecute(r)
}

/*
GetAssemblyShadedViews Get an array of shaded view images for the document.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiGetAssemblyShadedViewsRequest
*/
func (a *AssemblyApiService) GetAssemblyShadedViews(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetAssemblyShadedViewsRequest {
	return ApiGetAssemblyShadedViewsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTShadedViewsInfo
func (a *AssemblyApiService) GetAssemblyShadedViewsExecute(r ApiGetAssemblyShadedViewsRequest) (*BTShadedViewsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTShadedViewsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.GetAssemblyShadedViews")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/shadedviews"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.explodedViewId != nil {
		localVarQueryParams.Add("explodedViewId", parameterToString(*r.explodedViewId, ""))
	}
	if r.viewMatrix != nil {
		localVarQueryParams.Add("viewMatrix", parameterToString(*r.viewMatrix, ""))
	}
	if r.outputHeight != nil {
		localVarQueryParams.Add("outputHeight", parameterToString(*r.outputHeight, ""))
	}
	if r.outputWidth != nil {
		localVarQueryParams.Add("outputWidth", parameterToString(*r.outputWidth, ""))
	}
	if r.pixelSize != nil {
		localVarQueryParams.Add("pixelSize", parameterToString(*r.pixelSize, ""))
	}
	if r.edges != nil {
		localVarQueryParams.Add("edges", parameterToString(*r.edges, ""))
	}
	if r.showAllParts != nil {
		localVarQueryParams.Add("showAllParts", parameterToString(*r.showAllParts, ""))
	}
	if r.includeSurfaces != nil {
		localVarQueryParams.Add("includeSurfaces", parameterToString(*r.includeSurfaces, ""))
	}
	if r.useAntiAliasing != nil {
		localVarQueryParams.Add("useAntiAliasing", parameterToString(*r.useAntiAliasing, ""))
	}
	if r.includeWires != nil {
		localVarQueryParams.Add("includeWires", parameterToString(*r.includeWires, ""))
	}
	if r.displayStateId != nil {
		localVarQueryParams.Add("displayStateId", parameterToString(*r.displayStateId, ""))
	}
	if r.namedPositionId != nil {
		localVarQueryParams.Add("namedPositionId", parameterToString(*r.namedPositionId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTShadedViewsInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBillOfMaterialsRequest struct {
	ctx                          context.Context
	ApiService                   *AssemblyApiService
	did                          string
	wvm                          string
	wvmid                        string
	eid                          string
	linkDocumentId               *string
	configuration                *string
	bomColumnIds                 *[]string
	indented                     *bool
	multiLevel                   *bool
	generateIfAbsent             *bool
	templateId                   *string
	includeExcluded              *bool
	onlyVisibleColumns           *bool
	ignoreSubassemblyBomBehavior *bool
	includeItemMicroversions     *bool
	includeTopLevelAssemblyRow   *bool
	thumbnail                    *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetBillOfMaterialsRequest) LinkDocumentId(linkDocumentId string) ApiGetBillOfMaterialsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;) for the feature definition.
func (r ApiGetBillOfMaterialsRequest) Configuration(configuration string) ApiGetBillOfMaterialsRequest {
	r.configuration = &configuration
	return r
}

// Ids of the columns to include, or all columns if empty. BOM column ids correspond to metadata property ids.
func (r ApiGetBillOfMaterialsRequest) BomColumnIds(bomColumnIds []string) ApiGetBillOfMaterialsRequest {
	r.bomColumnIds = &bomColumnIds
	return r
}

// Return the Structured BOM table with all rows collapsed, otherwise returns the Flattened BOM.
func (r ApiGetBillOfMaterialsRequest) Indented(indented bool) ApiGetBillOfMaterialsRequest {
	r.indented = &indented
	return r
}

// Return the Structured BOM table with all rows expanded. Ignored if indented is false.
func (r ApiGetBillOfMaterialsRequest) MultiLevel(multiLevel bool) ApiGetBillOfMaterialsRequest {
	r.multiLevel = &multiLevel
	return r
}

// Return the BOM table data even if the BOM does not exist. If this is false and the BOM does not exist, a 404 status code will be returned. This option is highly recommended.
func (r ApiGetBillOfMaterialsRequest) GenerateIfAbsent(generateIfAbsent bool) ApiGetBillOfMaterialsRequest {
	r.generateIfAbsent = &generateIfAbsent
	return r
}

// The id of the BOM table template to use when generating the table.
func (r ApiGetBillOfMaterialsRequest) TemplateId(templateId string) ApiGetBillOfMaterialsRequest {
	r.templateId = &templateId
	return r
}

// Include items that have been excluded from the BOM table.
func (r ApiGetBillOfMaterialsRequest) IncludeExcluded(includeExcluded bool) ApiGetBillOfMaterialsRequest {
	r.includeExcluded = &includeExcluded
	return r
}

// Only return data for visible columns, instead of all possible columns.
func (r ApiGetBillOfMaterialsRequest) OnlyVisibleColumns(onlyVisibleColumns bool) ApiGetBillOfMaterialsRequest {
	r.onlyVisibleColumns = &onlyVisibleColumns
	return r
}

// Ignore the &#39;Subassembly BOM behavior&#39; property when constructing the BOM table.
func (r ApiGetBillOfMaterialsRequest) IgnoreSubassemblyBomBehavior(ignoreSubassemblyBomBehavior bool) ApiGetBillOfMaterialsRequest {
	r.ignoreSubassemblyBomBehavior = &ignoreSubassemblyBomBehavior
	return r
}

// Include element microversions and version metadata microversions in the JSON.
func (r ApiGetBillOfMaterialsRequest) IncludeItemMicroversions(includeItemMicroversions bool) ApiGetBillOfMaterialsRequest {
	r.includeItemMicroversions = &includeItemMicroversions
	return r
}

// Include top-level assembly row when constructing the BOM table.
func (r ApiGetBillOfMaterialsRequest) IncludeTopLevelAssemblyRow(includeTopLevelAssemblyRow bool) ApiGetBillOfMaterialsRequest {
	r.includeTopLevelAssemblyRow = &includeTopLevelAssemblyRow
	return r
}

// Return thumbnail info
func (r ApiGetBillOfMaterialsRequest) Thumbnail(thumbnail bool) ApiGetBillOfMaterialsRequest {
	r.thumbnail = &thumbnail
	return r
}

func (r ApiGetBillOfMaterialsRequest) Execute() (*BTBillOfMaterialsInfo, *http.Response, error) {
	return r.ApiService.GetBillOfMaterialsExecute(r)
}

/*
GetBillOfMaterials Get the Bill Of Materials (BOM) content for the specified assembly.

Returns the BOM in JSON in the Onshape BOM Standard format.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiGetBillOfMaterialsRequest
*/
func (a *AssemblyApiService) GetBillOfMaterials(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetBillOfMaterialsRequest {
	return ApiGetBillOfMaterialsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTBillOfMaterialsInfo
func (a *AssemblyApiService) GetBillOfMaterialsExecute(r ApiGetBillOfMaterialsRequest) (*BTBillOfMaterialsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTBillOfMaterialsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.GetBillOfMaterials")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/bom"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.bomColumnIds != nil {
		t := *r.bomColumnIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("bomColumnIds", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("bomColumnIds", parameterToString(t, "multi"))
		}
	}
	if r.indented != nil {
		localVarQueryParams.Add("indented", parameterToString(*r.indented, ""))
	}
	if r.multiLevel != nil {
		localVarQueryParams.Add("multiLevel", parameterToString(*r.multiLevel, ""))
	}
	if r.generateIfAbsent != nil {
		localVarQueryParams.Add("generateIfAbsent", parameterToString(*r.generateIfAbsent, ""))
	}
	if r.templateId != nil {
		localVarQueryParams.Add("templateId", parameterToString(*r.templateId, ""))
	}
	if r.includeExcluded != nil {
		localVarQueryParams.Add("includeExcluded", parameterToString(*r.includeExcluded, ""))
	}
	if r.onlyVisibleColumns != nil {
		localVarQueryParams.Add("onlyVisibleColumns", parameterToString(*r.onlyVisibleColumns, ""))
	}
	if r.ignoreSubassemblyBomBehavior != nil {
		localVarQueryParams.Add("ignoreSubassemblyBomBehavior", parameterToString(*r.ignoreSubassemblyBomBehavior, ""))
	}
	if r.includeItemMicroversions != nil {
		localVarQueryParams.Add("includeItemMicroversions", parameterToString(*r.includeItemMicroversions, ""))
	}
	if r.includeTopLevelAssemblyRow != nil {
		localVarQueryParams.Add("includeTopLevelAssemblyRow", parameterToString(*r.includeTopLevelAssemblyRow, ""))
	}
	if r.thumbnail != nil {
		localVarQueryParams.Add("thumbnail", parameterToString(*r.thumbnail, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTBillOfMaterialsInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExplodedViewsRequest struct {
	ctx            context.Context
	ApiService     *AssemblyApiService
	did            string
	wvm            string
	wvmid          string
	eid            string
	linkDocumentId *string
	configuration  *string
	explodedViewId *string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetExplodedViewsRequest) LinkDocumentId(linkDocumentId string) ApiGetExplodedViewsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;) for the feature definition.
func (r ApiGetExplodedViewsRequest) Configuration(configuration string) ApiGetExplodedViewsRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetExplodedViewsRequest) ExplodedViewId(explodedViewId string) ApiGetExplodedViewsRequest {
	r.explodedViewId = &explodedViewId
	return r
}

func (r ApiGetExplodedViewsRequest) Execute() ([]BTViewFeatureBaseInfo, *http.Response, error) {
	return r.ApiService.GetExplodedViewsExecute(r)
}

/*
GetExplodedViews Get a list of exploded views for the specified assembly.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiGetExplodedViewsRequest
*/
func (a *AssemblyApiService) GetExplodedViews(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetExplodedViewsRequest {
	return ApiGetExplodedViewsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return []BTViewFeatureBaseInfo
func (a *AssemblyApiService) GetExplodedViewsExecute(r ApiGetExplodedViewsRequest) ([]BTViewFeatureBaseInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []BTViewFeatureBaseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.GetExplodedViews")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/explodedviews"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.explodedViewId != nil {
		localVarQueryParams.Add("explodedViewId", parameterToString(*r.explodedViewId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v []BTViewFeatureBaseInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFeatureSpecsRequest struct {
	ctx        context.Context
	ApiService *AssemblyApiService
	did        string
	wvm        string
	wvmid      string
	eid        string
}

func (r ApiGetFeatureSpecsRequest) Execute() (*BTFeatureSpecsResponse664, *http.Response, error) {
	return r.ApiService.GetFeatureSpecsExecute(r)
}

/*
GetFeatureSpecs Get the feature spec definitions for an assembly.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param wvm
	@param wvmid
	@param eid
	@return ApiGetFeatureSpecsRequest
*/
func (a *AssemblyApiService) GetFeatureSpecs(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetFeatureSpecsRequest {
	return ApiGetFeatureSpecsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTFeatureSpecsResponse664
func (a *AssemblyApiService) GetFeatureSpecsExecute(r ApiGetFeatureSpecsRequest) (*BTFeatureSpecsResponse664, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTFeatureSpecsResponse664
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.GetFeatureSpecs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/featurespecs"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTFeatureSpecsResponse664
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFeaturesRequest struct {
	ctx            context.Context
	ApiService     *AssemblyApiService
	did            string
	wvm            string
	wvmid          string
	eid            string
	linkDocumentId *string
	configuration  *string
	explodedViewId *string
	featureId      *[]string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetFeaturesRequest) LinkDocumentId(linkDocumentId string) ApiGetFeaturesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;) for the feature definition.
func (r ApiGetFeaturesRequest) Configuration(configuration string) ApiGetFeaturesRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetFeaturesRequest) ExplodedViewId(explodedViewId string) ApiGetFeaturesRequest {
	r.explodedViewId = &explodedViewId
	return r
}

func (r ApiGetFeaturesRequest) FeatureId(featureId []string) ApiGetFeaturesRequest {
	r.featureId = &featureId
	return r
}

func (r ApiGetFeaturesRequest) Execute() (*BTAssemblyFeatureListResponse1174, *http.Response, error) {
	return r.ApiService.GetFeaturesExecute(r)
}

/*
GetFeatures Get the definitions of the specified features in an assembly.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiGetFeaturesRequest
*/
func (a *AssemblyApiService) GetFeatures(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetFeaturesRequest {
	return ApiGetFeaturesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTAssemblyFeatureListResponse1174
func (a *AssemblyApiService) GetFeaturesExecute(r ApiGetFeaturesRequest) (*BTAssemblyFeatureListResponse1174, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAssemblyFeatureListResponse1174
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.GetFeatures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.explodedViewId != nil {
		localVarQueryParams.Add("explodedViewId", parameterToString(*r.explodedViewId, ""))
	}
	if r.featureId != nil {
		t := *r.featureId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("featureId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("featureId", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNamedPositionsRequest struct {
	ctx            context.Context
	ApiService     *AssemblyApiService
	did            string
	wvm            string
	wvmid          string
	eid            string
	linkDocumentId *string
	configuration  *string
	explodedViewId *string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetNamedPositionsRequest) LinkDocumentId(linkDocumentId string) ApiGetNamedPositionsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;) for the feature definition.
func (r ApiGetNamedPositionsRequest) Configuration(configuration string) ApiGetNamedPositionsRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetNamedPositionsRequest) ExplodedViewId(explodedViewId string) ApiGetNamedPositionsRequest {
	r.explodedViewId = &explodedViewId
	return r
}

func (r ApiGetNamedPositionsRequest) Execute() ([]BTViewFeatureBaseInfo, *http.Response, error) {
	return r.ApiService.GetNamedPositionsExecute(r)
}

/*
GetNamedPositions Get a list of all named positions for the assembly.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiGetNamedPositionsRequest
*/
func (a *AssemblyApiService) GetNamedPositions(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetNamedPositionsRequest {
	return ApiGetNamedPositionsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return []BTViewFeatureBaseInfo
func (a *AssemblyApiService) GetNamedPositionsExecute(r ApiGetNamedPositionsRequest) ([]BTViewFeatureBaseInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []BTViewFeatureBaseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.GetNamedPositions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/namedpositions"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.explodedViewId != nil {
		localVarQueryParams.Add("explodedViewId", parameterToString(*r.explodedViewId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v []BTViewFeatureBaseInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNamedViewsRequest struct {
	ctx                    context.Context
	ApiService             *AssemblyApiService
	did                    string
	eid                    string
	linkDocumentId         *string
	skipPerspective        *bool
	includeSectionCutViews *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetNamedViewsRequest) LinkDocumentId(linkDocumentId string) ApiGetNamedViewsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetNamedViewsRequest) SkipPerspective(skipPerspective bool) ApiGetNamedViewsRequest {
	r.skipPerspective = &skipPerspective
	return r
}

func (r ApiGetNamedViewsRequest) IncludeSectionCutViews(includeSectionCutViews bool) ApiGetNamedViewsRequest {
	r.includeSectionCutViews = &includeSectionCutViews
	return r
}

func (r ApiGetNamedViewsRequest) Execute() (*BTNamedViewsInfo, *http.Response, error) {
	return r.ApiService.GetNamedViewsExecute(r)
}

/*
GetNamedViews Get the view data for all named views for the specified element.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param eid
	@return ApiGetNamedViewsRequest
*/
func (a *AssemblyApiService) GetNamedViews(ctx context.Context, did string, eid string) ApiGetNamedViewsRequest {
	return ApiGetNamedViewsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTNamedViewsInfo
func (a *AssemblyApiService) GetNamedViewsExecute(r ApiGetNamedViewsRequest) (*BTNamedViewsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTNamedViewsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.GetNamedViews")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/e/{eid}/namedViews"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.skipPerspective != nil {
		localVarQueryParams.Add("skipPerspective", parameterToString(*r.skipPerspective, ""))
	}
	if r.includeSectionCutViews != nil {
		localVarQueryParams.Add("includeSectionCutViews", parameterToString(*r.includeSectionCutViews, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTNamedViewsInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrCreateBillOfMaterialsElementRequest struct {
	ctx        context.Context
	ApiService *AssemblyApiService
	did        string
	wid        string
	eid        string
}

func (r ApiGetOrCreateBillOfMaterialsElementRequest) Execute() (*BTDocumentElementInfo, *http.Response, error) {
	return r.ApiService.GetOrCreateBillOfMaterialsElementExecute(r)
}

/*
GetOrCreateBillOfMaterialsElement Gets the Bill Of Materials (BOM) for the specified assembly, or creates a BOM if none exist.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param wid
	@param eid
	@return ApiGetOrCreateBillOfMaterialsElementRequest
*/
func (a *AssemblyApiService) GetOrCreateBillOfMaterialsElement(ctx context.Context, did string, wid string, eid string) ApiGetOrCreateBillOfMaterialsElementRequest {
	return ApiGetOrCreateBillOfMaterialsElementRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTDocumentElementInfo
func (a *AssemblyApiService) GetOrCreateBillOfMaterialsElementExecute(r ApiGetOrCreateBillOfMaterialsElementRequest) (*BTDocumentElementInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTDocumentElementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.GetOrCreateBillOfMaterialsElement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/w/{wid}/e/{eid}/bomelement"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTDocumentElementInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsertTransformedInstancesRequest struct {
	ctx                                            context.Context
	ApiService                                     *AssemblyApiService
	did                                            string
	eid                                            string
	wid                                            string
	bTAssemblyTransformedInstancesDefinitionParams *BTAssemblyTransformedInstancesDefinitionParams
}

func (r ApiInsertTransformedInstancesRequest) BTAssemblyTransformedInstancesDefinitionParams(bTAssemblyTransformedInstancesDefinitionParams BTAssemblyTransformedInstancesDefinitionParams) ApiInsertTransformedInstancesRequest {
	r.bTAssemblyTransformedInstancesDefinitionParams = &bTAssemblyTransformedInstancesDefinitionParams
	return r
}

func (r ApiInsertTransformedInstancesRequest) Execute() (*BTAssemblyInsertTransformedInstancesResponse, *http.Response, error) {
	return r.ApiService.InsertTransformedInstancesExecute(r)
}

/*
InsertTransformedInstances Create new instances with transformation.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param eid
	@param wid
	@return ApiInsertTransformedInstancesRequest
*/
func (a *AssemblyApiService) InsertTransformedInstances(ctx context.Context, did string, eid string, wid string) ApiInsertTransformedInstancesRequest {
	return ApiInsertTransformedInstancesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wid:        wid,
	}
}

// Execute executes the request
//
//	@return BTAssemblyInsertTransformedInstancesResponse
func (a *AssemblyApiService) InsertTransformedInstancesExecute(r ApiInsertTransformedInstancesRequest) (*BTAssemblyInsertTransformedInstancesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAssemblyInsertTransformedInstancesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.InsertTransformedInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/w/{wid}/e/{eid}/transformedinstances"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTAssemblyTransformedInstancesDefinitionParams == nil {
		return localVarReturnValue, nil, reportError("bTAssemblyTransformedInstancesDefinitionParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAssemblyTransformedInstancesDefinitionParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAssemblyInsertTransformedInstancesResponse
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModifyRequest struct {
	ctx                          context.Context
	ApiService                   *AssemblyApiService
	did                          string
	wid                          string
	eid                          string
	linkDocumentId               *string
	bTAssemblyModificationParams *BTAssemblyModificationParams
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiModifyRequest) LinkDocumentId(linkDocumentId string) ApiModifyRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiModifyRequest) BTAssemblyModificationParams(bTAssemblyModificationParams BTAssemblyModificationParams) ApiModifyRequest {
	r.bTAssemblyModificationParams = &bTAssemblyModificationParams
	return r
}

func (r ApiModifyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ModifyExecute(r)
}

/*
Modify Modify an assembly.

This endpoint can include multiple modifications to an assembly with one change. For example, it can delete/suppress/unsuppress/transform multiple instances. It creates one history entry in the document history list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wid The id of the workspace in which to perform the operation.
	@param eid The id of the element in which to perform the operation.
	@return ApiModifyRequest
*/
func (a *AssemblyApiService) Modify(ctx context.Context, did string, wid string, eid string) ApiModifyRequest {
	return ApiModifyRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *AssemblyApiService) ModifyExecute(r ApiModifyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.Modify")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/w/{wid}/e/{eid}/modify"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAssemblyModificationParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransformOccurrencesRequest struct {
	ctx                                 context.Context
	ApiService                          *AssemblyApiService
	did                                 string
	eid                                 string
	wid                                 string
	bTAssemblyTransformDefinitionParams *BTAssemblyTransformDefinitionParams
}

func (r ApiTransformOccurrencesRequest) BTAssemblyTransformDefinitionParams(bTAssemblyTransformDefinitionParams BTAssemblyTransformDefinitionParams) ApiTransformOccurrencesRequest {
	r.bTAssemblyTransformDefinitionParams = &bTAssemblyTransformDefinitionParams
	return r
}

func (r ApiTransformOccurrencesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.TransformOccurrencesExecute(r)
}

/*
TransformOccurrences Transform a list of assembly occurrences.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param eid
	@param wid
	@return ApiTransformOccurrencesRequest
*/
func (a *AssemblyApiService) TransformOccurrences(ctx context.Context, did string, eid string, wid string) ApiTransformOccurrencesRequest {
	return ApiTransformOccurrencesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wid:        wid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *AssemblyApiService) TransformOccurrencesExecute(r ApiTransformOccurrencesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.TransformOccurrences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/w/{wid}/e/{eid}/occurrencetransforms"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAssemblyTransformDefinitionParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateFormatRequest struct {
	ctx                     context.Context
	ApiService              *AssemblyApiService
	did                     string
	wv                      string
	wvid                    string
	eid                     string
	bTTranslateFormatParams *BTTranslateFormatParams
}

func (r ApiTranslateFormatRequest) BTTranslateFormatParams(bTTranslateFormatParams BTTranslateFormatParams) ApiTranslateFormatRequest {
	r.bTTranslateFormatParams = &bTTranslateFormatParams
	return r
}

func (r ApiTranslateFormatRequest) Execute() (*BTTranslationRequestInfo, *http.Response, error) {
	return r.ApiService.TranslateFormatExecute(r)
}

/*
TranslateFormat Export the assembly to another format.

* Use `formatName` in the JSON request body to specify the export file type. Use [Translations/getAllTranslatorFormats](https://cad.onshape.com/glassworks/explorer/#/Translation/getAllTranslatorFormats) to get a list of valid export file formats. Confirm that `couldBeAssembly=true.`
* Set `storeInDocument` to `true` to export to a data file. Set to `false` to export to a blob element in the same document.
* See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/) for more details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param wv
	@param wvid
	@param eid
	@return ApiTranslateFormatRequest
*/
func (a *AssemblyApiService) TranslateFormat(ctx context.Context, did string, wv string, wvid string, eid string) ApiTranslateFormatRequest {
	return ApiTranslateFormatRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wv:         wv,
		wvid:       wvid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTTranslationRequestInfo
func (a *AssemblyApiService) TranslateFormatExecute(r ApiTranslateFormatRequest) (*BTTranslationRequestInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTTranslationRequestInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.TranslateFormat")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/{wv}/{wvid}/e/{eid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wv"+"}", url.PathEscape(parameterToString(r.wv, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvid"+"}", url.PathEscape(parameterToString(r.wvid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTTranslateFormatParams == nil {
		return localVarReturnValue, nil, reportError("bTTranslateFormatParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTTranslateFormatParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTTranslationRequestInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFeatureRequest struct {
	ctx                         context.Context
	ApiService                  *AssemblyApiService
	did                         string
	wid                         string
	eid                         string
	fid                         string
	bTFeatureDefinitionCall1406 *BTFeatureDefinitionCall1406
}

func (r ApiUpdateFeatureRequest) BTFeatureDefinitionCall1406(bTFeatureDefinitionCall1406 BTFeatureDefinitionCall1406) ApiUpdateFeatureRequest {
	r.bTFeatureDefinitionCall1406 = &bTFeatureDefinitionCall1406
	return r
}

func (r ApiUpdateFeatureRequest) Execute() (*BTFeatureDefinitionResponse1617, *http.Response, error) {
	return r.ApiService.UpdateFeatureExecute(r)
}

/*
UpdateFeature Update an existing feature for an Assembly.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param wid
	@param eid
	@param fid
	@return ApiUpdateFeatureRequest
*/
func (a *AssemblyApiService) UpdateFeature(ctx context.Context, did string, wid string, eid string, fid string) ApiUpdateFeatureRequest {
	return ApiUpdateFeatureRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
		fid:        fid,
	}
}

// Execute executes the request
//
//	@return BTFeatureDefinitionResponse1617
func (a *AssemblyApiService) UpdateFeatureExecute(r ApiUpdateFeatureRequest) (*BTFeatureDefinitionResponse1617, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTFeatureDefinitionResponse1617
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.UpdateFeature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/w/{wid}/e/{eid}/features/featureid/{fid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fid"+"}", url.PathEscape(parameterToString(r.fid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTFeatureDefinitionCall1406
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTFeatureDefinitionResponse1617
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
