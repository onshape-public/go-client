/*
Onshape REST API

The Onshape REST API consumed by all client. # Authorization The simplest way to authorize and enable the **Try it out** functionality is to sign in to Onshape and use the current session. The **Authorize** button enables other authorization techniques. To ensure the current session isn't used when trying other authentication techniques, make sure to remove the Onshape cookie as per the instructions for your particular browser. Alternatively, a private or incognito window may be used. Here's [how to remove a specific cookie on Chrome](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site). - **Current Session** authorization is enabled by default if the browser is already signed in to [Onshape](/). - **OAuth2** authorization uses an Onshape OAuth2 app created on the [Onshape Developer Portal](https://dev-portal.onshape.com/oauthApps). The redirect URL field should include `https://cad.onshape.com/glassworks/explorer/oauth2-redirect.html`. - **API Key** authorization using basic authentication is also available. The keys can be generated in the [Onshape Developer Portal](https://dev-portal.onshape.com/keys). In the authentication dialog, enter the access key in the `Username` field, and enter the secret key in the `Password` field. Basic authentication should only be used during the development process since sharing API Keys provides the same level of access as a username and password.

API version: 1.152.6126-5c3a878ad24b
Contact: api-support@onshape.zendesk.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package onshape

import (
	"context"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// AssemblyApiService AssemblyApi service
type AssemblyApiService service

type ApiAddFeatureRequest struct {
	ctx                         context.Context
	ApiService                  *AssemblyApiService
	did                         string
	wvm                         string
	wvmid                       string
	eid                         string
	bTFeatureDefinitionCall1406 *BTFeatureDefinitionCall1406
}

func (r ApiAddFeatureRequest) BTFeatureDefinitionCall1406(bTFeatureDefinitionCall1406 BTFeatureDefinitionCall1406) ApiAddFeatureRequest {
	r.bTFeatureDefinitionCall1406 = &bTFeatureDefinitionCall1406
	return r
}

func (r ApiAddFeatureRequest) Execute() (*BTFeatureDefinitionResponse1617, *http.Response, error) {
	return r.ApiService.AddFeatureExecute(r)
}

/*
AddFeature Create features array by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wvm
 @param wvmid
 @param eid
 @return ApiAddFeatureRequest
*/
func (a *AssemblyApiService) AddFeature(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiAddFeatureRequest {
	return ApiAddFeatureRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTFeatureDefinitionResponse1617
func (a *AssemblyApiService) AddFeatureExecute(r ApiAddFeatureRequest) (*BTFeatureDefinitionResponse1617, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTFeatureDefinitionResponse1617
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.AddFeature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTFeatureDefinitionCall1406
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTFeatureDefinitionResponse1617
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAssemblyRequest struct {
	ctx                  context.Context
	ApiService           *AssemblyApiService
	did                  string
	wid                  string
	bTModelElementParams *BTModelElementParams
}

func (r ApiCreateAssemblyRequest) BTModelElementParams(bTModelElementParams BTModelElementParams) ApiCreateAssemblyRequest {
	r.bTModelElementParams = &bTModelElementParams
	return r
}

func (r ApiCreateAssemblyRequest) Execute() (*BTDocumentElementInfo, *http.Response, error) {
	return r.ApiService.CreateAssemblyExecute(r)
}

/*
CreateAssembly Create Assembly by document ID and workspace ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wid
 @return ApiCreateAssemblyRequest
*/
func (a *AssemblyApiService) CreateAssembly(ctx context.Context, did string, wid string) ApiCreateAssemblyRequest {
	return ApiCreateAssemblyRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
	}
}

// Execute executes the request
//  @return BTDocumentElementInfo
func (a *AssemblyApiService) CreateAssemblyExecute(r ApiCreateAssemblyRequest) (*BTDocumentElementInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTDocumentElementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.CreateAssembly")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/w/{wid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTModelElementParams == nil {
		return localVarReturnValue, nil, reportError("bTModelElementParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTModelElementParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTDocumentElementInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateInstanceRequest struct {
	ctx                                context.Context
	ApiService                         *AssemblyApiService
	did                                string
	wid                                string
	eid                                string
	bTAssemblyInstanceDefinitionParams *BTAssemblyInstanceDefinitionParams
}

func (r ApiCreateInstanceRequest) BTAssemblyInstanceDefinitionParams(bTAssemblyInstanceDefinitionParams BTAssemblyInstanceDefinitionParams) ApiCreateInstanceRequest {
	r.bTAssemblyInstanceDefinitionParams = &bTAssemblyInstanceDefinitionParams
	return r
}

func (r ApiCreateInstanceRequest) Execute() ([]BTOccurrence74, *http.Response, error) {
	return r.ApiService.CreateInstanceExecute(r)
}

/*
CreateInstance Create Assembly instances by document ID, workspace ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wid
 @param eid
 @return ApiCreateInstanceRequest
*/
func (a *AssemblyApiService) CreateInstance(ctx context.Context, did string, wid string, eid string) ApiCreateInstanceRequest {
	return ApiCreateInstanceRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return []BTOccurrence74
func (a *AssemblyApiService) CreateInstanceExecute(r ApiCreateInstanceRequest) ([]BTOccurrence74, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []BTOccurrence74
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.CreateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/w/{wid}/e/{eid}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAssemblyInstanceDefinitionParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFeatureRequest struct {
	ctx        context.Context
	ApiService *AssemblyApiService
	did        string
	wid        string
	eid        string
	fid        string
}

func (r ApiDeleteFeatureRequest) Execute() (*BTFeatureApiBase1430, *http.Response, error) {
	return r.ApiService.DeleteFeatureExecute(r)
}

/*
DeleteFeature Delete a feature by document ID, workspace ID, tab ID, and feature ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wid
 @param eid
 @param fid
 @return ApiDeleteFeatureRequest
*/
func (a *AssemblyApiService) DeleteFeature(ctx context.Context, did string, wid string, eid string, fid string) ApiDeleteFeatureRequest {
	return ApiDeleteFeatureRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
		fid:        fid,
	}
}

// Execute executes the request
//  @return BTFeatureApiBase1430
func (a *AssemblyApiService) DeleteFeatureExecute(r ApiDeleteFeatureRequest) (*BTFeatureApiBase1430, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTFeatureApiBase1430
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.DeleteFeature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/w/{wid}/e/{eid}/features/featureid/{fid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fid"+"}", url.PathEscape(parameterToString(r.fid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteInstanceRequest struct {
	ctx        context.Context
	ApiService *AssemblyApiService
	did        string
	eid        string
	wid        string
	nid        string
}

func (r ApiDeleteInstanceRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteInstanceExecute(r)
}

/*
DeleteInstance Delete an instance by document ID, workspace ID, tab ID, and node ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param eid
 @param wid
 @param nid
 @return ApiDeleteInstanceRequest
*/
func (a *AssemblyApiService) DeleteInstance(ctx context.Context, did string, eid string, wid string, nid string) ApiDeleteInstanceRequest {
	return ApiDeleteInstanceRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wid:        wid,
		nid:        nid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AssemblyApiService) DeleteInstanceExecute(r ApiDeleteInstanceRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.DeleteInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/w/{wid}/e/{eid}/instance/nodeid/{nid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nid"+"}", url.PathEscape(parameterToString(r.nid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssemblyBoundingBoxesRequest struct {
	ctx             context.Context
	ApiService      *AssemblyApiService
	did             string
	wvm             string
	wvmid           string
	eid             string
	linkDocumentId  *string
	configuration   *string
	explodedViewId  *string
	includeHidden   *bool
	displayStateId  *string
	namedPositionId *string
	includeSketches *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetAssemblyBoundingBoxesRequest) LinkDocumentId(linkDocumentId string) ApiGetAssemblyBoundingBoxesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetAssemblyBoundingBoxesRequest) Configuration(configuration string) ApiGetAssemblyBoundingBoxesRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetAssemblyBoundingBoxesRequest) ExplodedViewId(explodedViewId string) ApiGetAssemblyBoundingBoxesRequest {
	r.explodedViewId = &explodedViewId
	return r
}

func (r ApiGetAssemblyBoundingBoxesRequest) IncludeHidden(includeHidden bool) ApiGetAssemblyBoundingBoxesRequest {
	r.includeHidden = &includeHidden
	return r
}

func (r ApiGetAssemblyBoundingBoxesRequest) DisplayStateId(displayStateId string) ApiGetAssemblyBoundingBoxesRequest {
	r.displayStateId = &displayStateId
	return r
}

func (r ApiGetAssemblyBoundingBoxesRequest) NamedPositionId(namedPositionId string) ApiGetAssemblyBoundingBoxesRequest {
	r.namedPositionId = &namedPositionId
	return r
}

func (r ApiGetAssemblyBoundingBoxesRequest) IncludeSketches(includeSketches bool) ApiGetAssemblyBoundingBoxesRequest {
	r.includeSketches = &includeSketches
	return r
}

func (r ApiGetAssemblyBoundingBoxesRequest) Execute() (*BTBoundingBoxInfo, *http.Response, error) {
	return r.ApiService.GetAssemblyBoundingBoxesExecute(r)
}

/*
GetAssemblyBoundingBoxes Retrieve bounding boxes by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace id, version id, or document microversion id is specified below.
 @param wvmid The id of the workspace, version, or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @return ApiGetAssemblyBoundingBoxesRequest
*/
func (a *AssemblyApiService) GetAssemblyBoundingBoxes(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetAssemblyBoundingBoxesRequest {
	return ApiGetAssemblyBoundingBoxesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTBoundingBoxInfo
func (a *AssemblyApiService) GetAssemblyBoundingBoxesExecute(r ApiGetAssemblyBoundingBoxesRequest) (*BTBoundingBoxInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTBoundingBoxInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.GetAssemblyBoundingBoxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/boundingboxes"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.explodedViewId != nil {
		localVarQueryParams.Add("explodedViewId", parameterToString(*r.explodedViewId, ""))
	}
	if r.includeHidden != nil {
		localVarQueryParams.Add("includeHidden", parameterToString(*r.includeHidden, ""))
	}
	if r.displayStateId != nil {
		localVarQueryParams.Add("displayStateId", parameterToString(*r.displayStateId, ""))
	}
	if r.namedPositionId != nil {
		localVarQueryParams.Add("namedPositionId", parameterToString(*r.namedPositionId, ""))
	}
	if r.includeSketches != nil {
		localVarQueryParams.Add("includeSketches", parameterToString(*r.includeSketches, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTBoundingBoxInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssemblyDefinitionRequest struct {
	ctx                   context.Context
	ApiService            *AssemblyApiService
	did                   string
	wvm                   string
	wvmid                 string
	eid                   string
	linkDocumentId        *string
	configuration         *string
	explodedViewId        *string
	includeMateFeatures   *bool
	includeNonSolids      *bool
	includeMateConnectors *bool
	excludeSuppressed     *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetAssemblyDefinitionRequest) LinkDocumentId(linkDocumentId string) ApiGetAssemblyDefinitionRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetAssemblyDefinitionRequest) Configuration(configuration string) ApiGetAssemblyDefinitionRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetAssemblyDefinitionRequest) ExplodedViewId(explodedViewId string) ApiGetAssemblyDefinitionRequest {
	r.explodedViewId = &explodedViewId
	return r
}

func (r ApiGetAssemblyDefinitionRequest) IncludeMateFeatures(includeMateFeatures bool) ApiGetAssemblyDefinitionRequest {
	r.includeMateFeatures = &includeMateFeatures
	return r
}

func (r ApiGetAssemblyDefinitionRequest) IncludeNonSolids(includeNonSolids bool) ApiGetAssemblyDefinitionRequest {
	r.includeNonSolids = &includeNonSolids
	return r
}

func (r ApiGetAssemblyDefinitionRequest) IncludeMateConnectors(includeMateConnectors bool) ApiGetAssemblyDefinitionRequest {
	r.includeMateConnectors = &includeMateConnectors
	return r
}

// Whether or not to exclude suppressed instances/mate features in response
func (r ApiGetAssemblyDefinitionRequest) ExcludeSuppressed(excludeSuppressed bool) ApiGetAssemblyDefinitionRequest {
	r.excludeSuppressed = &excludeSuppressed
	return r
}

func (r ApiGetAssemblyDefinitionRequest) Execute() (*BTAssemblyDefinitionInfo, *http.Response, error) {
	return r.ApiService.GetAssemblyDefinitionExecute(r)
}

/*
GetAssemblyDefinition Retrieve assembly by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace id, version id, or document microversion id is specified below.
 @param wvmid The id of the workspace, version, or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @return ApiGetAssemblyDefinitionRequest
*/
func (a *AssemblyApiService) GetAssemblyDefinition(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetAssemblyDefinitionRequest {
	return ApiGetAssemblyDefinitionRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTAssemblyDefinitionInfo
func (a *AssemblyApiService) GetAssemblyDefinitionExecute(r ApiGetAssemblyDefinitionRequest) (*BTAssemblyDefinitionInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAssemblyDefinitionInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.GetAssemblyDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.explodedViewId != nil {
		localVarQueryParams.Add("explodedViewId", parameterToString(*r.explodedViewId, ""))
	}
	if r.includeMateFeatures != nil {
		localVarQueryParams.Add("includeMateFeatures", parameterToString(*r.includeMateFeatures, ""))
	}
	if r.includeNonSolids != nil {
		localVarQueryParams.Add("includeNonSolids", parameterToString(*r.includeNonSolids, ""))
	}
	if r.includeMateConnectors != nil {
		localVarQueryParams.Add("includeMateConnectors", parameterToString(*r.includeMateConnectors, ""))
	}
	if r.excludeSuppressed != nil {
		localVarQueryParams.Add("excludeSuppressed", parameterToString(*r.excludeSuppressed, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAssemblyDefinitionInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssemblyMassPropertiesRequest struct {
	ctx            context.Context
	ApiService     *AssemblyApiService
	did            string
	wvm            string
	wvmid          string
	eid            string
	linkDocumentId *string
	configuration  *string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetAssemblyMassPropertiesRequest) LinkDocumentId(linkDocumentId string) ApiGetAssemblyMassPropertiesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetAssemblyMassPropertiesRequest) Configuration(configuration string) ApiGetAssemblyMassPropertiesRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetAssemblyMassPropertiesRequest) Execute() (*BTMassPropertiesInfoNull, *http.Response, error) {
	return r.ApiService.GetAssemblyMassPropertiesExecute(r)
}

/*
GetAssemblyMassProperties Method for GetAssemblyMassProperties

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace id, version id, or document microversion id is specified below.
 @param wvmid The id of the workspace, version, or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @return ApiGetAssemblyMassPropertiesRequest
*/
func (a *AssemblyApiService) GetAssemblyMassProperties(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetAssemblyMassPropertiesRequest {
	return ApiGetAssemblyMassPropertiesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTMassPropertiesInfoNull
func (a *AssemblyApiService) GetAssemblyMassPropertiesExecute(r ApiGetAssemblyMassPropertiesRequest) (*BTMassPropertiesInfoNull, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTMassPropertiesInfoNull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.GetAssemblyMassProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/massproperties"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTMassPropertiesInfoNull
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssemblyShadedViewsRequest struct {
	ctx             context.Context
	ApiService      *AssemblyApiService
	did             string
	wvm             string
	wvmid           string
	eid             string
	linkDocumentId  *string
	configuration   *string
	explodedViewId  *string
	viewMatrix      *string
	outputHeight    *int32
	outputWidth     *int32
	pixelSize       *float64
	edges           *string
	showAllParts    *bool
	includeSurfaces *bool
	useAntiAliasing *bool
	includeWires    *bool
	displayStateId  *string
	namedPositionId *string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetAssemblyShadedViewsRequest) LinkDocumentId(linkDocumentId string) ApiGetAssemblyShadedViewsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) Configuration(configuration string) ApiGetAssemblyShadedViewsRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) ExplodedViewId(explodedViewId string) ApiGetAssemblyShadedViewsRequest {
	r.explodedViewId = &explodedViewId
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) ViewMatrix(viewMatrix string) ApiGetAssemblyShadedViewsRequest {
	r.viewMatrix = &viewMatrix
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) OutputHeight(outputHeight int32) ApiGetAssemblyShadedViewsRequest {
	r.outputHeight = &outputHeight
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) OutputWidth(outputWidth int32) ApiGetAssemblyShadedViewsRequest {
	r.outputWidth = &outputWidth
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) PixelSize(pixelSize float64) ApiGetAssemblyShadedViewsRequest {
	r.pixelSize = &pixelSize
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) Edges(edges string) ApiGetAssemblyShadedViewsRequest {
	r.edges = &edges
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) ShowAllParts(showAllParts bool) ApiGetAssemblyShadedViewsRequest {
	r.showAllParts = &showAllParts
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) IncludeSurfaces(includeSurfaces bool) ApiGetAssemblyShadedViewsRequest {
	r.includeSurfaces = &includeSurfaces
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) UseAntiAliasing(useAntiAliasing bool) ApiGetAssemblyShadedViewsRequest {
	r.useAntiAliasing = &useAntiAliasing
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) IncludeWires(includeWires bool) ApiGetAssemblyShadedViewsRequest {
	r.includeWires = &includeWires
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) DisplayStateId(displayStateId string) ApiGetAssemblyShadedViewsRequest {
	r.displayStateId = &displayStateId
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) NamedPositionId(namedPositionId string) ApiGetAssemblyShadedViewsRequest {
	r.namedPositionId = &namedPositionId
	return r
}

func (r ApiGetAssemblyShadedViewsRequest) Execute() (*BTShadedViewsInfo, *http.Response, error) {
	return r.ApiService.GetAssemblyShadedViewsExecute(r)
}

/*
GetAssemblyShadedViews Retrieve an array of shaded view images by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace id, version id, or document microversion id is specified below.
 @param wvmid The id of the workspace, version, or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @return ApiGetAssemblyShadedViewsRequest
*/
func (a *AssemblyApiService) GetAssemblyShadedViews(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetAssemblyShadedViewsRequest {
	return ApiGetAssemblyShadedViewsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTShadedViewsInfo
func (a *AssemblyApiService) GetAssemblyShadedViewsExecute(r ApiGetAssemblyShadedViewsRequest) (*BTShadedViewsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTShadedViewsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.GetAssemblyShadedViews")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/shadedviews"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.explodedViewId != nil {
		localVarQueryParams.Add("explodedViewId", parameterToString(*r.explodedViewId, ""))
	}
	if r.viewMatrix != nil {
		localVarQueryParams.Add("viewMatrix", parameterToString(*r.viewMatrix, ""))
	}
	if r.outputHeight != nil {
		localVarQueryParams.Add("outputHeight", parameterToString(*r.outputHeight, ""))
	}
	if r.outputWidth != nil {
		localVarQueryParams.Add("outputWidth", parameterToString(*r.outputWidth, ""))
	}
	if r.pixelSize != nil {
		localVarQueryParams.Add("pixelSize", parameterToString(*r.pixelSize, ""))
	}
	if r.edges != nil {
		localVarQueryParams.Add("edges", parameterToString(*r.edges, ""))
	}
	if r.showAllParts != nil {
		localVarQueryParams.Add("showAllParts", parameterToString(*r.showAllParts, ""))
	}
	if r.includeSurfaces != nil {
		localVarQueryParams.Add("includeSurfaces", parameterToString(*r.includeSurfaces, ""))
	}
	if r.useAntiAliasing != nil {
		localVarQueryParams.Add("useAntiAliasing", parameterToString(*r.useAntiAliasing, ""))
	}
	if r.includeWires != nil {
		localVarQueryParams.Add("includeWires", parameterToString(*r.includeWires, ""))
	}
	if r.displayStateId != nil {
		localVarQueryParams.Add("displayStateId", parameterToString(*r.displayStateId, ""))
	}
	if r.namedPositionId != nil {
		localVarQueryParams.Add("namedPositionId", parameterToString(*r.namedPositionId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTShadedViewsInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBillOfMaterialsRequest struct {
	ctx                          context.Context
	ApiService                   *AssemblyApiService
	did                          string
	wvm                          string
	wvmid                        string
	eid                          string
	linkDocumentId               *string
	configuration                *string
	bomColumnIds                 *[]string
	indented                     *bool
	multiLevel                   *bool
	generateIfAbsent             *bool
	templateId                   *string
	includeExcluded              *bool
	onlyVisibleColumns           *bool
	ignoreSubassemblyBomBehavior *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetBillOfMaterialsRequest) LinkDocumentId(linkDocumentId string) ApiGetBillOfMaterialsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetBillOfMaterialsRequest) Configuration(configuration string) ApiGetBillOfMaterialsRequest {
	r.configuration = &configuration
	return r
}

// Ids of the columns to include, or all columnns if empty. BOM column ids correspond to metadata property ids.
func (r ApiGetBillOfMaterialsRequest) BomColumnIds(bomColumnIds []string) ApiGetBillOfMaterialsRequest {
	r.bomColumnIds = &bomColumnIds
	return r
}

// Return the Structured BOM table with all rows collapsed, otherwise returns the Flattened BOM.
func (r ApiGetBillOfMaterialsRequest) Indented(indented bool) ApiGetBillOfMaterialsRequest {
	r.indented = &indented
	return r
}

// Return the Structured BOM table with all rows expanded. Ignored if indented is false.
func (r ApiGetBillOfMaterialsRequest) MultiLevel(multiLevel bool) ApiGetBillOfMaterialsRequest {
	r.multiLevel = &multiLevel
	return r
}

// Return the BOM table data even if the BOM does not exist. If this is false and the BOM does not exist, a 404 status code will be returned. This option is highly recommended.
func (r ApiGetBillOfMaterialsRequest) GenerateIfAbsent(generateIfAbsent bool) ApiGetBillOfMaterialsRequest {
	r.generateIfAbsent = &generateIfAbsent
	return r
}

// The id of the BOM table template to use when generating the table.
func (r ApiGetBillOfMaterialsRequest) TemplateId(templateId string) ApiGetBillOfMaterialsRequest {
	r.templateId = &templateId
	return r
}

// Include items that have been excluded from the BOM table.
func (r ApiGetBillOfMaterialsRequest) IncludeExcluded(includeExcluded bool) ApiGetBillOfMaterialsRequest {
	r.includeExcluded = &includeExcluded
	return r
}

// Only return data for visible columns, instead of all possible columns.
func (r ApiGetBillOfMaterialsRequest) OnlyVisibleColumns(onlyVisibleColumns bool) ApiGetBillOfMaterialsRequest {
	r.onlyVisibleColumns = &onlyVisibleColumns
	return r
}

// Ignore the &#39;Subassembly BOM behavior&#39; property when constructing the BOM table.
func (r ApiGetBillOfMaterialsRequest) IgnoreSubassemblyBomBehavior(ignoreSubassemblyBomBehavior bool) ApiGetBillOfMaterialsRequest {
	r.ignoreSubassemblyBomBehavior = &ignoreSubassemblyBomBehavior
	return r
}

func (r ApiGetBillOfMaterialsRequest) Execute() (*BTBillOfMaterialsInfo, *http.Response, error) {
	return r.ApiService.GetBillOfMaterialsExecute(r)
}

/*
GetBillOfMaterials Retrieve the bill of materials (BOM) by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace id, version id, or document microversion id is specified below.
 @param wvmid The id of the workspace, version, or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @return ApiGetBillOfMaterialsRequest
*/
func (a *AssemblyApiService) GetBillOfMaterials(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetBillOfMaterialsRequest {
	return ApiGetBillOfMaterialsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTBillOfMaterialsInfo
func (a *AssemblyApiService) GetBillOfMaterialsExecute(r ApiGetBillOfMaterialsRequest) (*BTBillOfMaterialsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTBillOfMaterialsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.GetBillOfMaterials")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/bom"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.bomColumnIds != nil {
		t := *r.bomColumnIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("bomColumnIds", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("bomColumnIds", parameterToString(t, "multi"))
		}
	}
	if r.indented != nil {
		localVarQueryParams.Add("indented", parameterToString(*r.indented, ""))
	}
	if r.multiLevel != nil {
		localVarQueryParams.Add("multiLevel", parameterToString(*r.multiLevel, ""))
	}
	if r.generateIfAbsent != nil {
		localVarQueryParams.Add("generateIfAbsent", parameterToString(*r.generateIfAbsent, ""))
	}
	if r.templateId != nil {
		localVarQueryParams.Add("templateId", parameterToString(*r.templateId, ""))
	}
	if r.includeExcluded != nil {
		localVarQueryParams.Add("includeExcluded", parameterToString(*r.includeExcluded, ""))
	}
	if r.onlyVisibleColumns != nil {
		localVarQueryParams.Add("onlyVisibleColumns", parameterToString(*r.onlyVisibleColumns, ""))
	}
	if r.ignoreSubassemblyBomBehavior != nil {
		localVarQueryParams.Add("ignoreSubassemblyBomBehavior", parameterToString(*r.ignoreSubassemblyBomBehavior, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTBillOfMaterialsInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExplodedViewsRequest struct {
	ctx            context.Context
	ApiService     *AssemblyApiService
	did            string
	wvm            string
	wvmid          string
	eid            string
	linkDocumentId *string
	configuration  *string
	explodedViewId *string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetExplodedViewsRequest) LinkDocumentId(linkDocumentId string) ApiGetExplodedViewsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetExplodedViewsRequest) Configuration(configuration string) ApiGetExplodedViewsRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetExplodedViewsRequest) ExplodedViewId(explodedViewId string) ApiGetExplodedViewsRequest {
	r.explodedViewId = &explodedViewId
	return r
}

func (r ApiGetExplodedViewsRequest) Execute() ([]BTViewFeatureBaseInfo, *http.Response, error) {
	return r.ApiService.GetExplodedViewsExecute(r)
}

/*
GetExplodedViews Method for GetExplodedViews

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace id, version id, or document microversion id is specified below.
 @param wvmid The id of the workspace, version, or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @return ApiGetExplodedViewsRequest
*/
func (a *AssemblyApiService) GetExplodedViews(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetExplodedViewsRequest {
	return ApiGetExplodedViewsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return []BTViewFeatureBaseInfo
func (a *AssemblyApiService) GetExplodedViewsExecute(r ApiGetExplodedViewsRequest) ([]BTViewFeatureBaseInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []BTViewFeatureBaseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.GetExplodedViews")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/explodedviews"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.explodedViewId != nil {
		localVarQueryParams.Add("explodedViewId", parameterToString(*r.explodedViewId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v []BTViewFeatureBaseInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFeatureSpecsRequest struct {
	ctx        context.Context
	ApiService *AssemblyApiService
	did        string
	wvm        string
	wvmid      string
	eid        string
}

func (r ApiGetFeatureSpecsRequest) Execute() (*BTFeatureSpecsResponse664, *http.Response, error) {
	return r.ApiService.GetFeatureSpecsExecute(r)
}

/*
GetFeatureSpecs Retrieve feature specifications array by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wvm
 @param wvmid
 @param eid
 @return ApiGetFeatureSpecsRequest
*/
func (a *AssemblyApiService) GetFeatureSpecs(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetFeatureSpecsRequest {
	return ApiGetFeatureSpecsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTFeatureSpecsResponse664
func (a *AssemblyApiService) GetFeatureSpecsExecute(r ApiGetFeatureSpecsRequest) (*BTFeatureSpecsResponse664, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTFeatureSpecsResponse664
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.GetFeatureSpecs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/featurespecs"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTFeatureSpecsResponse664
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFeaturesRequest struct {
	ctx            context.Context
	ApiService     *AssemblyApiService
	did            string
	wvm            string
	wvmid          string
	eid            string
	linkDocumentId *string
	configuration  *string
	explodedViewId *string
	featureId      *[]string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetFeaturesRequest) LinkDocumentId(linkDocumentId string) ApiGetFeaturesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetFeaturesRequest) Configuration(configuration string) ApiGetFeaturesRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetFeaturesRequest) ExplodedViewId(explodedViewId string) ApiGetFeaturesRequest {
	r.explodedViewId = &explodedViewId
	return r
}

func (r ApiGetFeaturesRequest) FeatureId(featureId []string) ApiGetFeaturesRequest {
	r.featureId = &featureId
	return r
}

func (r ApiGetFeaturesRequest) Execute() (*BTAssemblyFeatureListResponse1174, *http.Response, error) {
	return r.ApiService.GetFeaturesExecute(r)
}

/*
GetFeatures Retrieve features array by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace id, version id, or document microversion id is specified below.
 @param wvmid The id of the workspace, version, or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @return ApiGetFeaturesRequest
*/
func (a *AssemblyApiService) GetFeatures(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetFeaturesRequest {
	return ApiGetFeaturesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTAssemblyFeatureListResponse1174
func (a *AssemblyApiService) GetFeaturesExecute(r ApiGetFeaturesRequest) (*BTAssemblyFeatureListResponse1174, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAssemblyFeatureListResponse1174
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.GetFeatures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.explodedViewId != nil {
		localVarQueryParams.Add("explodedViewId", parameterToString(*r.explodedViewId, ""))
	}
	if r.featureId != nil {
		t := *r.featureId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("featureId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("featureId", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNamedPositionsRequest struct {
	ctx            context.Context
	ApiService     *AssemblyApiService
	did            string
	wvm            string
	wvmid          string
	eid            string
	linkDocumentId *string
	configuration  *string
	explodedViewId *string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetNamedPositionsRequest) LinkDocumentId(linkDocumentId string) ApiGetNamedPositionsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetNamedPositionsRequest) Configuration(configuration string) ApiGetNamedPositionsRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetNamedPositionsRequest) ExplodedViewId(explodedViewId string) ApiGetNamedPositionsRequest {
	r.explodedViewId = &explodedViewId
	return r
}

func (r ApiGetNamedPositionsRequest) Execute() ([]BTViewFeatureBaseInfo, *http.Response, error) {
	return r.ApiService.GetNamedPositionsExecute(r)
}

/*
GetNamedPositions Method for GetNamedPositions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace id, version id, or document microversion id is specified below.
 @param wvmid The id of the workspace, version, or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @return ApiGetNamedPositionsRequest
*/
func (a *AssemblyApiService) GetNamedPositions(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetNamedPositionsRequest {
	return ApiGetNamedPositionsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return []BTViewFeatureBaseInfo
func (a *AssemblyApiService) GetNamedPositionsExecute(r ApiGetNamedPositionsRequest) ([]BTViewFeatureBaseInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []BTViewFeatureBaseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.GetNamedPositions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/namedpositions"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.explodedViewId != nil {
		localVarQueryParams.Add("explodedViewId", parameterToString(*r.explodedViewId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v []BTViewFeatureBaseInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNamedViewsRequest struct {
	ctx                    context.Context
	ApiService             *AssemblyApiService
	did                    string
	eid                    string
	linkDocumentId         *string
	skipPerspective        *bool
	includeSectionCutViews *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetNamedViewsRequest) LinkDocumentId(linkDocumentId string) ApiGetNamedViewsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetNamedViewsRequest) SkipPerspective(skipPerspective bool) ApiGetNamedViewsRequest {
	r.skipPerspective = &skipPerspective
	return r
}

func (r ApiGetNamedViewsRequest) IncludeSectionCutViews(includeSectionCutViews bool) ApiGetNamedViewsRequest {
	r.includeSectionCutViews = &includeSectionCutViews
	return r
}

func (r ApiGetNamedViewsRequest) Execute() (*BTNamedViewsInfo, *http.Response, error) {
	return r.ApiService.GetNamedViewsExecute(r)
}

/*
GetNamedViews Method for GetNamedViews

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param eid
 @return ApiGetNamedViewsRequest
*/
func (a *AssemblyApiService) GetNamedViews(ctx context.Context, did string, eid string) ApiGetNamedViewsRequest {
	return ApiGetNamedViewsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTNamedViewsInfo
func (a *AssemblyApiService) GetNamedViewsExecute(r ApiGetNamedViewsRequest) (*BTNamedViewsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTNamedViewsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.GetNamedViews")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/e/{eid}/namedViews"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.skipPerspective != nil {
		localVarQueryParams.Add("skipPerspective", parameterToString(*r.skipPerspective, ""))
	}
	if r.includeSectionCutViews != nil {
		localVarQueryParams.Add("includeSectionCutViews", parameterToString(*r.includeSectionCutViews, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTNamedViewsInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrCreateBillOfMaterialsElementRequest struct {
	ctx        context.Context
	ApiService *AssemblyApiService
	did        string
	wid        string
	eid        string
}

func (r ApiGetOrCreateBillOfMaterialsElementRequest) Execute() (*BTDocumentElementInfo, *http.Response, error) {
	return r.ApiService.GetOrCreateBillOfMaterialsElementExecute(r)
}

/*
GetOrCreateBillOfMaterialsElement Create a bill of materials (BOM) table by document ID, workspace ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wid
 @param eid
 @return ApiGetOrCreateBillOfMaterialsElementRequest
*/
func (a *AssemblyApiService) GetOrCreateBillOfMaterialsElement(ctx context.Context, did string, wid string, eid string) ApiGetOrCreateBillOfMaterialsElementRequest {
	return ApiGetOrCreateBillOfMaterialsElementRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTDocumentElementInfo
func (a *AssemblyApiService) GetOrCreateBillOfMaterialsElementExecute(r ApiGetOrCreateBillOfMaterialsElementRequest) (*BTDocumentElementInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTDocumentElementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.GetOrCreateBillOfMaterialsElement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/w/{wid}/e/{eid}/bomelement"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTDocumentElementInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsertTransformedInstancesRequest struct {
	ctx                                            context.Context
	ApiService                                     *AssemblyApiService
	did                                            string
	eid                                            string
	wid                                            string
	bTAssemblyTransformedInstancesDefinitionParams *BTAssemblyTransformedInstancesDefinitionParams
}

func (r ApiInsertTransformedInstancesRequest) BTAssemblyTransformedInstancesDefinitionParams(bTAssemblyTransformedInstancesDefinitionParams BTAssemblyTransformedInstancesDefinitionParams) ApiInsertTransformedInstancesRequest {
	r.bTAssemblyTransformedInstancesDefinitionParams = &bTAssemblyTransformedInstancesDefinitionParams
	return r
}

func (r ApiInsertTransformedInstancesRequest) Execute() (*BTAssemblyInsertTransformedInstancesResponse, *http.Response, error) {
	return r.ApiService.InsertTransformedInstancesExecute(r)
}

/*
InsertTransformedInstances Create an instance transform by document ID, workspace ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param eid
 @param wid
 @return ApiInsertTransformedInstancesRequest
*/
func (a *AssemblyApiService) InsertTransformedInstances(ctx context.Context, did string, eid string, wid string) ApiInsertTransformedInstancesRequest {
	return ApiInsertTransformedInstancesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wid:        wid,
	}
}

// Execute executes the request
//  @return BTAssemblyInsertTransformedInstancesResponse
func (a *AssemblyApiService) InsertTransformedInstancesExecute(r ApiInsertTransformedInstancesRequest) (*BTAssemblyInsertTransformedInstancesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAssemblyInsertTransformedInstancesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.InsertTransformedInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/w/{wid}/e/{eid}/transformedinstances"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTAssemblyTransformedInstancesDefinitionParams == nil {
		return localVarReturnValue, nil, reportError("bTAssemblyTransformedInstancesDefinitionParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAssemblyTransformedInstancesDefinitionParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAssemblyInsertTransformedInstancesResponse
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransformOccurrencesRequest struct {
	ctx                                 context.Context
	ApiService                          *AssemblyApiService
	did                                 string
	eid                                 string
	wid                                 string
	bTAssemblyTransformDefinitionParams *BTAssemblyTransformDefinitionParams
}

func (r ApiTransformOccurrencesRequest) BTAssemblyTransformDefinitionParams(bTAssemblyTransformDefinitionParams BTAssemblyTransformDefinitionParams) ApiTransformOccurrencesRequest {
	r.bTAssemblyTransformDefinitionParams = &bTAssemblyTransformDefinitionParams
	return r
}

func (r ApiTransformOccurrencesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.TransformOccurrencesExecute(r)
}

/*
TransformOccurrences Create an occurrence transform by document ID, workspace ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param eid
 @param wid
 @return ApiTransformOccurrencesRequest
*/
func (a *AssemblyApiService) TransformOccurrences(ctx context.Context, did string, eid string, wid string) ApiTransformOccurrencesRequest {
	return ApiTransformOccurrencesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wid:        wid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AssemblyApiService) TransformOccurrencesExecute(r ApiTransformOccurrencesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.TransformOccurrences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/w/{wid}/e/{eid}/occurrencetransforms"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAssemblyTransformDefinitionParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateFormatRequest struct {
	ctx                     context.Context
	ApiService              *AssemblyApiService
	did                     string
	wv                      string
	wvid                    string
	eid                     string
	bTTranslateFormatParams *BTTranslateFormatParams
}

func (r ApiTranslateFormatRequest) BTTranslateFormatParams(bTTranslateFormatParams BTTranslateFormatParams) ApiTranslateFormatRequest {
	r.bTTranslateFormatParams = &bTTranslateFormatParams
	return r
}

func (r ApiTranslateFormatRequest) Execute() (*BTTranslationRequestInfo, *http.Response, error) {
	return r.ApiService.TranslateFormatExecute(r)
}

/*
TranslateFormat Create assembly translation by document ID, workspace or version ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wv
 @param wvid
 @param eid
 @return ApiTranslateFormatRequest
*/
func (a *AssemblyApiService) TranslateFormat(ctx context.Context, did string, wv string, wvid string, eid string) ApiTranslateFormatRequest {
	return ApiTranslateFormatRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wv:         wv,
		wvid:       wvid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTTranslationRequestInfo
func (a *AssemblyApiService) TranslateFormatExecute(r ApiTranslateFormatRequest) (*BTTranslationRequestInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTTranslationRequestInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.TranslateFormat")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/{wv}/{wvid}/e/{eid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wv"+"}", url.PathEscape(parameterToString(r.wv, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvid"+"}", url.PathEscape(parameterToString(r.wvid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTTranslateFormatParams == nil {
		return localVarReturnValue, nil, reportError("bTTranslateFormatParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTTranslateFormatParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTTranslationRequestInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFeatureRequest struct {
	ctx                         context.Context
	ApiService                  *AssemblyApiService
	did                         string
	wid                         string
	eid                         string
	fid                         string
	bTFeatureDefinitionCall1406 *BTFeatureDefinitionCall1406
}

func (r ApiUpdateFeatureRequest) BTFeatureDefinitionCall1406(bTFeatureDefinitionCall1406 BTFeatureDefinitionCall1406) ApiUpdateFeatureRequest {
	r.bTFeatureDefinitionCall1406 = &bTFeatureDefinitionCall1406
	return r
}

func (r ApiUpdateFeatureRequest) Execute() (*BTFeatureDefinitionResponse1617, *http.Response, error) {
	return r.ApiService.UpdateFeatureExecute(r)
}

/*
UpdateFeature Upload a feature by document ID, workspace ID, tab ID, and feature ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wid
 @param eid
 @param fid
 @return ApiUpdateFeatureRequest
*/
func (a *AssemblyApiService) UpdateFeature(ctx context.Context, did string, wid string, eid string, fid string) ApiUpdateFeatureRequest {
	return ApiUpdateFeatureRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
		fid:        fid,
	}
}

// Execute executes the request
//  @return BTFeatureDefinitionResponse1617
func (a *AssemblyApiService) UpdateFeatureExecute(r ApiUpdateFeatureRequest) (*BTFeatureDefinitionResponse1617, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTFeatureDefinitionResponse1617
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssemblyApiService.UpdateFeature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assemblies/d/{did}/w/{wid}/e/{eid}/features/featureid/{fid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fid"+"}", url.PathEscape(parameterToString(r.fid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTFeatureDefinitionCall1406
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTFeatureDefinitionResponse1617
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
