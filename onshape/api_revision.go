/*
Onshape REST API

## Welcome to the Onshape REST API Explorer  To use this API explorer, sign in to your [Onshape](https://cad.onshape.com) account in another tab, then click the **Try it out** button below (it toggles to a **Cancel** button when selected).  See the **[API Explorer Guide](https://onshape-public.github.io/docs/api-intro/explorer/)** for help navigating this API Explorer, including **[authentication](https://onshape-public.github.io/docs/api-intro/explorer/#authentication)**.  **Tip:** To ensure the current session isn't used when trying other authentication techniques, make sure to [remove the Onshape cookie](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site) as per the instructions for your browser. Alternatively, you can use a private or incognito window.  ## See Also  * [Onshape API Guide](https://onshape-public.github.io/docs/): Our full suite of developer guides, to be used as an accompaniment to this API Explorer. * [Onshape Developer Portal](https://cad.onshape.com/appstore/dev-portal): The Onshape portal for managing your API keys, OAuth2 credentials, your Onshape applications, and your Onshape App Store entries. * [Authentication Guide](https://onshape-public.github.io/docs/auth/): Our guide to using API keys, request signatures, and OAuth2 in  your Onshape applications.

Contact: api-support@onshape.zendesk.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package onshape

import (
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// RevisionApiService RevisionApi service
type RevisionApiService service

type ApiDeleteRevisionHistoryRequest struct {
	ctx                   context.Context
	ApiService            *RevisionApiService
	cid                   string
	pnum                  string
	et                    string
	ignoreLinkedDocuments *bool
}

func (r ApiDeleteRevisionHistoryRequest) IgnoreLinkedDocuments(ignoreLinkedDocuments bool) ApiDeleteRevisionHistoryRequest {
	r.ignoreLinkedDocuments = &ignoreLinkedDocuments
	return r
}

func (r ApiDeleteRevisionHistoryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteRevisionHistoryExecute(r)
}

/*
DeleteRevisionHistory Delete all revisions for a part number.

Only company admins can call this API. All documents that contain or use the part number must be deleted first. This operation cannot be undone.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cid
	@param pnum
	@param et
	@return ApiDeleteRevisionHistoryRequest
*/
func (a *RevisionApiService) DeleteRevisionHistory(ctx context.Context, cid string, pnum string, et string) ApiDeleteRevisionHistoryRequest {
	return ApiDeleteRevisionHistoryRequest{
		ApiService: a,
		ctx:        ctx,
		cid:        cid,
		pnum:       pnum,
		et:         et,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *RevisionApiService) DeleteRevisionHistoryExecute(r ApiDeleteRevisionHistoryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RevisionApiService.DeleteRevisionHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revisions/companies/{cid}/partnumber/{pnum}/elementType/{et}"
	localVarPath = strings.Replace(localVarPath, "{"+"cid"+"}", url.PathEscape(parameterToString(r.cid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pnum"+"}", url.PathEscape(parameterToString(r.pnum, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"et"+"}", url.PathEscape(parameterToString(r.et, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ignoreLinkedDocuments != nil {
		localVarQueryParams.Add("ignoreLinkedDocuments", parameterToString(*r.ignoreLinkedDocuments, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnumerateRevisionsRequest struct {
	ctx         context.Context
	ApiService  *RevisionApiService
	cid         string
	elementType *int32
	limit       *int32
	latestOnly  *bool
	after       *JSONTime
}

// 0: Part Studio, 1: Assembly, 2: Drawing. 4: Blob
func (r ApiEnumerateRevisionsRequest) ElementType(elementType int32) ApiEnumerateRevisionsRequest {
	r.elementType = &elementType
	return r
}

// The number of items to return in a single API call
func (r ApiEnumerateRevisionsRequest) Limit(limit int32) ApiEnumerateRevisionsRequest {
	r.limit = &limit
	return r
}

// Whether to limit search to only latest revisions.
func (r ApiEnumerateRevisionsRequest) LatestOnly(latestOnly bool) ApiEnumerateRevisionsRequest {
	r.latestOnly = &latestOnly
	return r
}

// The earliest creation date of the revision to find.
func (r ApiEnumerateRevisionsRequest) After(after JSONTime) ApiEnumerateRevisionsRequest {
	r.after = &after
	return r
}

func (r ApiEnumerateRevisionsRequest) Execute() (*BTListResponseBTRevisionInfo, *http.Response, error) {
	return r.ApiService.EnumerateRevisionsExecute(r)
}

/*
EnumerateRevisions Enumerate all of a company's revisions.

* Returns a slice of all revisions per API call.
* To get the next set of results, use the `next` URL from the response body.
* This API can only be called by company admins.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cid The company or enterprise ID that owns the resource.
	@return ApiEnumerateRevisionsRequest
*/
func (a *RevisionApiService) EnumerateRevisions(ctx context.Context, cid string) ApiEnumerateRevisionsRequest {
	return ApiEnumerateRevisionsRequest{
		ApiService: a,
		ctx:        ctx,
		cid:        cid,
	}
}

// Execute executes the request
//
//	@return BTListResponseBTRevisionInfo
func (a *RevisionApiService) EnumerateRevisionsExecute(r ApiEnumerateRevisionsRequest) (*BTListResponseBTRevisionInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTListResponseBTRevisionInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RevisionApiService.EnumerateRevisions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revisions/companies/{cid}"
	localVarPath = strings.Replace(localVarPath, "{"+"cid"+"}", url.PathEscape(parameterToString(r.cid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.elementType != nil {
		localVarQueryParams.Add("elementType", parameterToString(*r.elementType, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.latestOnly != nil {
		localVarQueryParams.Add("latestOnly", parameterToString(*r.latestOnly, ""))
	}
	if r.after != nil {
		localVarQueryParams.Add("after", parameterToString(*r.after, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTListResponseBTRevisionInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllInDocumentRequest struct {
	ctx        context.Context
	ApiService *RevisionApiService
	did        string
}

func (r ApiGetAllInDocumentRequest) Execute() (*BTListResponseBTRevisionInfo, *http.Response, error) {
	return r.ApiService.GetAllInDocumentExecute(r)
}

/*
GetAllInDocument Get all revisions for the specified document.

Retrieve a list of all revisions that exist in a document and are owned by the document's owning company.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@return ApiGetAllInDocumentRequest
*/
func (a *RevisionApiService) GetAllInDocument(ctx context.Context, did string) ApiGetAllInDocumentRequest {
	return ApiGetAllInDocumentRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
	}
}

// Execute executes the request
//
//	@return BTListResponseBTRevisionInfo
func (a *RevisionApiService) GetAllInDocumentExecute(r ApiGetAllInDocumentRequest) (*BTListResponseBTRevisionInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTListResponseBTRevisionInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RevisionApiService.GetAllInDocument")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revisions/d/{did}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTListResponseBTRevisionInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllInDocumentVersionRequest struct {
	ctx        context.Context
	ApiService *RevisionApiService
	did        string
	vid        string
}

func (r ApiGetAllInDocumentVersionRequest) Execute() (*BTListResponseBTRevisionInfo, *http.Response, error) {
	return r.ApiService.GetAllInDocumentVersionExecute(r)
}

/*
GetAllInDocumentVersion Get all revisions for a version.

Retrieve a list of all revisions that exist in a document version and are owned by the document's owning company.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param vid
	@return ApiGetAllInDocumentVersionRequest
*/
func (a *RevisionApiService) GetAllInDocumentVersion(ctx context.Context, did string, vid string) ApiGetAllInDocumentVersionRequest {
	return ApiGetAllInDocumentVersionRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		vid:        vid,
	}
}

// Execute executes the request
//
//	@return BTListResponseBTRevisionInfo
func (a *RevisionApiService) GetAllInDocumentVersionExecute(r ApiGetAllInDocumentVersionRequest) (*BTListResponseBTRevisionInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTListResponseBTRevisionInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RevisionApiService.GetAllInDocumentVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revisions/d/{did}/v/{vid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vid"+"}", url.PathEscape(parameterToString(r.vid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTListResponseBTRevisionInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLatestInDocumentOrCompanyRequest struct {
	ctx        context.Context
	ApiService *RevisionApiService
	cd         string
	cdid       string
	pnum       string
	et         *string
}

// 0: Part Studio, 1: Assembly, 2: Drawing. 4: Blob
func (r ApiGetLatestInDocumentOrCompanyRequest) Et(et string) ApiGetLatestInDocumentOrCompanyRequest {
	r.et = &et
	return r
}

func (r ApiGetLatestInDocumentOrCompanyRequest) Execute() (*BTRevisionInfo, *http.Response, error) {
	return r.ApiService.GetLatestInDocumentOrCompanyExecute(r)
}

/*
GetLatestInDocumentOrCompany Get the latest revision for a part number in a document or company.

Returns 204 if no revisions are found.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cd
	@param cdid
	@param pnum
	@return ApiGetLatestInDocumentOrCompanyRequest
*/
func (a *RevisionApiService) GetLatestInDocumentOrCompany(ctx context.Context, cd string, cdid string, pnum string) ApiGetLatestInDocumentOrCompanyRequest {
	return ApiGetLatestInDocumentOrCompanyRequest{
		ApiService: a,
		ctx:        ctx,
		cd:         cd,
		cdid:       cdid,
		pnum:       pnum,
	}
}

// Execute executes the request
//
//	@return BTRevisionInfo
func (a *RevisionApiService) GetLatestInDocumentOrCompanyExecute(r ApiGetLatestInDocumentOrCompanyRequest) (*BTRevisionInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTRevisionInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RevisionApiService.GetLatestInDocumentOrCompany")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revisions/{cd}/{cdid}/p/{pnum}/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"cd"+"}", url.PathEscape(parameterToString(r.cd, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cdid"+"}", url.PathEscape(parameterToString(r.cdid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pnum"+"}", url.PathEscape(parameterToString(r.pnum, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.et == nil {
		return localVarReturnValue, nil, reportError("et is required and must be specified")
	}

	localVarQueryParams.Add("et", parameterToString(*r.et, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTRevisionInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRevisionByPartNumberRequest struct {
	ctx         context.Context
	ApiService  *RevisionApiService
	cid         string
	pnum        string
	revision    *string
	elementType *int32
}

// Revision
func (r ApiGetRevisionByPartNumberRequest) Revision(revision string) ApiGetRevisionByPartNumberRequest {
	r.revision = &revision
	return r
}

// 0: Part Studio, 1: Assembly, 2: Drawing. 4: Blob
func (r ApiGetRevisionByPartNumberRequest) ElementType(elementType int32) ApiGetRevisionByPartNumberRequest {
	r.elementType = &elementType
	return r
}

func (r ApiGetRevisionByPartNumberRequest) Execute() (*BTRevisionInfo, *http.Response, error) {
	return r.ApiService.GetRevisionByPartNumberExecute(r)
}

/*
GetRevisionByPartNumber Get a list of revisions by part number.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cid Company id
	@param pnum Part Number
	@return ApiGetRevisionByPartNumberRequest
*/
func (a *RevisionApiService) GetRevisionByPartNumber(ctx context.Context, cid string, pnum string) ApiGetRevisionByPartNumberRequest {
	return ApiGetRevisionByPartNumberRequest{
		ApiService: a,
		ctx:        ctx,
		cid:        cid,
		pnum:       pnum,
	}
}

// Execute executes the request
//
//	@return BTRevisionInfo
func (a *RevisionApiService) GetRevisionByPartNumberExecute(r ApiGetRevisionByPartNumberRequest) (*BTRevisionInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTRevisionInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RevisionApiService.GetRevisionByPartNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revisions/c/{cid}/partnumber/{pnum}"
	localVarPath = strings.Replace(localVarPath, "{"+"cid"+"}", url.PathEscape(parameterToString(r.cid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pnum"+"}", url.PathEscape(parameterToString(r.pnum, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.revision != nil {
		localVarQueryParams.Add("revision", parameterToString(*r.revision, ""))
	}
	if r.elementType != nil {
		localVarQueryParams.Add("elementType", parameterToString(*r.elementType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTRevisionInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRevisionHistoryInCompanyByElementIdRequest struct {
	ctx                  context.Context
	ApiService           *RevisionApiService
	cid                  string
	did                  string
	wv                   string
	wvid                 string
	eid                  string
	elementType          *string
	linkDocumentId       *string
	configuration        *string
	fillApprovers        *bool
	fillExportPermission *bool
	supportChangeType    *bool
}

func (r ApiGetRevisionHistoryInCompanyByElementIdRequest) ElementType(elementType string) ApiGetRevisionHistoryInCompanyByElementIdRequest {
	r.elementType = &elementType
	return r
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetRevisionHistoryInCompanyByElementIdRequest) LinkDocumentId(linkDocumentId string) ApiGetRevisionHistoryInCompanyByElementIdRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;). See the [Configurations API Guide](https://onshape-public.github.io/docs/api-adv/configs/) for details.
func (r ApiGetRevisionHistoryInCompanyByElementIdRequest) Configuration(configuration string) ApiGetRevisionHistoryInCompanyByElementIdRequest {
	r.configuration = &configuration
	return r
}

// Set to &#x60;true&#x60; to return a list of approvers. Default is &#x60;false&#x60; and will return &#x60;null&#x60;.
func (r ApiGetRevisionHistoryInCompanyByElementIdRequest) FillApprovers(fillApprovers bool) ApiGetRevisionHistoryInCompanyByElementIdRequest {
	r.fillApprovers = &fillApprovers
	return r
}

func (r ApiGetRevisionHistoryInCompanyByElementIdRequest) FillExportPermission(fillExportPermission bool) ApiGetRevisionHistoryInCompanyByElementIdRequest {
	r.fillExportPermission = &fillExportPermission
	return r
}

func (r ApiGetRevisionHistoryInCompanyByElementIdRequest) SupportChangeType(supportChangeType bool) ApiGetRevisionHistoryInCompanyByElementIdRequest {
	r.supportChangeType = &supportChangeType
	return r
}

func (r ApiGetRevisionHistoryInCompanyByElementIdRequest) Execute() (*BTRevisionListResponse, *http.Response, error) {
	return r.ApiService.GetRevisionHistoryInCompanyByElementIdExecute(r)
}

/*
GetRevisionHistoryInCompanyByElementId Get a list of all revisions for an element in a company-owned document.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cid
	@param did The id of the document in which to perform the operation.
	@param wv Indicates which of workspace (w) or version (v) id is specified below.
	@param wvid The id of the workspace, version in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiGetRevisionHistoryInCompanyByElementIdRequest
*/
func (a *RevisionApiService) GetRevisionHistoryInCompanyByElementId(ctx context.Context, cid string, did string, wv string, wvid string, eid string) ApiGetRevisionHistoryInCompanyByElementIdRequest {
	return ApiGetRevisionHistoryInCompanyByElementIdRequest{
		ApiService: a,
		ctx:        ctx,
		cid:        cid,
		did:        did,
		wv:         wv,
		wvid:       wvid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTRevisionListResponse
func (a *RevisionApiService) GetRevisionHistoryInCompanyByElementIdExecute(r ApiGetRevisionHistoryInCompanyByElementIdRequest) (*BTRevisionListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTRevisionListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RevisionApiService.GetRevisionHistoryInCompanyByElementId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revisions/companies/{cid}/d/{did}/{wv}/{wvid}/e/{eid}"
	localVarPath = strings.Replace(localVarPath, "{"+"cid"+"}", url.PathEscape(parameterToString(r.cid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wv"+"}", url.PathEscape(parameterToString(r.wv, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvid"+"}", url.PathEscape(parameterToString(r.wvid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.elementType == nil {
		return localVarReturnValue, nil, reportError("elementType is required and must be specified")
	}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	localVarQueryParams.Add("elementType", parameterToString(*r.elementType, ""))
	if r.fillApprovers != nil {
		localVarQueryParams.Add("fillApprovers", parameterToString(*r.fillApprovers, ""))
	}
	if r.fillExportPermission != nil {
		localVarQueryParams.Add("fillExportPermission", parameterToString(*r.fillExportPermission, ""))
	}
	if r.supportChangeType != nil {
		localVarQueryParams.Add("supportChangeType", parameterToString(*r.supportChangeType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTRevisionListResponse
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRevisionHistoryInCompanyByPartIdRequest struct {
	ctx                  context.Context
	ApiService           *RevisionApiService
	cid                  string
	did                  string
	wv                   string
	wvid                 string
	eid                  string
	pid                  string
	configuration        *string
	linkDocumentId       *string
	fillApprovers        *bool
	fillExportPermission *bool
	supportChangeType    *bool
}

func (r ApiGetRevisionHistoryInCompanyByPartIdRequest) Configuration(configuration string) ApiGetRevisionHistoryInCompanyByPartIdRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetRevisionHistoryInCompanyByPartIdRequest) LinkDocumentId(linkDocumentId string) ApiGetRevisionHistoryInCompanyByPartIdRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// Set to &#x60;true&#x60; to return a list of approvers. Default is &#x60;false&#x60; and will return &#x60;null&#x60;.
func (r ApiGetRevisionHistoryInCompanyByPartIdRequest) FillApprovers(fillApprovers bool) ApiGetRevisionHistoryInCompanyByPartIdRequest {
	r.fillApprovers = &fillApprovers
	return r
}

func (r ApiGetRevisionHistoryInCompanyByPartIdRequest) FillExportPermission(fillExportPermission bool) ApiGetRevisionHistoryInCompanyByPartIdRequest {
	r.fillExportPermission = &fillExportPermission
	return r
}

func (r ApiGetRevisionHistoryInCompanyByPartIdRequest) SupportChangeType(supportChangeType bool) ApiGetRevisionHistoryInCompanyByPartIdRequest {
	r.supportChangeType = &supportChangeType
	return r
}

func (r ApiGetRevisionHistoryInCompanyByPartIdRequest) Execute() (*BTRevisionListResponse, *http.Response, error) {
	return r.ApiService.GetRevisionHistoryInCompanyByPartIdExecute(r)
}

/*
GetRevisionHistoryInCompanyByPartId Get a list of all revisions for a part in a company-owned document by part ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cid
	@param did
	@param wv
	@param wvid
	@param eid
	@param pid
	@return ApiGetRevisionHistoryInCompanyByPartIdRequest
*/
func (a *RevisionApiService) GetRevisionHistoryInCompanyByPartId(ctx context.Context, cid string, did string, wv string, wvid string, eid string, pid string) ApiGetRevisionHistoryInCompanyByPartIdRequest {
	return ApiGetRevisionHistoryInCompanyByPartIdRequest{
		ApiService: a,
		ctx:        ctx,
		cid:        cid,
		did:        did,
		wv:         wv,
		wvid:       wvid,
		eid:        eid,
		pid:        pid,
	}
}

// Execute executes the request
//
//	@return BTRevisionListResponse
func (a *RevisionApiService) GetRevisionHistoryInCompanyByPartIdExecute(r ApiGetRevisionHistoryInCompanyByPartIdRequest) (*BTRevisionListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTRevisionListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RevisionApiService.GetRevisionHistoryInCompanyByPartId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revisions/companies/{cid}/d/{did}/{wv}/{wvid}/e/{eid}/p/{pid}"
	localVarPath = strings.Replace(localVarPath, "{"+"cid"+"}", url.PathEscape(parameterToString(r.cid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wv"+"}", url.PathEscape(parameterToString(r.wv, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvid"+"}", url.PathEscape(parameterToString(r.wvid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pid"+"}", url.PathEscape(parameterToString(r.pid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.fillApprovers != nil {
		localVarQueryParams.Add("fillApprovers", parameterToString(*r.fillApprovers, ""))
	}
	if r.fillExportPermission != nil {
		localVarQueryParams.Add("fillExportPermission", parameterToString(*r.fillExportPermission, ""))
	}
	if r.supportChangeType != nil {
		localVarQueryParams.Add("supportChangeType", parameterToString(*r.supportChangeType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTRevisionListResponse
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRevisionHistoryInCompanyByPartNumberRequest struct {
	ctx                  context.Context
	ApiService           *RevisionApiService
	cid                  string
	pnum                 string
	elementType          *string
	fillApprovers        *bool
	fillExportPermission *bool
	supportChangeType    *bool
}

func (r ApiGetRevisionHistoryInCompanyByPartNumberRequest) ElementType(elementType string) ApiGetRevisionHistoryInCompanyByPartNumberRequest {
	r.elementType = &elementType
	return r
}

// Set to &#x60;true&#x60; to return a list of approvers. Default is &#x60;false&#x60; and will return &#x60;null&#x60;.
func (r ApiGetRevisionHistoryInCompanyByPartNumberRequest) FillApprovers(fillApprovers bool) ApiGetRevisionHistoryInCompanyByPartNumberRequest {
	r.fillApprovers = &fillApprovers
	return r
}

func (r ApiGetRevisionHistoryInCompanyByPartNumberRequest) FillExportPermission(fillExportPermission bool) ApiGetRevisionHistoryInCompanyByPartNumberRequest {
	r.fillExportPermission = &fillExportPermission
	return r
}

func (r ApiGetRevisionHistoryInCompanyByPartNumberRequest) SupportChangeType(supportChangeType bool) ApiGetRevisionHistoryInCompanyByPartNumberRequest {
	r.supportChangeType = &supportChangeType
	return r
}

func (r ApiGetRevisionHistoryInCompanyByPartNumberRequest) Execute() (*BTRevisionListResponse, *http.Response, error) {
	return r.ApiService.GetRevisionHistoryInCompanyByPartNumberExecute(r)
}

/*
GetRevisionHistoryInCompanyByPartNumber Get a list of all revisions for a part or element in a company-owned document by part number.

You can also request `elementType` in addition to `partNumber` since companies may or may not allow drawings to share part numbers with their parts/assemblies. To perform search without `elementType`, use `elementType` = -1 | UNKNOWN. Available element types are: -1: Unknown, 0: Part Studio, 1: Assembly, 2: Drawing, 4: Blob, 5: Application, 8: Variable Studio 10: Unknown

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cid
	@param pnum
	@return ApiGetRevisionHistoryInCompanyByPartNumberRequest
*/
func (a *RevisionApiService) GetRevisionHistoryInCompanyByPartNumber(ctx context.Context, cid string, pnum string) ApiGetRevisionHistoryInCompanyByPartNumberRequest {
	return ApiGetRevisionHistoryInCompanyByPartNumberRequest{
		ApiService: a,
		ctx:        ctx,
		cid:        cid,
		pnum:       pnum,
	}
}

// Execute executes the request
//
//	@return BTRevisionListResponse
func (a *RevisionApiService) GetRevisionHistoryInCompanyByPartNumberExecute(r ApiGetRevisionHistoryInCompanyByPartNumberRequest) (*BTRevisionListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTRevisionListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RevisionApiService.GetRevisionHistoryInCompanyByPartNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revisions/companies/{cid}/partnumber/{pnum}"
	localVarPath = strings.Replace(localVarPath, "{"+"cid"+"}", url.PathEscape(parameterToString(r.cid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pnum"+"}", url.PathEscape(parameterToString(r.pnum, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.elementType == nil {
		return localVarReturnValue, nil, reportError("elementType is required and must be specified")
	}

	localVarQueryParams.Add("elementType", parameterToString(*r.elementType, ""))
	if r.fillApprovers != nil {
		localVarQueryParams.Add("fillApprovers", parameterToString(*r.fillApprovers, ""))
	}
	if r.fillExportPermission != nil {
		localVarQueryParams.Add("fillExportPermission", parameterToString(*r.fillExportPermission, ""))
	}
	if r.supportChangeType != nil {
		localVarQueryParams.Add("supportChangeType", parameterToString(*r.supportChangeType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTRevisionListResponse
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
