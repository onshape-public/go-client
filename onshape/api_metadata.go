/*
Onshape REST API

The Onshape REST API consumed by all client. # Authorization The simplest way to authorize and enable the **Try it out** functionality is to sign in to Onshape and use the current session. The **Authorize** button enables other authorization techniques. To ensure the current session isn't used when trying other authentication techniques, make sure to remove the Onshape cookie as per the instructions for your particular browser. Alternatively, a private or incognito window may be used. Here's [how to remove a specific cookie on Chrome](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site). - **Current Session** authorization is enabled by default if the browser is already signed in to [Onshape](/). - **OAuth2** authorization uses an Onshape OAuth2 app created on the [Onshape Developer Portal](https://dev-portal.onshape.com/oauthApps). The redirect URL field should include `https://cad.onshape.com/glassworks/explorer/oauth2-redirect.html`. - **API Key** authorization using basic authentication is also available. The keys can be generated in the [Onshape Developer Portal](https://dev-portal.onshape.com/keys). In the authentication dialog, enter the access key in the `Username` field, and enter the secret key in the `Password` field. Basic authentication should only be used during the development process since sharing API Keys provides the same level of access as a username and password.

API version: 1.168.20544-ab34447a30b0
Contact: api-support@onshape.zendesk.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package onshape

import (
	"context"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// MetadataApiService MetadataApi service
type MetadataApiService service

type ApiGetVEOPStandardContentMetadataRequest struct {
	ctx                               context.Context
	ApiService                        *MetadataApiService
	did                               string
	vid                               string
	eid                               string
	pid                               string
	configuration                     *string
	linkDocumentId                    *string
	includeComputedProperties         *bool
	includeComputedAssemblyProperties *bool
	thumbnail                         *bool
}

func (r ApiGetVEOPStandardContentMetadataRequest) Configuration(configuration string) ApiGetVEOPStandardContentMetadataRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetVEOPStandardContentMetadataRequest) LinkDocumentId(linkDocumentId string) ApiGetVEOPStandardContentMetadataRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetVEOPStandardContentMetadataRequest) IncludeComputedProperties(includeComputedProperties bool) ApiGetVEOPStandardContentMetadataRequest {
	r.includeComputedProperties = &includeComputedProperties
	return r
}

func (r ApiGetVEOPStandardContentMetadataRequest) IncludeComputedAssemblyProperties(includeComputedAssemblyProperties bool) ApiGetVEOPStandardContentMetadataRequest {
	r.includeComputedAssemblyProperties = &includeComputedAssemblyProperties
	return r
}

func (r ApiGetVEOPStandardContentMetadataRequest) Thumbnail(thumbnail bool) ApiGetVEOPStandardContentMetadataRequest {
	r.thumbnail = &thumbnail
	return r
}

func (r ApiGetVEOPStandardContentMetadataRequest) Execute() (*BTMetadataObjectInfo, *http.Response, error) {
	return r.ApiService.GetVEOPStandardContentMetadataExecute(r)
}

/*
GetVEOPStandardContentMetadata Get the metadata for a standard content part.

* Specify the part in the `pid` path parameter.
* The `configuration` and `linkDocumentId` query parameters are required.
* `includeComputedProperties` can be used to include or omit computed properties. Default value is `true`.
* `includeComputedAssemblyProperties` can be used to query computed assembly properties which are generally expensive. Default value is `false`.
* You can also choose to include a `thumbnail`. Default value is `false`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param vid
 @param eid
 @param pid
 @return ApiGetVEOPStandardContentMetadataRequest
*/
func (a *MetadataApiService) GetVEOPStandardContentMetadata(ctx context.Context, did string, vid string, eid string, pid string) ApiGetVEOPStandardContentMetadataRequest {
	return ApiGetVEOPStandardContentMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		vid:        vid,
		eid:        eid,
		pid:        pid,
	}
}

// Execute executes the request
//  @return BTMetadataObjectInfo
func (a *MetadataApiService) GetVEOPStandardContentMetadataExecute(r ApiGetVEOPStandardContentMetadataRequest) (*BTMetadataObjectInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTMetadataObjectInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataApiService.GetVEOPStandardContentMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/standardcontent/d/{did}/v/{vid}/e/{eid}/p/{pid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vid"+"}", url.PathEscape(parameterToString(r.vid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pid"+"}", url.PathEscape(parameterToString(r.pid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.includeComputedProperties != nil {
		localVarQueryParams.Add("includeComputedProperties", parameterToString(*r.includeComputedProperties, ""))
	}
	if r.includeComputedAssemblyProperties != nil {
		localVarQueryParams.Add("includeComputedAssemblyProperties", parameterToString(*r.includeComputedAssemblyProperties, ""))
	}
	if r.thumbnail != nil {
		localVarQueryParams.Add("thumbnail", parameterToString(*r.thumbnail, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTMetadataObjectInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWMVEMetadataRequest struct {
	ctx                               context.Context
	ApiService                        *MetadataApiService
	did                               string
	wvm                               string
	wvmid                             string
	eid                               string
	linkDocumentId                    *string
	configuration                     *string
	inferMetadataOwner                *bool
	depth                             *string
	includeComputedProperties         *bool
	includeComputedAssemblyProperties *bool
	thumbnail                         *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetWMVEMetadataRequest) LinkDocumentId(linkDocumentId string) ApiGetWMVEMetadataRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetWMVEMetadataRequest) Configuration(configuration string) ApiGetWMVEMetadataRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetWMVEMetadataRequest) InferMetadataOwner(inferMetadataOwner bool) ApiGetWMVEMetadataRequest {
	r.inferMetadataOwner = &inferMetadataOwner
	return r
}

func (r ApiGetWMVEMetadataRequest) Depth(depth string) ApiGetWMVEMetadataRequest {
	r.depth = &depth
	return r
}

func (r ApiGetWMVEMetadataRequest) IncludeComputedProperties(includeComputedProperties bool) ApiGetWMVEMetadataRequest {
	r.includeComputedProperties = &includeComputedProperties
	return r
}

func (r ApiGetWMVEMetadataRequest) IncludeComputedAssemblyProperties(includeComputedAssemblyProperties bool) ApiGetWMVEMetadataRequest {
	r.includeComputedAssemblyProperties = &includeComputedAssemblyProperties
	return r
}

func (r ApiGetWMVEMetadataRequest) Thumbnail(thumbnail bool) ApiGetWMVEMetadataRequest {
	r.thumbnail = &thumbnail
	return r
}

func (r ApiGetWMVEMetadataRequest) Execute() (*BTMetadataObjectInfo, *http.Response, error) {
	return r.ApiService.GetWMVEMetadataExecute(r)
}

/*
GetWMVEMetadata Get the metadata for an element in a document, version or micro version.

* `linkDocumentId` can be specified where applicable and this combined with the query param `inferMetadataOwner` (default value is `false`) will be used to infer metadata owner.
* `configuration` optional query parameter defaults to default configuration.
* You can specify an optional `depth` query parameter to get multiple levels in an assembly. Default `depth` is `1`.
* `includeComputedProperties` can be used to include or omit computed properties. Default value is `true`.
* `includeComputedAssemblyProperties` can be used to query computed assembly properties which are generally expensive. Default value is `false`.
* You can also choose to include a `thumbnail`. Default value is `false`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
 @param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @return ApiGetWMVEMetadataRequest
*/
func (a *MetadataApiService) GetWMVEMetadata(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetWMVEMetadataRequest {
	return ApiGetWMVEMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTMetadataObjectInfo
func (a *MetadataApiService) GetWMVEMetadataExecute(r ApiGetWMVEMetadataRequest) (*BTMetadataObjectInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTMetadataObjectInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataApiService.GetWMVEMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/d/{did}/{wvm}/{wvmid}/e/{eid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.inferMetadataOwner != nil {
		localVarQueryParams.Add("inferMetadataOwner", parameterToString(*r.inferMetadataOwner, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	if r.includeComputedProperties != nil {
		localVarQueryParams.Add("includeComputedProperties", parameterToString(*r.includeComputedProperties, ""))
	}
	if r.includeComputedAssemblyProperties != nil {
		localVarQueryParams.Add("includeComputedAssemblyProperties", parameterToString(*r.includeComputedAssemblyProperties, ""))
	}
	if r.thumbnail != nil {
		localVarQueryParams.Add("thumbnail", parameterToString(*r.thumbnail, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTMetadataObjectInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWMVEPMetadataRequest struct {
	ctx                               context.Context
	ApiService                        *MetadataApiService
	did                               string
	wvm                               string
	wvmid                             string
	eid                               string
	iden                              string
	pid                               string
	linkDocumentId                    *string
	configuration                     *string
	rollbackBarIndex                  *int32
	elementMicroversionId             *string
	inferMetadataOwner                *bool
	includeComputedProperties         *bool
	includeComputedAssemblyProperties *bool
	thumbnail                         *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetWMVEPMetadataRequest) LinkDocumentId(linkDocumentId string) ApiGetWMVEPMetadataRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetWMVEPMetadataRequest) Configuration(configuration string) ApiGetWMVEPMetadataRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiGetWMVEPMetadataRequest) RollbackBarIndex(rollbackBarIndex int32) ApiGetWMVEPMetadataRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

// A specific element microversion in which to evaluate the request.
func (r ApiGetWMVEPMetadataRequest) ElementMicroversionId(elementMicroversionId string) ApiGetWMVEPMetadataRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiGetWMVEPMetadataRequest) InferMetadataOwner(inferMetadataOwner bool) ApiGetWMVEPMetadataRequest {
	r.inferMetadataOwner = &inferMetadataOwner
	return r
}

func (r ApiGetWMVEPMetadataRequest) IncludeComputedProperties(includeComputedProperties bool) ApiGetWMVEPMetadataRequest {
	r.includeComputedProperties = &includeComputedProperties
	return r
}

func (r ApiGetWMVEPMetadataRequest) IncludeComputedAssemblyProperties(includeComputedAssemblyProperties bool) ApiGetWMVEPMetadataRequest {
	r.includeComputedAssemblyProperties = &includeComputedAssemblyProperties
	return r
}

func (r ApiGetWMVEPMetadataRequest) Thumbnail(thumbnail bool) ApiGetWMVEPMetadataRequest {
	r.thumbnail = &thumbnail
	return r
}

func (r ApiGetWMVEPMetadataRequest) Execute() (*BTMetadataObjectInfo, *http.Response, error) {
	return r.ApiService.GetWMVEPMetadataExecute(r)
}

/*
GetWMVEPMetadata Get the metadata for a part in a document workspace or version or microversion, element.

* Specify the part in the `iden` or `pid` path parameter.
* The `configuration` optional query parameter uses the default configuration unless otherwise specified.
* `linkDocumentId` can be specified where applicable. Combined with `inferMetadataOwner` (default value is `false`), this is used to infer metadata owner.
* `includeComputedProperties` can be used to include or omit computed properties. Default value is `true`.
* `includeComputedAssemblyProperties` can be used to query computed assembly properties which are generally expensive. Default value is `false`.
* You can also choose to include a `thumbnail`. Default value is `false`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
 @param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @param iden Denotes whether the pid specified is a part id (p) or a part identity (pi).
 @param pid
 @return ApiGetWMVEPMetadataRequest
*/
func (a *MetadataApiService) GetWMVEPMetadata(ctx context.Context, did string, wvm string, wvmid string, eid string, iden string, pid string) ApiGetWMVEPMetadataRequest {
	return ApiGetWMVEPMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		iden:       iden,
		pid:        pid,
	}
}

// Execute executes the request
//  @return BTMetadataObjectInfo
func (a *MetadataApiService) GetWMVEPMetadataExecute(r ApiGetWMVEPMetadataRequest) (*BTMetadataObjectInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTMetadataObjectInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataApiService.GetWMVEPMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/d/{did}/{wvm}/{wvmid}/e/{eid}/{iden}/{pid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"iden"+"}", url.PathEscape(parameterToString(r.iden, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pid"+"}", url.PathEscape(parameterToString(r.pid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	if r.inferMetadataOwner != nil {
		localVarQueryParams.Add("inferMetadataOwner", parameterToString(*r.inferMetadataOwner, ""))
	}
	if r.includeComputedProperties != nil {
		localVarQueryParams.Add("includeComputedProperties", parameterToString(*r.includeComputedProperties, ""))
	}
	if r.includeComputedAssemblyProperties != nil {
		localVarQueryParams.Add("includeComputedAssemblyProperties", parameterToString(*r.includeComputedAssemblyProperties, ""))
	}
	if r.thumbnail != nil {
		localVarQueryParams.Add("thumbnail", parameterToString(*r.thumbnail, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTMetadataObjectInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWMVEPsMetadataRequest struct {
	ctx                               context.Context
	ApiService                        *MetadataApiService
	did                               string
	wvm                               string
	wvmid                             string
	eid                               string
	linkDocumentId                    *string
	configuration                     *string
	inferMetadataOwner                *bool
	includeComputedProperties         *bool
	includeComputedAssemblyProperties *bool
	thumbnail                         *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetWMVEPsMetadataRequest) LinkDocumentId(linkDocumentId string) ApiGetWMVEPsMetadataRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetWMVEPsMetadataRequest) Configuration(configuration string) ApiGetWMVEPsMetadataRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetWMVEPsMetadataRequest) InferMetadataOwner(inferMetadataOwner bool) ApiGetWMVEPsMetadataRequest {
	r.inferMetadataOwner = &inferMetadataOwner
	return r
}

func (r ApiGetWMVEPsMetadataRequest) IncludeComputedProperties(includeComputedProperties bool) ApiGetWMVEPsMetadataRequest {
	r.includeComputedProperties = &includeComputedProperties
	return r
}

func (r ApiGetWMVEPsMetadataRequest) IncludeComputedAssemblyProperties(includeComputedAssemblyProperties bool) ApiGetWMVEPsMetadataRequest {
	r.includeComputedAssemblyProperties = &includeComputedAssemblyProperties
	return r
}

func (r ApiGetWMVEPsMetadataRequest) Thumbnail(thumbnail bool) ApiGetWMVEPsMetadataRequest {
	r.thumbnail = &thumbnail
	return r
}

func (r ApiGetWMVEPsMetadataRequest) Execute() (*BTMetadataObjectListInfoBTMetadataPartInfo, *http.Response, error) {
	return r.ApiService.GetWMVEPsMetadataExecute(r)
}

/*
GetWMVEPsMetadata Get the metadata for all parts in a document workspace or version or microversion, element and configuration.

* The `configuration` optional query parameter uses the default configuration unless otherwise specified.
* You can specify an optional `depth` query parameter to get multiple levels in an assembly. Default `depth` is `1`.
* `linkDocumentId` can be specified where applicable. Combined with `inferMetadataOwner` (default value is `false`), this is used to infer metadata owner.
* `includeComputedProperties` can be used to include or omit computed properties. Default value is `true`.
* `includeComputedAssemblyProperties` can be used to query computed assembly properties which are generally expensive. Default value is `false`.
* You can also choose to include a `thumbnail`. Default value is `false`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
 @param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @return ApiGetWMVEPsMetadataRequest
*/
func (a *MetadataApiService) GetWMVEPsMetadata(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetWMVEPsMetadataRequest {
	return ApiGetWMVEPsMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTMetadataObjectListInfoBTMetadataPartInfo
func (a *MetadataApiService) GetWMVEPsMetadataExecute(r ApiGetWMVEPsMetadataRequest) (*BTMetadataObjectListInfoBTMetadataPartInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTMetadataObjectListInfoBTMetadataPartInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataApiService.GetWMVEPsMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/d/{did}/{wvm}/{wvmid}/e/{eid}/p"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.inferMetadataOwner != nil {
		localVarQueryParams.Add("inferMetadataOwner", parameterToString(*r.inferMetadataOwner, ""))
	}
	if r.includeComputedProperties != nil {
		localVarQueryParams.Add("includeComputedProperties", parameterToString(*r.includeComputedProperties, ""))
	}
	if r.includeComputedAssemblyProperties != nil {
		localVarQueryParams.Add("includeComputedAssemblyProperties", parameterToString(*r.includeComputedAssemblyProperties, ""))
	}
	if r.thumbnail != nil {
		localVarQueryParams.Add("thumbnail", parameterToString(*r.thumbnail, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTMetadataObjectListInfoBTMetadataPartInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWMVEsMetadataRequest struct {
	ctx                               context.Context
	ApiService                        *MetadataApiService
	did                               string
	wvm                               string
	wvmid                             string
	linkDocumentId                    *string
	inferMetadataOwner                *bool
	depth                             *string
	includeComputedProperties         *bool
	includeComputedAssemblyProperties *bool
	thumbnail                         *bool
}

func (r ApiGetWMVEsMetadataRequest) LinkDocumentId(linkDocumentId string) ApiGetWMVEsMetadataRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetWMVEsMetadataRequest) InferMetadataOwner(inferMetadataOwner bool) ApiGetWMVEsMetadataRequest {
	r.inferMetadataOwner = &inferMetadataOwner
	return r
}

func (r ApiGetWMVEsMetadataRequest) Depth(depth string) ApiGetWMVEsMetadataRequest {
	r.depth = &depth
	return r
}

func (r ApiGetWMVEsMetadataRequest) IncludeComputedProperties(includeComputedProperties bool) ApiGetWMVEsMetadataRequest {
	r.includeComputedProperties = &includeComputedProperties
	return r
}

func (r ApiGetWMVEsMetadataRequest) IncludeComputedAssemblyProperties(includeComputedAssemblyProperties bool) ApiGetWMVEsMetadataRequest {
	r.includeComputedAssemblyProperties = &includeComputedAssemblyProperties
	return r
}

func (r ApiGetWMVEsMetadataRequest) Thumbnail(thumbnail bool) ApiGetWMVEsMetadataRequest {
	r.thumbnail = &thumbnail
	return r
}

func (r ApiGetWMVEsMetadataRequest) Execute() (*BTMetadataObjectListInfoBTMetadataElementInfo, *http.Response, error) {
	return r.ApiService.GetWMVEsMetadataExecute(r)
}

/*
GetWMVEsMetadata Get the metadata for all elements in a document with given document id and version or microversion id.

* You can specify the optional `depth` query parameter to get multiple levels in an assembly. Default `depth` is `1`.
* `linkDocumentId` can be specified where applicable. Combined with `inferMetadataOwner` (default value is `false`), this is used to infer metadata owner.
* `includeComputedProperties` can be used to include or omit computed properties. Default value is `true`.
* `includeComputedAssemblyProperties` can be used to query computed assembly properties which are generally expensive. Default value is `false`.
* You can also choose to include a `thumbnail`. Default value is `false`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wvm
 @param wvmid
 @return ApiGetWMVEsMetadataRequest
*/
func (a *MetadataApiService) GetWMVEsMetadata(ctx context.Context, did string, wvm string, wvmid string) ApiGetWMVEsMetadataRequest {
	return ApiGetWMVEsMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
	}
}

// Execute executes the request
//  @return BTMetadataObjectListInfoBTMetadataElementInfo
func (a *MetadataApiService) GetWMVEsMetadataExecute(r ApiGetWMVEsMetadataRequest) (*BTMetadataObjectListInfoBTMetadataElementInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTMetadataObjectListInfoBTMetadataElementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataApiService.GetWMVEsMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/d/{did}/{wvm}/{wvmid}/e"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.inferMetadataOwner != nil {
		localVarQueryParams.Add("inferMetadataOwner", parameterToString(*r.inferMetadataOwner, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	if r.includeComputedProperties != nil {
		localVarQueryParams.Add("includeComputedProperties", parameterToString(*r.includeComputedProperties, ""))
	}
	if r.includeComputedAssemblyProperties != nil {
		localVarQueryParams.Add("includeComputedAssemblyProperties", parameterToString(*r.includeComputedAssemblyProperties, ""))
	}
	if r.thumbnail != nil {
		localVarQueryParams.Add("thumbnail", parameterToString(*r.thumbnail, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTMetadataObjectListInfoBTMetadataElementInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWVMetadataRequest struct {
	ctx                               context.Context
	ApiService                        *MetadataApiService
	did                               string
	wv                                string
	wvid                              string
	linkDocumentId                    *string
	inferMetadataOwner                *bool
	depth                             *string
	includeComputedProperties         *bool
	includeComputedAssemblyProperties *bool
	thumbnail                         *bool
}

func (r ApiGetWVMetadataRequest) LinkDocumentId(linkDocumentId string) ApiGetWVMetadataRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetWVMetadataRequest) InferMetadataOwner(inferMetadataOwner bool) ApiGetWVMetadataRequest {
	r.inferMetadataOwner = &inferMetadataOwner
	return r
}

func (r ApiGetWVMetadataRequest) Depth(depth string) ApiGetWVMetadataRequest {
	r.depth = &depth
	return r
}

func (r ApiGetWVMetadataRequest) IncludeComputedProperties(includeComputedProperties bool) ApiGetWVMetadataRequest {
	r.includeComputedProperties = &includeComputedProperties
	return r
}

func (r ApiGetWVMetadataRequest) IncludeComputedAssemblyProperties(includeComputedAssemblyProperties bool) ApiGetWVMetadataRequest {
	r.includeComputedAssemblyProperties = &includeComputedAssemblyProperties
	return r
}

func (r ApiGetWVMetadataRequest) Thumbnail(thumbnail bool) ApiGetWVMetadataRequest {
	r.thumbnail = &thumbnail
	return r
}

func (r ApiGetWVMetadataRequest) Execute() (*BTMetadataObjectInfo, *http.Response, error) {
	return r.ApiService.GetWVMetadataExecute(r)
}

/*
GetWVMetadata Get the metadata for a workspace or version in a document.

* `linkDocumentId` can be specified where applicable. Combined with `inferMetadataOwner` (default value is `false`), this is used to infer metadata owner.
* You can specify an optional `depth` query parameter to get multiple levels in an assembly. Default `depth` is `1`.
* `includeComputedProperties` can be used to include or omit computed properties. Default value is `true`.
* `includeComputedAssemblyProperties` can be used to query computed assembly properties which are generally expensive. Default value is `false`.
* You can also choose to include a `thumbnail`. Default value is `false`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wv
 @param wvid
 @return ApiGetWVMetadataRequest
*/
func (a *MetadataApiService) GetWVMetadata(ctx context.Context, did string, wv string, wvid string) ApiGetWVMetadataRequest {
	return ApiGetWVMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wv:         wv,
		wvid:       wvid,
	}
}

// Execute executes the request
//  @return BTMetadataObjectInfo
func (a *MetadataApiService) GetWVMetadataExecute(r ApiGetWVMetadataRequest) (*BTMetadataObjectInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTMetadataObjectInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataApiService.GetWVMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/d/{did}/{wv}/{wvid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wv"+"}", url.PathEscape(parameterToString(r.wv, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvid"+"}", url.PathEscape(parameterToString(r.wvid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.inferMetadataOwner != nil {
		localVarQueryParams.Add("inferMetadataOwner", parameterToString(*r.inferMetadataOwner, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	if r.includeComputedProperties != nil {
		localVarQueryParams.Add("includeComputedProperties", parameterToString(*r.includeComputedProperties, ""))
	}
	if r.includeComputedAssemblyProperties != nil {
		localVarQueryParams.Add("includeComputedAssemblyProperties", parameterToString(*r.includeComputedAssemblyProperties, ""))
	}
	if r.thumbnail != nil {
		localVarQueryParams.Add("thumbnail", parameterToString(*r.thumbnail, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTMetadataObjectInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateVEOPStandardContentPartMetadataRequest struct {
	ctx            context.Context
	ApiService     *MetadataApiService
	did            string
	linkDocumentId *string
	body           *string
}

func (r ApiUpdateVEOPStandardContentPartMetadataRequest) LinkDocumentId(linkDocumentId string) ApiUpdateVEOPStandardContentPartMetadataRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiUpdateVEOPStandardContentPartMetadataRequest) Body(body string) ApiUpdateVEOPStandardContentPartMetadataRequest {
	r.body = &body
	return r
}

func (r ApiUpdateVEOPStandardContentPartMetadataRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateVEOPStandardContentPartMetadataExecute(r)
}

/*
UpdateVEOPStandardContentPartMetadata Update the metadata in a document for a standard content part.

* Specify the document ID to update in the `did` path param.
* Specify the document in which you have inserted the standard content part in the `linkDocumentId` query param.
* Specify the property metadata to update in the Request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @return ApiUpdateVEOPStandardContentPartMetadataRequest
*/
func (a *MetadataApiService) UpdateVEOPStandardContentPartMetadata(ctx context.Context, did string) ApiUpdateVEOPStandardContentPartMetadataRequest {
	return ApiUpdateVEOPStandardContentPartMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MetadataApiService) UpdateVEOPStandardContentPartMetadataExecute(r ApiUpdateVEOPStandardContentPartMetadataRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataApiService.UpdateVEOPStandardContentPartMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/standardcontent/d/{did}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.linkDocumentId == nil {
		return localVarReturnValue, nil, reportError("linkDocumentId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWVEMetadataRequest struct {
	ctx           context.Context
	ApiService    *MetadataApiService
	did           string
	wvm           string
	wvmid         string
	eid           string
	body          *string
	configuration *string
}

func (r ApiUpdateWVEMetadataRequest) Body(body string) ApiUpdateWVEMetadataRequest {
	r.body = &body
	return r
}

func (r ApiUpdateWVEMetadataRequest) Configuration(configuration string) ApiUpdateWVEMetadataRequest {
	r.configuration = &configuration
	return r
}

func (r ApiUpdateWVEMetadataRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateWVEMetadataExecute(r)
}

/*
UpdateWVEMetadata Update the metadata for an element in a document workspace or version

* Microversion (`m`) in `wvm` path parameter option is not supported.
* Specify the property metadata to update in the Request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wvm
 @param wvmid
 @param eid
 @return ApiUpdateWVEMetadataRequest
*/
func (a *MetadataApiService) UpdateWVEMetadata(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiUpdateWVEMetadataRequest {
	return ApiUpdateWVEMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MetadataApiService) UpdateWVEMetadataExecute(r ApiUpdateWVEMetadataRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataApiService.UpdateWVEMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/d/{did}/{wvm}/{wvmid}/e/{eid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWVEPMetadataRequest struct {
	ctx                   context.Context
	ApiService            *MetadataApiService
	did                   string
	wvm                   string
	wvmid                 string
	eid                   string
	iden                  string
	pid                   string
	body                  *string
	linkDocumentId        *string
	configuration         *string
	rollbackBarIndex      *int32
	elementMicroversionId *string
}

func (r ApiUpdateWVEPMetadataRequest) Body(body string) ApiUpdateWVEPMetadataRequest {
	r.body = &body
	return r
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiUpdateWVEPMetadataRequest) LinkDocumentId(linkDocumentId string) ApiUpdateWVEPMetadataRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiUpdateWVEPMetadataRequest) Configuration(configuration string) ApiUpdateWVEPMetadataRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiUpdateWVEPMetadataRequest) RollbackBarIndex(rollbackBarIndex int32) ApiUpdateWVEPMetadataRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

// A specific element microversion in which to evaluate the request.
func (r ApiUpdateWVEPMetadataRequest) ElementMicroversionId(elementMicroversionId string) ApiUpdateWVEPMetadataRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiUpdateWVEPMetadataRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateWVEPMetadataExecute(r)
}

/*
UpdateWVEPMetadata Update the metadata for a part in a document workspace or version or microversion, element.

* Specify the part in the `iden` or `pid` path parameter.
* The `configuration` optional query parameter uses the default configuration unless otherwise specified.
* `linkDocumentId` can be specified where applicable. Combined with `inferMetadataOwner` (default value is `false`), this is used to infer metadata owner.
* Specify the property metadata to update in the Request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
 @param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @param iden Denotes whether the pid specified is a part id (p) or a part identity (pi).
 @param pid
 @return ApiUpdateWVEPMetadataRequest
*/
func (a *MetadataApiService) UpdateWVEPMetadata(ctx context.Context, did string, wvm string, wvmid string, eid string, iden string, pid string) ApiUpdateWVEPMetadataRequest {
	return ApiUpdateWVEPMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		iden:       iden,
		pid:        pid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MetadataApiService) UpdateWVEPMetadataExecute(r ApiUpdateWVEPMetadataRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataApiService.UpdateWVEPMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/d/{did}/{wvm}/{wvmid}/e/{eid}/{iden}/{pid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"iden"+"}", url.PathEscape(parameterToString(r.iden, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pid"+"}", url.PathEscape(parameterToString(r.pid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWVMetadataRequest struct {
	ctx        context.Context
	ApiService *MetadataApiService
	did        string
	wv         string
	wvid       string
	body       *string
}

func (r ApiUpdateWVMetadataRequest) Body(body string) ApiUpdateWVMetadataRequest {
	r.body = &body
	return r
}

func (r ApiUpdateWVMetadataRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateWVMetadataExecute(r)
}

/*
UpdateWVMetadata Update the metadata for a workspace or version in a document.

Specify the property metadata to update in the Request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wv
 @param wvid
 @return ApiUpdateWVMetadataRequest
*/
func (a *MetadataApiService) UpdateWVMetadata(ctx context.Context, did string, wv string, wvid string) ApiUpdateWVMetadataRequest {
	return ApiUpdateWVMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wv:         wv,
		wvid:       wvid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MetadataApiService) UpdateWVMetadataExecute(r ApiUpdateWVMetadataRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataApiService.UpdateWVMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/d/{did}/{wv}/{wvid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wv"+"}", url.PathEscape(parameterToString(r.wv, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvid"+"}", url.PathEscape(parameterToString(r.wvid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
