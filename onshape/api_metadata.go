/*
Onshape REST API

## Welcome to the Onshape REST API Explorer  To use this API explorer, sign in to your [Onshape](https://cad.onshape.com) account in another tab, then click the **Try it out** button below (it toggles to a **Cancel** button when selected).  See the **[API Explorer Guide](https://onshape-public.github.io/docs/api-intro/explorer/)** for help navigating this API Explorer, including **[authentication](https://onshape-public.github.io/docs/api-intro/explorer/#authentication)**.  **Tip:** To ensure the current session isn't used when trying other authentication techniques, make sure to [remove the Onshape cookie](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site) as per the instructions for your browser. Alternatively, you can use a private or incognito window.  ## See Also  * [Onshape API Guide](https://onshape-public.github.io/docs/): Our full suite of developer guides, to be used as an accompaniment to this API Explorer. * [Onshape Developer Portal](https://dev-portal.onshape.com/): The Onshape portal for managing your API keys, OAuth2 credentials, your Onshape applications, and your Onshape App Store entries. * [Authentication Guide](https://onshape-public.github.io/docs/auth/): Our guide to using API keys, request signatures, and OAuth2 in  your Onshape applications.

Contact: api-support@onshape.zendesk.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package onshape

import (
	"context"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// MetadataApiService MetadataApi service
type MetadataApiService service

type ApiGetVEOPStandardContentMetadataRequest struct {
	ctx                               context.Context
	ApiService                        *MetadataApiService
	did                               string
	vid                               string
	eid                               string
	pid                               string
	configuration                     *string
	linkDocumentId                    *string
	includeComputedProperties         *bool
	includeComputedAssemblyProperties *bool
	thumbnail                         *bool
}

func (r ApiGetVEOPStandardContentMetadataRequest) Configuration(configuration string) ApiGetVEOPStandardContentMetadataRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetVEOPStandardContentMetadataRequest) LinkDocumentId(linkDocumentId string) ApiGetVEOPStandardContentMetadataRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetVEOPStandardContentMetadataRequest) IncludeComputedProperties(includeComputedProperties bool) ApiGetVEOPStandardContentMetadataRequest {
	r.includeComputedProperties = &includeComputedProperties
	return r
}

func (r ApiGetVEOPStandardContentMetadataRequest) IncludeComputedAssemblyProperties(includeComputedAssemblyProperties bool) ApiGetVEOPStandardContentMetadataRequest {
	r.includeComputedAssemblyProperties = &includeComputedAssemblyProperties
	return r
}

func (r ApiGetVEOPStandardContentMetadataRequest) Thumbnail(thumbnail bool) ApiGetVEOPStandardContentMetadataRequest {
	r.thumbnail = &thumbnail
	return r
}

func (r ApiGetVEOPStandardContentMetadataRequest) Execute() (*BTMetadataObjectInfo, *http.Response, error) {
	return r.ApiService.GetVEOPStandardContentMetadataExecute(r)
}

/*
GetVEOPStandardContentMetadata Get the metadata for a standard content part.

See [API Guide: Metadata](https://onshape-public.github.io/docs/api-adv/metadata/) for details.
* Specify the part in the `pid` path parameter.
* The `configuration` and `linkDocumentId` query parameters are required.
* `includeComputedProperties` can be used to include or omit computed properties. Default value is `true`.
* `includeComputedAssemblyProperties` can be used to query computed assembly properties which are generally expensive. Default value is `false`.
* You can also choose to include a `thumbnail`. Default value is `false`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param vid
	@param eid
	@param pid
	@return ApiGetVEOPStandardContentMetadataRequest
*/
func (a *MetadataApiService) GetVEOPStandardContentMetadata(ctx context.Context, did string, vid string, eid string, pid string) ApiGetVEOPStandardContentMetadataRequest {
	return ApiGetVEOPStandardContentMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		vid:        vid,
		eid:        eid,
		pid:        pid,
	}
}

// Execute executes the request
//
//	@return BTMetadataObjectInfo
func (a *MetadataApiService) GetVEOPStandardContentMetadataExecute(r ApiGetVEOPStandardContentMetadataRequest) (*BTMetadataObjectInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTMetadataObjectInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataApiService.GetVEOPStandardContentMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/standardcontent/d/{did}/v/{vid}/e/{eid}/p/{pid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vid"+"}", url.PathEscape(parameterToString(r.vid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pid"+"}", url.PathEscape(parameterToString(r.pid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.includeComputedProperties != nil {
		localVarQueryParams.Add("includeComputedProperties", parameterToString(*r.includeComputedProperties, ""))
	}
	if r.includeComputedAssemblyProperties != nil {
		localVarQueryParams.Add("includeComputedAssemblyProperties", parameterToString(*r.includeComputedAssemblyProperties, ""))
	}
	if r.thumbnail != nil {
		localVarQueryParams.Add("thumbnail", parameterToString(*r.thumbnail, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTMetadataObjectInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWMVEMetadataRequest struct {
	ctx                               context.Context
	ApiService                        *MetadataApiService
	did                               string
	wvm                               string
	wvmid                             string
	eid                               string
	linkDocumentId                    *string
	configuration                     *string
	inferMetadataOwner                *bool
	depth                             *string
	includeComputedProperties         *bool
	includeComputedAssemblyProperties *bool
	thumbnail                         *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetWMVEMetadataRequest) LinkDocumentId(linkDocumentId string) ApiGetWMVEMetadataRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetWMVEMetadataRequest) Configuration(configuration string) ApiGetWMVEMetadataRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetWMVEMetadataRequest) InferMetadataOwner(inferMetadataOwner bool) ApiGetWMVEMetadataRequest {
	r.inferMetadataOwner = &inferMetadataOwner
	return r
}

func (r ApiGetWMVEMetadataRequest) Depth(depth string) ApiGetWMVEMetadataRequest {
	r.depth = &depth
	return r
}

func (r ApiGetWMVEMetadataRequest) IncludeComputedProperties(includeComputedProperties bool) ApiGetWMVEMetadataRequest {
	r.includeComputedProperties = &includeComputedProperties
	return r
}

func (r ApiGetWMVEMetadataRequest) IncludeComputedAssemblyProperties(includeComputedAssemblyProperties bool) ApiGetWMVEMetadataRequest {
	r.includeComputedAssemblyProperties = &includeComputedAssemblyProperties
	return r
}

func (r ApiGetWMVEMetadataRequest) Thumbnail(thumbnail bool) ApiGetWMVEMetadataRequest {
	r.thumbnail = &thumbnail
	return r
}

func (r ApiGetWMVEMetadataRequest) Execute() (*BTMetadataObjectInfo, *http.Response, error) {
	return r.ApiService.GetWMVEMetadataExecute(r)
}

/*
GetWMVEMetadata Get the metadata for an element.

See [API Guide: Metadata](https://onshape-public.github.io/docs/api-adv/metadata/) for details.
* `linkDocumentId` can be specified where applicable and this combined with the query param `inferMetadataOwner` (default value is `false`) will be used to infer metadata owner.
* `configuration` optional query parameter defaults to default configuration.
* You can specify an optional `depth` query parameter to get multiple levels in an assembly. Default `depth` is `1`.
* `includeComputedProperties` can be used to include or omit computed properties. Default value is `true`.
* `includeComputedAssemblyProperties` can be used to query computed assembly properties which are generally expensive. Default value is `false`.
* You can also choose to include a `thumbnail`. Default value is `false`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiGetWMVEMetadataRequest
*/
func (a *MetadataApiService) GetWMVEMetadata(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetWMVEMetadataRequest {
	return ApiGetWMVEMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTMetadataObjectInfo
func (a *MetadataApiService) GetWMVEMetadataExecute(r ApiGetWMVEMetadataRequest) (*BTMetadataObjectInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTMetadataObjectInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataApiService.GetWMVEMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/d/{did}/{wvm}/{wvmid}/e/{eid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.inferMetadataOwner != nil {
		localVarQueryParams.Add("inferMetadataOwner", parameterToString(*r.inferMetadataOwner, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	if r.includeComputedProperties != nil {
		localVarQueryParams.Add("includeComputedProperties", parameterToString(*r.includeComputedProperties, ""))
	}
	if r.includeComputedAssemblyProperties != nil {
		localVarQueryParams.Add("includeComputedAssemblyProperties", parameterToString(*r.includeComputedAssemblyProperties, ""))
	}
	if r.thumbnail != nil {
		localVarQueryParams.Add("thumbnail", parameterToString(*r.thumbnail, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTMetadataObjectInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWMVEPMetadataRequest struct {
	ctx                               context.Context
	ApiService                        *MetadataApiService
	did                               string
	wvm                               string
	wvmid                             string
	eid                               string
	iden                              string
	pid                               string
	linkDocumentId                    *string
	configuration                     *string
	rollbackBarIndex                  *int32
	elementMicroversionId             *string
	inferMetadataOwner                *bool
	includeComputedProperties         *bool
	includeComputedAssemblyProperties *bool
	thumbnail                         *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetWMVEPMetadataRequest) LinkDocumentId(linkDocumentId string) ApiGetWMVEPMetadataRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;) for the feature definition.
func (r ApiGetWMVEPMetadataRequest) Configuration(configuration string) ApiGetWMVEPMetadataRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiGetWMVEPMetadataRequest) RollbackBarIndex(rollbackBarIndex int32) ApiGetWMVEPMetadataRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

// A specific element microversion in which to evaluate the request.
func (r ApiGetWMVEPMetadataRequest) ElementMicroversionId(elementMicroversionId string) ApiGetWMVEPMetadataRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiGetWMVEPMetadataRequest) InferMetadataOwner(inferMetadataOwner bool) ApiGetWMVEPMetadataRequest {
	r.inferMetadataOwner = &inferMetadataOwner
	return r
}

func (r ApiGetWMVEPMetadataRequest) IncludeComputedProperties(includeComputedProperties bool) ApiGetWMVEPMetadataRequest {
	r.includeComputedProperties = &includeComputedProperties
	return r
}

func (r ApiGetWMVEPMetadataRequest) IncludeComputedAssemblyProperties(includeComputedAssemblyProperties bool) ApiGetWMVEPMetadataRequest {
	r.includeComputedAssemblyProperties = &includeComputedAssemblyProperties
	return r
}

func (r ApiGetWMVEPMetadataRequest) Thumbnail(thumbnail bool) ApiGetWMVEPMetadataRequest {
	r.thumbnail = &thumbnail
	return r
}

func (r ApiGetWMVEPMetadataRequest) Execute() (*BTMetadataObjectInfo, *http.Response, error) {
	return r.ApiService.GetWMVEPMetadataExecute(r)
}

/*
GetWMVEPMetadata Get the metadata for a part.

See [API Guide: Metadata](https://onshape-public.github.io/docs/api-adv/metadata/) for details.
* Specify the part in the `iden` or `pid` path parameter.
* The `configuration` optional query parameter uses the default configuration unless otherwise specified.
* `linkDocumentId` can be specified where applicable. Combined with `inferMetadataOwner` (default value is `false`), this is used to infer metadata owner.
* `includeComputedProperties` can be used to include or omit computed properties. Default value is `true`.
* `includeComputedAssemblyProperties` can be used to query computed assembly properties which are generally expensive. Default value is `false`.
* You can also choose to include a `thumbnail`. Default value is `false`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@param iden Denotes whether the pid specified is a part id (p) or a part identity (pi).
	@param pid
	@return ApiGetWMVEPMetadataRequest
*/
func (a *MetadataApiService) GetWMVEPMetadata(ctx context.Context, did string, wvm string, wvmid string, eid string, iden string, pid string) ApiGetWMVEPMetadataRequest {
	return ApiGetWMVEPMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		iden:       iden,
		pid:        pid,
	}
}

// Execute executes the request
//
//	@return BTMetadataObjectInfo
func (a *MetadataApiService) GetWMVEPMetadataExecute(r ApiGetWMVEPMetadataRequest) (*BTMetadataObjectInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTMetadataObjectInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataApiService.GetWMVEPMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/d/{did}/{wvm}/{wvmid}/e/{eid}/{iden}/{pid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"iden"+"}", url.PathEscape(parameterToString(r.iden, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pid"+"}", url.PathEscape(parameterToString(r.pid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	if r.inferMetadataOwner != nil {
		localVarQueryParams.Add("inferMetadataOwner", parameterToString(*r.inferMetadataOwner, ""))
	}
	if r.includeComputedProperties != nil {
		localVarQueryParams.Add("includeComputedProperties", parameterToString(*r.includeComputedProperties, ""))
	}
	if r.includeComputedAssemblyProperties != nil {
		localVarQueryParams.Add("includeComputedAssemblyProperties", parameterToString(*r.includeComputedAssemblyProperties, ""))
	}
	if r.thumbnail != nil {
		localVarQueryParams.Add("thumbnail", parameterToString(*r.thumbnail, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTMetadataObjectInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWMVEPsMetadataRequest struct {
	ctx                               context.Context
	ApiService                        *MetadataApiService
	did                               string
	wvm                               string
	wvmid                             string
	eid                               string
	linkDocumentId                    *string
	configuration                     *string
	inferMetadataOwner                *bool
	includeComputedProperties         *bool
	includeComputedAssemblyProperties *bool
	thumbnail                         *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetWMVEPsMetadataRequest) LinkDocumentId(linkDocumentId string) ApiGetWMVEPsMetadataRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;) for the feature definition.
func (r ApiGetWMVEPsMetadataRequest) Configuration(configuration string) ApiGetWMVEPsMetadataRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetWMVEPsMetadataRequest) InferMetadataOwner(inferMetadataOwner bool) ApiGetWMVEPsMetadataRequest {
	r.inferMetadataOwner = &inferMetadataOwner
	return r
}

func (r ApiGetWMVEPsMetadataRequest) IncludeComputedProperties(includeComputedProperties bool) ApiGetWMVEPsMetadataRequest {
	r.includeComputedProperties = &includeComputedProperties
	return r
}

func (r ApiGetWMVEPsMetadataRequest) IncludeComputedAssemblyProperties(includeComputedAssemblyProperties bool) ApiGetWMVEPsMetadataRequest {
	r.includeComputedAssemblyProperties = &includeComputedAssemblyProperties
	return r
}

func (r ApiGetWMVEPsMetadataRequest) Thumbnail(thumbnail bool) ApiGetWMVEPsMetadataRequest {
	r.thumbnail = &thumbnail
	return r
}

func (r ApiGetWMVEPsMetadataRequest) Execute() (*BTMetadataObjectListInfoBTMetadataPartInfo, *http.Response, error) {
	return r.ApiService.GetWMVEPsMetadataExecute(r)
}

/*
GetWMVEPsMetadata Get the metadata for all parts in a document.

See [API Guide: Metadata](https://onshape-public.github.io/docs/api-adv/metadata/) for details.
* The `configuration` optional query parameter uses the default configuration unless otherwise specified.
* You can specify an optional `depth` query parameter to get multiple levels in an assembly. Default `depth` is `1`.
* `linkDocumentId` can be specified where applicable. Combined with `inferMetadataOwner` (default value is `false`), this is used to infer metadata owner.
* `includeComputedProperties` can be used to include or omit computed properties. Default value is `true`.
* `includeComputedAssemblyProperties` can be used to query computed assembly properties which are generally expensive. Default value is `false`.
* You can also choose to include a `thumbnail`. Default value is `false`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiGetWMVEPsMetadataRequest
*/
func (a *MetadataApiService) GetWMVEPsMetadata(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetWMVEPsMetadataRequest {
	return ApiGetWMVEPsMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTMetadataObjectListInfoBTMetadataPartInfo
func (a *MetadataApiService) GetWMVEPsMetadataExecute(r ApiGetWMVEPsMetadataRequest) (*BTMetadataObjectListInfoBTMetadataPartInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTMetadataObjectListInfoBTMetadataPartInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataApiService.GetWMVEPsMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/d/{did}/{wvm}/{wvmid}/e/{eid}/p"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.inferMetadataOwner != nil {
		localVarQueryParams.Add("inferMetadataOwner", parameterToString(*r.inferMetadataOwner, ""))
	}
	if r.includeComputedProperties != nil {
		localVarQueryParams.Add("includeComputedProperties", parameterToString(*r.includeComputedProperties, ""))
	}
	if r.includeComputedAssemblyProperties != nil {
		localVarQueryParams.Add("includeComputedAssemblyProperties", parameterToString(*r.includeComputedAssemblyProperties, ""))
	}
	if r.thumbnail != nil {
		localVarQueryParams.Add("thumbnail", parameterToString(*r.thumbnail, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTMetadataObjectListInfoBTMetadataPartInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWMVEsMetadataRequest struct {
	ctx                               context.Context
	ApiService                        *MetadataApiService
	did                               string
	wvm                               string
	wvmid                             string
	linkDocumentId                    *string
	inferMetadataOwner                *bool
	depth                             *string
	includeComputedProperties         *bool
	includeComputedAssemblyProperties *bool
	thumbnail                         *bool
}

func (r ApiGetWMVEsMetadataRequest) LinkDocumentId(linkDocumentId string) ApiGetWMVEsMetadataRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetWMVEsMetadataRequest) InferMetadataOwner(inferMetadataOwner bool) ApiGetWMVEsMetadataRequest {
	r.inferMetadataOwner = &inferMetadataOwner
	return r
}

func (r ApiGetWMVEsMetadataRequest) Depth(depth string) ApiGetWMVEsMetadataRequest {
	r.depth = &depth
	return r
}

func (r ApiGetWMVEsMetadataRequest) IncludeComputedProperties(includeComputedProperties bool) ApiGetWMVEsMetadataRequest {
	r.includeComputedProperties = &includeComputedProperties
	return r
}

func (r ApiGetWMVEsMetadataRequest) IncludeComputedAssemblyProperties(includeComputedAssemblyProperties bool) ApiGetWMVEsMetadataRequest {
	r.includeComputedAssemblyProperties = &includeComputedAssemblyProperties
	return r
}

func (r ApiGetWMVEsMetadataRequest) Thumbnail(thumbnail bool) ApiGetWMVEsMetadataRequest {
	r.thumbnail = &thumbnail
	return r
}

func (r ApiGetWMVEsMetadataRequest) Execute() (*BTMetadataObjectListInfoBTMetadataElementInfo, *http.Response, error) {
	return r.ApiService.GetWMVEsMetadataExecute(r)
}

/*
GetWMVEsMetadata Get the metadata for all elements in a document.

See [API Guide: Metadata](https://onshape-public.github.io/docs/api-adv/metadata/) for details.
* You can specify the optional `depth` query parameter to get multiple levels in an assembly. Default `depth` is `1`.
* `linkDocumentId` can be specified where applicable. Combined with `inferMetadataOwner` (default value is `false`), this is used to infer metadata owner.
* `includeComputedProperties` can be used to include or omit computed properties. Default value is `true`.
* `includeComputedAssemblyProperties` can be used to query computed assembly properties which are generally expensive. Default value is `false`.
* You can also choose to include a `thumbnail`. Default value is `false`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param wvm
	@param wvmid
	@return ApiGetWMVEsMetadataRequest
*/
func (a *MetadataApiService) GetWMVEsMetadata(ctx context.Context, did string, wvm string, wvmid string) ApiGetWMVEsMetadataRequest {
	return ApiGetWMVEsMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
	}
}

// Execute executes the request
//
//	@return BTMetadataObjectListInfoBTMetadataElementInfo
func (a *MetadataApiService) GetWMVEsMetadataExecute(r ApiGetWMVEsMetadataRequest) (*BTMetadataObjectListInfoBTMetadataElementInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTMetadataObjectListInfoBTMetadataElementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataApiService.GetWMVEsMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/d/{did}/{wvm}/{wvmid}/e"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.inferMetadataOwner != nil {
		localVarQueryParams.Add("inferMetadataOwner", parameterToString(*r.inferMetadataOwner, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	if r.includeComputedProperties != nil {
		localVarQueryParams.Add("includeComputedProperties", parameterToString(*r.includeComputedProperties, ""))
	}
	if r.includeComputedAssemblyProperties != nil {
		localVarQueryParams.Add("includeComputedAssemblyProperties", parameterToString(*r.includeComputedAssemblyProperties, ""))
	}
	if r.thumbnail != nil {
		localVarQueryParams.Add("thumbnail", parameterToString(*r.thumbnail, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTMetadataObjectListInfoBTMetadataElementInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWVMetadataRequest struct {
	ctx                               context.Context
	ApiService                        *MetadataApiService
	did                               string
	wv                                string
	wvid                              string
	linkDocumentId                    *string
	inferMetadataOwner                *bool
	depth                             *string
	includeComputedProperties         *bool
	includeComputedAssemblyProperties *bool
	thumbnail                         *bool
}

func (r ApiGetWVMetadataRequest) LinkDocumentId(linkDocumentId string) ApiGetWVMetadataRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetWVMetadataRequest) InferMetadataOwner(inferMetadataOwner bool) ApiGetWVMetadataRequest {
	r.inferMetadataOwner = &inferMetadataOwner
	return r
}

func (r ApiGetWVMetadataRequest) Depth(depth string) ApiGetWVMetadataRequest {
	r.depth = &depth
	return r
}

func (r ApiGetWVMetadataRequest) IncludeComputedProperties(includeComputedProperties bool) ApiGetWVMetadataRequest {
	r.includeComputedProperties = &includeComputedProperties
	return r
}

func (r ApiGetWVMetadataRequest) IncludeComputedAssemblyProperties(includeComputedAssemblyProperties bool) ApiGetWVMetadataRequest {
	r.includeComputedAssemblyProperties = &includeComputedAssemblyProperties
	return r
}

func (r ApiGetWVMetadataRequest) Thumbnail(thumbnail bool) ApiGetWVMetadataRequest {
	r.thumbnail = &thumbnail
	return r
}

func (r ApiGetWVMetadataRequest) Execute() (*BTMetadataObjectInfo, *http.Response, error) {
	return r.ApiService.GetWVMetadataExecute(r)
}

/*
GetWVMetadata Get the metadata for a workspace or version.

See [API Guide: Metadata](https://onshape-public.github.io/docs/api-adv/metadata/) for details.
* `linkDocumentId` can be specified where applicable. Combined with `inferMetadataOwner` (default value is `false`), this is used to infer metadata owner.
* You can specify an optional `depth` query parameter to get multiple levels in an assembly. Default `depth` is `1`.
* `includeComputedProperties` can be used to include or omit computed properties. Default value is `true`.
* `includeComputedAssemblyProperties` can be used to query computed assembly properties which are generally expensive. Default value is `false`.
* You can also choose to include a `thumbnail`. Default value is `false`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param wv
	@param wvid
	@return ApiGetWVMetadataRequest
*/
func (a *MetadataApiService) GetWVMetadata(ctx context.Context, did string, wv string, wvid string) ApiGetWVMetadataRequest {
	return ApiGetWVMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wv:         wv,
		wvid:       wvid,
	}
}

// Execute executes the request
//
//	@return BTMetadataObjectInfo
func (a *MetadataApiService) GetWVMetadataExecute(r ApiGetWVMetadataRequest) (*BTMetadataObjectInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTMetadataObjectInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataApiService.GetWVMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/d/{did}/{wv}/{wvid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wv"+"}", url.PathEscape(parameterToString(r.wv, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvid"+"}", url.PathEscape(parameterToString(r.wvid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.inferMetadataOwner != nil {
		localVarQueryParams.Add("inferMetadataOwner", parameterToString(*r.inferMetadataOwner, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	if r.includeComputedProperties != nil {
		localVarQueryParams.Add("includeComputedProperties", parameterToString(*r.includeComputedProperties, ""))
	}
	if r.includeComputedAssemblyProperties != nil {
		localVarQueryParams.Add("includeComputedAssemblyProperties", parameterToString(*r.includeComputedAssemblyProperties, ""))
	}
	if r.thumbnail != nil {
		localVarQueryParams.Add("thumbnail", parameterToString(*r.thumbnail, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTMetadataObjectInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateVEOPStandardContentPartMetadataRequest struct {
	ctx            context.Context
	ApiService     *MetadataApiService
	did            string
	linkDocumentId *string
	body           *string
}

func (r ApiUpdateVEOPStandardContentPartMetadataRequest) LinkDocumentId(linkDocumentId string) ApiUpdateVEOPStandardContentPartMetadataRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiUpdateVEOPStandardContentPartMetadataRequest) Body(body string) ApiUpdateVEOPStandardContentPartMetadataRequest {
	r.body = &body
	return r
}

func (r ApiUpdateVEOPStandardContentPartMetadataRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateVEOPStandardContentPartMetadataExecute(r)
}

/*
UpdateVEOPStandardContentPartMetadata Update the metadata for a standard content part.

See [API Guide: Metadata](https://onshape-public.github.io/docs/api-adv/metadata/) for details.
* Specify the document ID to update in the `did` path param.
* Specify the document in which you have inserted the standard content part in the `linkDocumentId` query param.
* Specify the property metadata to update in the Request body.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@return ApiUpdateVEOPStandardContentPartMetadataRequest
*/
func (a *MetadataApiService) UpdateVEOPStandardContentPartMetadata(ctx context.Context, did string) ApiUpdateVEOPStandardContentPartMetadataRequest {
	return ApiUpdateVEOPStandardContentPartMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MetadataApiService) UpdateVEOPStandardContentPartMetadataExecute(r ApiUpdateVEOPStandardContentPartMetadataRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataApiService.UpdateVEOPStandardContentPartMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/standardcontent/d/{did}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.linkDocumentId == nil {
		return localVarReturnValue, nil, reportError("linkDocumentId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWVEMetadataRequest struct {
	ctx           context.Context
	ApiService    *MetadataApiService
	did           string
	wvm           string
	wvmid         string
	eid           string
	body          *string
	configuration *string
}

func (r ApiUpdateWVEMetadataRequest) Body(body string) ApiUpdateWVEMetadataRequest {
	r.body = &body
	return r
}

func (r ApiUpdateWVEMetadataRequest) Configuration(configuration string) ApiUpdateWVEMetadataRequest {
	r.configuration = &configuration
	return r
}

func (r ApiUpdateWVEMetadataRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateWVEMetadataExecute(r)
}

/*
UpdateWVEMetadata Update the metadata for an element.

See [API Guide: Metadata](https://onshape-public.github.io/docs/api-adv/metadata/) for details.
* Microversion (`m`) in `wvm` path parameter option is not supported.
* Specify the property metadata to update in the Request body.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param wvm
	@param wvmid
	@param eid
	@return ApiUpdateWVEMetadataRequest
*/
func (a *MetadataApiService) UpdateWVEMetadata(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiUpdateWVEMetadataRequest {
	return ApiUpdateWVEMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MetadataApiService) UpdateWVEMetadataExecute(r ApiUpdateWVEMetadataRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataApiService.UpdateWVEMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/d/{did}/{wvm}/{wvmid}/e/{eid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWVEPMetadataRequest struct {
	ctx                   context.Context
	ApiService            *MetadataApiService
	did                   string
	wvm                   string
	wvmid                 string
	eid                   string
	iden                  string
	pid                   string
	body                  *string
	linkDocumentId        *string
	configuration         *string
	rollbackBarIndex      *int32
	elementMicroversionId *string
}

func (r ApiUpdateWVEPMetadataRequest) Body(body string) ApiUpdateWVEPMetadataRequest {
	r.body = &body
	return r
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiUpdateWVEPMetadataRequest) LinkDocumentId(linkDocumentId string) ApiUpdateWVEPMetadataRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;) for the feature definition.
func (r ApiUpdateWVEPMetadataRequest) Configuration(configuration string) ApiUpdateWVEPMetadataRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiUpdateWVEPMetadataRequest) RollbackBarIndex(rollbackBarIndex int32) ApiUpdateWVEPMetadataRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

// A specific element microversion in which to evaluate the request.
func (r ApiUpdateWVEPMetadataRequest) ElementMicroversionId(elementMicroversionId string) ApiUpdateWVEPMetadataRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiUpdateWVEPMetadataRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateWVEPMetadataExecute(r)
}

/*
UpdateWVEPMetadata Update the metadata for a part.

See [API Guide: Metadata](https://onshape-public.github.io/docs/api-adv/metadata/) for details.
* Specify the part in the `iden` or `pid` path parameter.
* The `configuration` optional query parameter uses the default configuration unless otherwise specified.
* `linkDocumentId` can be specified where applicable. Combined with `inferMetadataOwner` (default value is `false`), this is used to infer metadata owner.
* Specify the property metadata to update in the Request body.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@param iden Denotes whether the pid specified is a part id (p) or a part identity (pi).
	@param pid
	@return ApiUpdateWVEPMetadataRequest
*/
func (a *MetadataApiService) UpdateWVEPMetadata(ctx context.Context, did string, wvm string, wvmid string, eid string, iden string, pid string) ApiUpdateWVEPMetadataRequest {
	return ApiUpdateWVEPMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		iden:       iden,
		pid:        pid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MetadataApiService) UpdateWVEPMetadataExecute(r ApiUpdateWVEPMetadataRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataApiService.UpdateWVEPMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/d/{did}/{wvm}/{wvmid}/e/{eid}/{iden}/{pid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"iden"+"}", url.PathEscape(parameterToString(r.iden, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pid"+"}", url.PathEscape(parameterToString(r.pid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWVMetadataRequest struct {
	ctx        context.Context
	ApiService *MetadataApiService
	did        string
	wv         string
	wvid       string
	body       *string
}

func (r ApiUpdateWVMetadataRequest) Body(body string) ApiUpdateWVMetadataRequest {
	r.body = &body
	return r
}

func (r ApiUpdateWVMetadataRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateWVMetadataExecute(r)
}

/*
UpdateWVMetadata Update the metadata for a workspace or version.

See [API Guide: Metadata](https://onshape-public.github.io/docs/api-adv/metadata/) for details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param wv
	@param wvid
	@return ApiUpdateWVMetadataRequest
*/
func (a *MetadataApiService) UpdateWVMetadata(ctx context.Context, did string, wv string, wvid string) ApiUpdateWVMetadataRequest {
	return ApiUpdateWVMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wv:         wv,
		wvid:       wvid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MetadataApiService) UpdateWVMetadataExecute(r ApiUpdateWVMetadataRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataApiService.UpdateWVMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/d/{did}/{wv}/{wvid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wv"+"}", url.PathEscape(parameterToString(r.wv, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvid"+"}", url.PathEscape(parameterToString(r.wvid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
