/*
Onshape REST API

## Welcome to the Onshape REST API Explorer  To use this API explorer, sign in to your [Onshape](https://cad.onshape.com) account in another tab, then click the **Try it out** button below (it toggles to a **Cancel** button when selected).  See the **[API Explorer Guide](https://onshape-public.github.io/docs/api-intro/explorer/)** for help navigating this API Explorer, including **[authentication](https://onshape-public.github.io/docs/api-intro/explorer/#authentication)**.  **Tip:** To ensure the current session isn't used when trying other authentication techniques, make sure to [remove the Onshape cookie](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site) as per the instructions for your browser. Alternatively, you can use a private or incognito window.  ## See Also  * [Onshape API Guide](https://onshape-public.github.io/docs/): Our full suite of developer guides, to be used as an accompaniment to this API Explorer. * [Onshape Developer Portal](https://dev-portal.onshape.com/): The Onshape portal for managing your API keys, OAuth2 credentials, your Onshape applications, and your Onshape App Store entries. * [Authentication Guide](https://onshape-public.github.io/docs/auth/): Our guide to using API keys, request signatures, and OAuth2 in  your Onshape applications.

Contact: api-support@onshape.zendesk.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package onshape

import (
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// BlobElementApiService BlobElementApi service
type BlobElementApiService service

type ApiCreateBlobTranslationRequest struct {
	ctx                     context.Context
	ApiService              *BlobElementApiService
	did                     string
	wv                      string
	wvid                    string
	eid                     string
	bTTranslateFormatParams *BTTranslateFormatParams
	linkDocumentId          *string
}

func (r ApiCreateBlobTranslationRequest) BTTranslateFormatParams(bTTranslateFormatParams BTTranslateFormatParams) ApiCreateBlobTranslationRequest {
	r.bTTranslateFormatParams = &bTTranslateFormatParams
	return r
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiCreateBlobTranslationRequest) LinkDocumentId(linkDocumentId string) ApiCreateBlobTranslationRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiCreateBlobTranslationRequest) Execute() (*BTTranslationRequestInfo, *http.Response, error) {
	return r.ApiService.CreateBlobTranslationExecute(r)
}

/*
CreateBlobTranslation Export a blob element to another format.

* Use `formatName` in the JSON request body to specify the export file type. Use [Translations/getAllTranslatorFormats](https://cad.onshape.com/glassworks/explorer/#/Translation/getAllTranslatorFormats) to get a list of valid export file formats.
* Set `storeInDocument` to `true` to export to a data file. Set to `false` to export to a blob element in the same document.
* See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/) for more details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wv Indicates which of workspace (w) or version (v) id is specified below.
	@param wvid The id of the workspace, version in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiCreateBlobTranslationRequest
*/
func (a *BlobElementApiService) CreateBlobTranslation(ctx context.Context, did string, wv string, wvid string, eid string) ApiCreateBlobTranslationRequest {
	return ApiCreateBlobTranslationRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wv:         wv,
		wvid:       wvid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTTranslationRequestInfo
func (a *BlobElementApiService) CreateBlobTranslationExecute(r ApiCreateBlobTranslationRequest) (*BTTranslationRequestInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTTranslationRequestInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlobElementApiService.CreateBlobTranslation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blobelements/d/{did}/{wv}/{wvid}/e/{eid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wv"+"}", url.PathEscape(parameterToString(r.wv, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvid"+"}", url.PathEscape(parameterToString(r.wvid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTTranslateFormatParams == nil {
		return localVarReturnValue, nil, reportError("bTTranslateFormatParams is required and must be specified")
	}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTTranslateFormatParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTTranslationRequestInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadFileWorkspaceRequest struct {
	ctx                context.Context
	ApiService         *BlobElementApiService
	did                string
	wid                string
	eid                string
	linkDocumentId     *string
	contentDisposition *string
	ifNoneMatch        *string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiDownloadFileWorkspaceRequest) LinkDocumentId(linkDocumentId string) ApiDownloadFileWorkspaceRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// If \&quot;attachment\&quot;, includes a Content-Disposition return header with the filename.
func (r ApiDownloadFileWorkspaceRequest) ContentDisposition(contentDisposition string) ApiDownloadFileWorkspaceRequest {
	r.contentDisposition = &contentDisposition
	return r
}

// Entity tag; an md5 checksum of the data in double quotes. If the data to download has the same checksum as this entity tag, a 304 &#39;Not Modified&#39; status will be returned. The entity tag is returned in the response headers as ETag.
func (r ApiDownloadFileWorkspaceRequest) IfNoneMatch(ifNoneMatch string) ApiDownloadFileWorkspaceRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r ApiDownloadFileWorkspaceRequest) Execute() (*HttpFile, *http.Response, error) {
	return r.ApiService.DownloadFileWorkspaceExecute(r)
}

/*
DownloadFileWorkspace Download a file from a blob element for the specified workspace/version/microversion.

See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/) for more details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wid The id of the workspace in which to perform the operation.
	@param eid The id of the element in which to perform the operation.
	@return ApiDownloadFileWorkspaceRequest
*/
func (a *BlobElementApiService) DownloadFileWorkspace(ctx context.Context, did string, wid string, eid string) ApiDownloadFileWorkspaceRequest {
	return ApiDownloadFileWorkspaceRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return HttpFile
func (a *BlobElementApiService) DownloadFileWorkspaceExecute(r ApiDownloadFileWorkspaceRequest) (*HttpFile, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *HttpFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlobElementApiService.DownloadFileWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blobelements/d/{did}/w/{wid}/e/{eid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.contentDisposition != nil {
		localVarQueryParams.Add("contentDisposition", parameterToString(*r.contentDisposition, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v HttpFile
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUnitsRequest struct {
	ctx                     context.Context
	ApiService              *BlobElementApiService
	did                     string
	wid                     string
	eid                     string
	bTUpdateMeshUnitsParams *BTUpdateMeshUnitsParams
	linkDocumentId          *string
}

func (r ApiUpdateUnitsRequest) BTUpdateMeshUnitsParams(bTUpdateMeshUnitsParams BTUpdateMeshUnitsParams) ApiUpdateUnitsRequest {
	r.bTUpdateMeshUnitsParams = &bTUpdateMeshUnitsParams
	return r
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiUpdateUnitsRequest) LinkDocumentId(linkDocumentId string) ApiUpdateUnitsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiUpdateUnitsRequest) Execute() (*BTDocumentElementProcessingInfo, *http.Response, error) {
	return r.ApiService.UpdateUnitsExecute(r)
}

/*
UpdateUnits Change the measurement units for the blob element.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wid The id of the workspace in which to perform the operation.
	@param eid The id of the element in which to perform the operation.
	@return ApiUpdateUnitsRequest
*/
func (a *BlobElementApiService) UpdateUnits(ctx context.Context, did string, wid string, eid string) ApiUpdateUnitsRequest {
	return ApiUpdateUnitsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTDocumentElementProcessingInfo
func (a *BlobElementApiService) UpdateUnitsExecute(r ApiUpdateUnitsRequest) (*BTDocumentElementProcessingInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTDocumentElementProcessingInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlobElementApiService.UpdateUnits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blobelements/d/{did}/w/{wid}/e/{eid}/units"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTUpdateMeshUnitsParams == nil {
		return localVarReturnValue, nil, reportError("bTUpdateMeshUnitsParams is required and must be specified")
	}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTUpdateMeshUnitsParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTDocumentElementProcessingInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadFileCreateElementRequest struct {
	ctx                                  context.Context
	ApiService                           *BlobElementApiService
	did                                  string
	wid                                  string
	linkDocumentId                       *string
	file                                 *map[string]interface{}
	allowFaultyParts                     *bool
	createComposite                      *bool
	createDrawingIfPossible              *bool
	encodedFilename                      *string
	extractAssemblyHierarchy             *bool
	flattenAssemblies                    *bool
	formatName                           *string
	joinAdjacentSurfaces                 *bool
	locationElementId                    *string
	locationGroupId                      *string
	locationPosition                     *int32
	notifyUser                           *bool
	ownerId                              *string
	parentId                             *string
	projectId                            *string
	public                               *bool
	onePartPerDoc                        *bool
	splitAssembliesIntoMultipleDocuments *bool
	storeInDocument                      *bool
	translate                            *bool
	unit                                 *string
	uploadId                             *string
	versionString                        *string
	importAppearances                    *bool
	importMaterialDensity                *bool
	yAxisIsUp                            *bool
	importWithinDocument                 *bool
	useIGESImportPostProcessing          *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiUploadFileCreateElementRequest) LinkDocumentId(linkDocumentId string) ApiUploadFileCreateElementRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// The file to upload.
func (r ApiUploadFileCreateElementRequest) File(file map[string]interface{}) ApiUploadFileCreateElementRequest {
	r.file = &file
	return r
}

// If true, and a part doesn&#39;t pass Onshape validation, it will be imported with faults.
func (r ApiUploadFileCreateElementRequest) AllowFaultyParts(allowFaultyParts bool) ApiUploadFileCreateElementRequest {
	r.allowFaultyParts = &allowFaultyParts
	return r
}

// Not supported for importing into a single part studio.
func (r ApiUploadFileCreateElementRequest) CreateComposite(createComposite bool) ApiUploadFileCreateElementRequest {
	r.createComposite = &createComposite
	return r
}

func (r ApiUploadFileCreateElementRequest) CreateDrawingIfPossible(createDrawingIfPossible bool) ApiUploadFileCreateElementRequest {
	r.createDrawingIfPossible = &createDrawingIfPossible
	return r
}

// If the filename contains non-ASCII characters. Use this field to store the filename.
func (r ApiUploadFileCreateElementRequest) EncodedFilename(encodedFilename string) ApiUploadFileCreateElementRequest {
	r.encodedFilename = &encodedFilename
	return r
}

func (r ApiUploadFileCreateElementRequest) ExtractAssemblyHierarchy(extractAssemblyHierarchy bool) ApiUploadFileCreateElementRequest {
	r.extractAssemblyHierarchy = &extractAssemblyHierarchy
	return r
}

// If the file is an assembly, or contains an assembly, setting this to True will import it as a Part Studio. In this case the assembly will be flattened to a set of parts in a Part Studio. There will be duplicate parts created whenever a part is instanced more than once. If False, it will be imported as an Assembly.
func (r ApiUploadFileCreateElementRequest) FlattenAssemblies(flattenAssemblies bool) ApiUploadFileCreateElementRequest {
	r.flattenAssemblies = &flattenAssemblies
	return r
}

func (r ApiUploadFileCreateElementRequest) FormatName(formatName string) ApiUploadFileCreateElementRequest {
	r.formatName = &formatName
	return r
}

func (r ApiUploadFileCreateElementRequest) JoinAdjacentSurfaces(joinAdjacentSurfaces bool) ApiUploadFileCreateElementRequest {
	r.joinAdjacentSurfaces = &joinAdjacentSurfaces
	return r
}

func (r ApiUploadFileCreateElementRequest) LocationElementId(locationElementId string) ApiUploadFileCreateElementRequest {
	r.locationElementId = &locationElementId
	return r
}

func (r ApiUploadFileCreateElementRequest) LocationGroupId(locationGroupId string) ApiUploadFileCreateElementRequest {
	r.locationGroupId = &locationGroupId
	return r
}

func (r ApiUploadFileCreateElementRequest) LocationPosition(locationPosition int32) ApiUploadFileCreateElementRequest {
	r.locationPosition = &locationPosition
	return r
}

func (r ApiUploadFileCreateElementRequest) NotifyUser(notifyUser bool) ApiUploadFileCreateElementRequest {
	r.notifyUser = &notifyUser
	return r
}

func (r ApiUploadFileCreateElementRequest) OwnerId(ownerId string) ApiUploadFileCreateElementRequest {
	r.ownerId = &ownerId
	return r
}

func (r ApiUploadFileCreateElementRequest) ParentId(parentId string) ApiUploadFileCreateElementRequest {
	r.parentId = &parentId
	return r
}

func (r ApiUploadFileCreateElementRequest) ProjectId(projectId string) ApiUploadFileCreateElementRequest {
	r.projectId = &projectId
	return r
}

func (r ApiUploadFileCreateElementRequest) Public(public bool) ApiUploadFileCreateElementRequest {
	r.public = &public
	return r
}

func (r ApiUploadFileCreateElementRequest) OnePartPerDoc(onePartPerDoc bool) ApiUploadFileCreateElementRequest {
	r.onePartPerDoc = &onePartPerDoc
	return r
}

func (r ApiUploadFileCreateElementRequest) SplitAssembliesIntoMultipleDocuments(splitAssembliesIntoMultipleDocuments bool) ApiUploadFileCreateElementRequest {
	r.splitAssembliesIntoMultipleDocuments = &splitAssembliesIntoMultipleDocuments
	return r
}

func (r ApiUploadFileCreateElementRequest) StoreInDocument(storeInDocument bool) ApiUploadFileCreateElementRequest {
	r.storeInDocument = &storeInDocument
	return r
}

func (r ApiUploadFileCreateElementRequest) Translate(translate bool) ApiUploadFileCreateElementRequest {
	r.translate = &translate
	return r
}

func (r ApiUploadFileCreateElementRequest) Unit(unit string) ApiUploadFileCreateElementRequest {
	r.unit = &unit
	return r
}

func (r ApiUploadFileCreateElementRequest) UploadId(uploadId string) ApiUploadFileCreateElementRequest {
	r.uploadId = &uploadId
	return r
}

func (r ApiUploadFileCreateElementRequest) VersionString(versionString string) ApiUploadFileCreateElementRequest {
	r.versionString = &versionString
	return r
}

// Face appearances defined on models will be imported.
func (r ApiUploadFileCreateElementRequest) ImportAppearances(importAppearances bool) ApiUploadFileCreateElementRequest {
	r.importAppearances = &importAppearances
	return r
}

// Material density defined on models will be imported.
func (r ApiUploadFileCreateElementRequest) ImportMaterialDensity(importMaterialDensity bool) ApiUploadFileCreateElementRequest {
	r.importMaterialDensity = &importMaterialDensity
	return r
}

// If the file was created in a system that orients with Y Axis Up, the models would by default be brought into Onshape (a Z Axis Up system) with a flipped coordinate system. Toggle this value to reorient the axis system to match Onshape and display the model with the coordinates you expect.
func (r ApiUploadFileCreateElementRequest) YAxisIsUp(yAxisIsUp bool) ApiUploadFileCreateElementRequest {
	r.yAxisIsUp = &yAxisIsUp
	return r
}

func (r ApiUploadFileCreateElementRequest) ImportWithinDocument(importWithinDocument bool) ApiUploadFileCreateElementRequest {
	r.importWithinDocument = &importWithinDocument
	return r
}

// Try getting optimized topology from IGES model.
func (r ApiUploadFileCreateElementRequest) UseIGESImportPostProcessing(useIGESImportPostProcessing bool) ApiUploadFileCreateElementRequest {
	r.useIGESImportPostProcessing = &useIGESImportPostProcessing
	return r
}

func (r ApiUploadFileCreateElementRequest) Execute() (*BTDocumentElementProcessingInfo, *http.Response, error) {
	return r.ApiService.UploadFileCreateElementExecute(r)
}

/*
UploadFileCreateElement Upload a file and create a blob element from it.

Request body parameters are multipart fields, so you must use `"Content-Type":"multipart/form-data"` in the request header.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wid The id of the workspace in which to perform the operation.
	@return ApiUploadFileCreateElementRequest
*/
func (a *BlobElementApiService) UploadFileCreateElement(ctx context.Context, did string, wid string) ApiUploadFileCreateElementRequest {
	return ApiUploadFileCreateElementRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
	}
}

// Execute executes the request
//
//	@return BTDocumentElementProcessingInfo
func (a *BlobElementApiService) UploadFileCreateElementExecute(r ApiUploadFileCreateElementRequest) (*BTDocumentElementProcessingInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTDocumentElementProcessingInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlobElementApiService.UploadFileCreateElement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blobelements/d/{did}/w/{wid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.file != nil {
		localVarFormParams.Add("file", parameterToString(*r.file, ""))
	}
	if r.allowFaultyParts != nil {
		localVarFormParams.Add("allowFaultyParts", parameterToString(*r.allowFaultyParts, ""))
	}
	if r.createComposite != nil {
		localVarFormParams.Add("createComposite", parameterToString(*r.createComposite, ""))
	}
	if r.createDrawingIfPossible != nil {
		localVarFormParams.Add("createDrawingIfPossible", parameterToString(*r.createDrawingIfPossible, ""))
	}
	if r.encodedFilename != nil {
		localVarFormParams.Add("encodedFilename", parameterToString(*r.encodedFilename, ""))
	}
	if r.extractAssemblyHierarchy != nil {
		localVarFormParams.Add("extractAssemblyHierarchy", parameterToString(*r.extractAssemblyHierarchy, ""))
	}
	if r.flattenAssemblies != nil {
		localVarFormParams.Add("flattenAssemblies", parameterToString(*r.flattenAssemblies, ""))
	}
	if r.formatName != nil {
		localVarFormParams.Add("formatName", parameterToString(*r.formatName, ""))
	}
	if r.joinAdjacentSurfaces != nil {
		localVarFormParams.Add("joinAdjacentSurfaces", parameterToString(*r.joinAdjacentSurfaces, ""))
	}
	if r.locationElementId != nil {
		localVarFormParams.Add("locationElementId", parameterToString(*r.locationElementId, ""))
	}
	if r.locationGroupId != nil {
		localVarFormParams.Add("locationGroupId", parameterToString(*r.locationGroupId, ""))
	}
	if r.locationPosition != nil {
		localVarFormParams.Add("locationPosition", parameterToString(*r.locationPosition, ""))
	}
	if r.notifyUser != nil {
		localVarFormParams.Add("notifyUser", parameterToString(*r.notifyUser, ""))
	}
	if r.ownerId != nil {
		localVarFormParams.Add("ownerId", parameterToString(*r.ownerId, ""))
	}
	if r.parentId != nil {
		localVarFormParams.Add("parentId", parameterToString(*r.parentId, ""))
	}
	if r.projectId != nil {
		localVarFormParams.Add("projectId", parameterToString(*r.projectId, ""))
	}
	if r.public != nil {
		localVarFormParams.Add("public", parameterToString(*r.public, ""))
	}
	if r.onePartPerDoc != nil {
		localVarFormParams.Add("onePartPerDoc", parameterToString(*r.onePartPerDoc, ""))
	}
	if r.splitAssembliesIntoMultipleDocuments != nil {
		localVarFormParams.Add("splitAssembliesIntoMultipleDocuments", parameterToString(*r.splitAssembliesIntoMultipleDocuments, ""))
	}
	if r.storeInDocument != nil {
		localVarFormParams.Add("storeInDocument", parameterToString(*r.storeInDocument, ""))
	}
	if r.translate != nil {
		localVarFormParams.Add("translate", parameterToString(*r.translate, ""))
	}
	if r.unit != nil {
		localVarFormParams.Add("unit", parameterToString(*r.unit, ""))
	}
	if r.uploadId != nil {
		localVarFormParams.Add("uploadId", parameterToString(*r.uploadId, ""))
	}
	if r.versionString != nil {
		localVarFormParams.Add("versionString", parameterToString(*r.versionString, ""))
	}
	if r.importAppearances != nil {
		localVarFormParams.Add("importAppearances", parameterToString(*r.importAppearances, ""))
	}
	if r.importMaterialDensity != nil {
		localVarFormParams.Add("importMaterialDensity", parameterToString(*r.importMaterialDensity, ""))
	}
	if r.yAxisIsUp != nil {
		localVarFormParams.Add("yAxisIsUp", parameterToString(*r.yAxisIsUp, ""))
	}
	if r.importWithinDocument != nil {
		localVarFormParams.Add("importWithinDocument", parameterToString(*r.importWithinDocument, ""))
	}
	if r.useIGESImportPostProcessing != nil {
		localVarFormParams.Add("useIGESImportPostProcessing", parameterToString(*r.useIGESImportPostProcessing, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTDocumentElementProcessingInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadFileUpdateElementRequest struct {
	ctx                                  context.Context
	ApiService                           *BlobElementApiService
	did                                  string
	wid                                  string
	eid                                  string
	linkDocumentId                       *string
	parentChangeId                       *string
	file                                 *map[string]interface{}
	allowFaultyParts                     *bool
	createComposite                      *bool
	createDrawingIfPossible              *bool
	encodedFilename                      *string
	extractAssemblyHierarchy             *bool
	flattenAssemblies                    *bool
	formatName                           *string
	joinAdjacentSurfaces                 *bool
	locationElementId                    *string
	locationGroupId                      *string
	locationPosition                     *int32
	notifyUser                           *bool
	ownerId                              *string
	parentId                             *string
	projectId                            *string
	public                               *bool
	onePartPerDoc                        *bool
	splitAssembliesIntoMultipleDocuments *bool
	storeInDocument                      *bool
	translate                            *bool
	unit                                 *string
	uploadId                             *string
	versionString                        *string
	importAppearances                    *bool
	importMaterialDensity                *bool
	yAxisIsUp                            *bool
	importWithinDocument                 *bool
	useIGESImportPostProcessing          *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiUploadFileUpdateElementRequest) LinkDocumentId(linkDocumentId string) ApiUploadFileUpdateElementRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// The id of the last change made to this application element. This can be retrieved from the response for any app element modification endpoint.
func (r ApiUploadFileUpdateElementRequest) ParentChangeId(parentChangeId string) ApiUploadFileUpdateElementRequest {
	r.parentChangeId = &parentChangeId
	return r
}

// The file to upload.
func (r ApiUploadFileUpdateElementRequest) File(file map[string]interface{}) ApiUploadFileUpdateElementRequest {
	r.file = &file
	return r
}

// If true, and a part doesn&#39;t pass Onshape validation, it will be imported with faults.
func (r ApiUploadFileUpdateElementRequest) AllowFaultyParts(allowFaultyParts bool) ApiUploadFileUpdateElementRequest {
	r.allowFaultyParts = &allowFaultyParts
	return r
}

// Not supported for importing into a single part studio.
func (r ApiUploadFileUpdateElementRequest) CreateComposite(createComposite bool) ApiUploadFileUpdateElementRequest {
	r.createComposite = &createComposite
	return r
}

func (r ApiUploadFileUpdateElementRequest) CreateDrawingIfPossible(createDrawingIfPossible bool) ApiUploadFileUpdateElementRequest {
	r.createDrawingIfPossible = &createDrawingIfPossible
	return r
}

// If the filename contains non-ASCII characters. Use this field to store the filename.
func (r ApiUploadFileUpdateElementRequest) EncodedFilename(encodedFilename string) ApiUploadFileUpdateElementRequest {
	r.encodedFilename = &encodedFilename
	return r
}

func (r ApiUploadFileUpdateElementRequest) ExtractAssemblyHierarchy(extractAssemblyHierarchy bool) ApiUploadFileUpdateElementRequest {
	r.extractAssemblyHierarchy = &extractAssemblyHierarchy
	return r
}

// If the file is an assembly, or contains an assembly, setting this to True will import it as a Part Studio. In this case the assembly will be flattened to a set of parts in a Part Studio. There will be duplicate parts created whenever a part is instanced more than once. If False, it will be imported as an Assembly.
func (r ApiUploadFileUpdateElementRequest) FlattenAssemblies(flattenAssemblies bool) ApiUploadFileUpdateElementRequest {
	r.flattenAssemblies = &flattenAssemblies
	return r
}

func (r ApiUploadFileUpdateElementRequest) FormatName(formatName string) ApiUploadFileUpdateElementRequest {
	r.formatName = &formatName
	return r
}

func (r ApiUploadFileUpdateElementRequest) JoinAdjacentSurfaces(joinAdjacentSurfaces bool) ApiUploadFileUpdateElementRequest {
	r.joinAdjacentSurfaces = &joinAdjacentSurfaces
	return r
}

func (r ApiUploadFileUpdateElementRequest) LocationElementId(locationElementId string) ApiUploadFileUpdateElementRequest {
	r.locationElementId = &locationElementId
	return r
}

func (r ApiUploadFileUpdateElementRequest) LocationGroupId(locationGroupId string) ApiUploadFileUpdateElementRequest {
	r.locationGroupId = &locationGroupId
	return r
}

func (r ApiUploadFileUpdateElementRequest) LocationPosition(locationPosition int32) ApiUploadFileUpdateElementRequest {
	r.locationPosition = &locationPosition
	return r
}

func (r ApiUploadFileUpdateElementRequest) NotifyUser(notifyUser bool) ApiUploadFileUpdateElementRequest {
	r.notifyUser = &notifyUser
	return r
}

func (r ApiUploadFileUpdateElementRequest) OwnerId(ownerId string) ApiUploadFileUpdateElementRequest {
	r.ownerId = &ownerId
	return r
}

func (r ApiUploadFileUpdateElementRequest) ParentId(parentId string) ApiUploadFileUpdateElementRequest {
	r.parentId = &parentId
	return r
}

func (r ApiUploadFileUpdateElementRequest) ProjectId(projectId string) ApiUploadFileUpdateElementRequest {
	r.projectId = &projectId
	return r
}

func (r ApiUploadFileUpdateElementRequest) Public(public bool) ApiUploadFileUpdateElementRequest {
	r.public = &public
	return r
}

func (r ApiUploadFileUpdateElementRequest) OnePartPerDoc(onePartPerDoc bool) ApiUploadFileUpdateElementRequest {
	r.onePartPerDoc = &onePartPerDoc
	return r
}

func (r ApiUploadFileUpdateElementRequest) SplitAssembliesIntoMultipleDocuments(splitAssembliesIntoMultipleDocuments bool) ApiUploadFileUpdateElementRequest {
	r.splitAssembliesIntoMultipleDocuments = &splitAssembliesIntoMultipleDocuments
	return r
}

func (r ApiUploadFileUpdateElementRequest) StoreInDocument(storeInDocument bool) ApiUploadFileUpdateElementRequest {
	r.storeInDocument = &storeInDocument
	return r
}

func (r ApiUploadFileUpdateElementRequest) Translate(translate bool) ApiUploadFileUpdateElementRequest {
	r.translate = &translate
	return r
}

func (r ApiUploadFileUpdateElementRequest) Unit(unit string) ApiUploadFileUpdateElementRequest {
	r.unit = &unit
	return r
}

func (r ApiUploadFileUpdateElementRequest) UploadId(uploadId string) ApiUploadFileUpdateElementRequest {
	r.uploadId = &uploadId
	return r
}

func (r ApiUploadFileUpdateElementRequest) VersionString(versionString string) ApiUploadFileUpdateElementRequest {
	r.versionString = &versionString
	return r
}

// Face appearances defined on models will be imported.
func (r ApiUploadFileUpdateElementRequest) ImportAppearances(importAppearances bool) ApiUploadFileUpdateElementRequest {
	r.importAppearances = &importAppearances
	return r
}

// Material density defined on models will be imported.
func (r ApiUploadFileUpdateElementRequest) ImportMaterialDensity(importMaterialDensity bool) ApiUploadFileUpdateElementRequest {
	r.importMaterialDensity = &importMaterialDensity
	return r
}

// If the file was created in a system that orients with Y Axis Up, the models would by default be brought into Onshape (a Z Axis Up system) with a flipped coordinate system. Toggle this value to reorient the axis system to match Onshape and display the model with the coordinates you expect.
func (r ApiUploadFileUpdateElementRequest) YAxisIsUp(yAxisIsUp bool) ApiUploadFileUpdateElementRequest {
	r.yAxisIsUp = &yAxisIsUp
	return r
}

func (r ApiUploadFileUpdateElementRequest) ImportWithinDocument(importWithinDocument bool) ApiUploadFileUpdateElementRequest {
	r.importWithinDocument = &importWithinDocument
	return r
}

// Try getting optimized topology from IGES model.
func (r ApiUploadFileUpdateElementRequest) UseIGESImportPostProcessing(useIGESImportPostProcessing bool) ApiUploadFileUpdateElementRequest {
	r.useIGESImportPostProcessing = &useIGESImportPostProcessing
	return r
}

func (r ApiUploadFileUpdateElementRequest) Execute() (*BTDocumentElementProcessingInfo, *http.Response, error) {
	return r.ApiService.UploadFileUpdateElementExecute(r)
}

/*
UploadFileUpdateElement Update a blob element by uploading a file.

Request body parameters are multipart fields, so you must use `"Content-Type":"multipart/form-data"` in the request header.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wid The id of the workspace in which to perform the operation.
	@param eid The id of the element in which to perform the operation.
	@return ApiUploadFileUpdateElementRequest
*/
func (a *BlobElementApiService) UploadFileUpdateElement(ctx context.Context, did string, wid string, eid string) ApiUploadFileUpdateElementRequest {
	return ApiUploadFileUpdateElementRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTDocumentElementProcessingInfo
func (a *BlobElementApiService) UploadFileUpdateElementExecute(r ApiUploadFileUpdateElementRequest) (*BTDocumentElementProcessingInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTDocumentElementProcessingInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlobElementApiService.UploadFileUpdateElement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blobelements/d/{did}/w/{wid}/e/{eid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.parentChangeId != nil {
		localVarQueryParams.Add("parentChangeId", parameterToString(*r.parentChangeId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.file != nil {
		localVarFormParams.Add("file", parameterToString(*r.file, ""))
	}
	if r.allowFaultyParts != nil {
		localVarFormParams.Add("allowFaultyParts", parameterToString(*r.allowFaultyParts, ""))
	}
	if r.createComposite != nil {
		localVarFormParams.Add("createComposite", parameterToString(*r.createComposite, ""))
	}
	if r.createDrawingIfPossible != nil {
		localVarFormParams.Add("createDrawingIfPossible", parameterToString(*r.createDrawingIfPossible, ""))
	}
	if r.encodedFilename != nil {
		localVarFormParams.Add("encodedFilename", parameterToString(*r.encodedFilename, ""))
	}
	if r.extractAssemblyHierarchy != nil {
		localVarFormParams.Add("extractAssemblyHierarchy", parameterToString(*r.extractAssemblyHierarchy, ""))
	}
	if r.flattenAssemblies != nil {
		localVarFormParams.Add("flattenAssemblies", parameterToString(*r.flattenAssemblies, ""))
	}
	if r.formatName != nil {
		localVarFormParams.Add("formatName", parameterToString(*r.formatName, ""))
	}
	if r.joinAdjacentSurfaces != nil {
		localVarFormParams.Add("joinAdjacentSurfaces", parameterToString(*r.joinAdjacentSurfaces, ""))
	}
	if r.locationElementId != nil {
		localVarFormParams.Add("locationElementId", parameterToString(*r.locationElementId, ""))
	}
	if r.locationGroupId != nil {
		localVarFormParams.Add("locationGroupId", parameterToString(*r.locationGroupId, ""))
	}
	if r.locationPosition != nil {
		localVarFormParams.Add("locationPosition", parameterToString(*r.locationPosition, ""))
	}
	if r.notifyUser != nil {
		localVarFormParams.Add("notifyUser", parameterToString(*r.notifyUser, ""))
	}
	if r.ownerId != nil {
		localVarFormParams.Add("ownerId", parameterToString(*r.ownerId, ""))
	}
	if r.parentId != nil {
		localVarFormParams.Add("parentId", parameterToString(*r.parentId, ""))
	}
	if r.projectId != nil {
		localVarFormParams.Add("projectId", parameterToString(*r.projectId, ""))
	}
	if r.public != nil {
		localVarFormParams.Add("public", parameterToString(*r.public, ""))
	}
	if r.onePartPerDoc != nil {
		localVarFormParams.Add("onePartPerDoc", parameterToString(*r.onePartPerDoc, ""))
	}
	if r.splitAssembliesIntoMultipleDocuments != nil {
		localVarFormParams.Add("splitAssembliesIntoMultipleDocuments", parameterToString(*r.splitAssembliesIntoMultipleDocuments, ""))
	}
	if r.storeInDocument != nil {
		localVarFormParams.Add("storeInDocument", parameterToString(*r.storeInDocument, ""))
	}
	if r.translate != nil {
		localVarFormParams.Add("translate", parameterToString(*r.translate, ""))
	}
	if r.unit != nil {
		localVarFormParams.Add("unit", parameterToString(*r.unit, ""))
	}
	if r.uploadId != nil {
		localVarFormParams.Add("uploadId", parameterToString(*r.uploadId, ""))
	}
	if r.versionString != nil {
		localVarFormParams.Add("versionString", parameterToString(*r.versionString, ""))
	}
	if r.importAppearances != nil {
		localVarFormParams.Add("importAppearances", parameterToString(*r.importAppearances, ""))
	}
	if r.importMaterialDensity != nil {
		localVarFormParams.Add("importMaterialDensity", parameterToString(*r.importMaterialDensity, ""))
	}
	if r.yAxisIsUp != nil {
		localVarFormParams.Add("yAxisIsUp", parameterToString(*r.yAxisIsUp, ""))
	}
	if r.importWithinDocument != nil {
		localVarFormParams.Add("importWithinDocument", parameterToString(*r.importWithinDocument, ""))
	}
	if r.useIGESImportPostProcessing != nil {
		localVarFormParams.Add("useIGESImportPostProcessing", parameterToString(*r.useIGESImportPostProcessing, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTDocumentElementProcessingInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
