/*
Onshape REST API

The Onshape REST API consumed by all client. # Authorization The simplest way to authorize and enable the **Try it out** functionality is to sign in to Onshape and use the current session. The **Authorize** button enables other authorization techniques. To ensure the current session isn't used when trying other authentication techniques, make sure to remove the Onshape cookie as per the instructions for your particular browser. Alternatively, a private or incognito window may be used. Here's [how to remove a specific cookie on Chrome](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site). - **Current Session** authorization is enabled by default if the browser is already signed in to [Onshape](/). - **OAuth2** authorization uses an Onshape OAuth2 app created on the [Onshape Developer Portal](https://dev-portal.onshape.com/oauthApps). The redirect URL field should include `https://cad.onshape.com/glassworks/explorer/oauth2-redirect.html`. - **API Key** authorization using basic authentication is also available. The keys can be generated in the [Onshape Developer Portal](https://dev-portal.onshape.com/keys). In the authentication dialog, enter the access key in the `Username` field, and enter the secret key in the `Password` field. Basic authentication should only be used during the development process since sharing API Keys provides the same level of access as a username and password.

API version: 1.152.5998-d3227e94fd7e
Contact: api-support@onshape.zendesk.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package onshape

import (
	"context"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// BlobElementApiService BlobElementApi service
type BlobElementApiService service

type ApiCreateBlobTranslationRequest struct {
	ctx                     context.Context
	ApiService              *BlobElementApiService
	did                     string
	wv                      string
	wvid                    string
	eid                     string
	bTTranslateFormatParams *BTTranslateFormatParams
}

func (r ApiCreateBlobTranslationRequest) BTTranslateFormatParams(bTTranslateFormatParams BTTranslateFormatParams) ApiCreateBlobTranslationRequest {
	r.bTTranslateFormatParams = &bTTranslateFormatParams
	return r
}

func (r ApiCreateBlobTranslationRequest) Execute() (*BTTranslationRequestInfo, *http.Response, error) {
	return r.ApiService.CreateBlobTranslationExecute(r)
}

/*
CreateBlobTranslation Create translation (export) of blob element (document tab) by document id, workspace or version ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wv
 @param wvid
 @param eid
 @return ApiCreateBlobTranslationRequest
*/
func (a *BlobElementApiService) CreateBlobTranslation(ctx context.Context, did string, wv string, wvid string, eid string) ApiCreateBlobTranslationRequest {
	return ApiCreateBlobTranslationRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wv:         wv,
		wvid:       wvid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTTranslationRequestInfo
func (a *BlobElementApiService) CreateBlobTranslationExecute(r ApiCreateBlobTranslationRequest) (*BTTranslationRequestInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTTranslationRequestInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlobElementApiService.CreateBlobTranslation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blobelements/d/{did}/{wv}/{wvid}/e/{eid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wv"+"}", url.PathEscape(parameterToString(r.wv, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvid"+"}", url.PathEscape(parameterToString(r.wvid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTTranslateFormatParams == nil {
		return localVarReturnValue, nil, reportError("bTTranslateFormatParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTTranslateFormatParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTTranslationRequestInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadFileWorkspaceRequest struct {
	ctx                context.Context
	ApiService         *BlobElementApiService
	did                string
	wid                string
	eid                string
	contentDisposition *string
	ifNoneMatch        *string
	linkDocumentId     *string
}

func (r ApiDownloadFileWorkspaceRequest) ContentDisposition(contentDisposition string) ApiDownloadFileWorkspaceRequest {
	r.contentDisposition = &contentDisposition
	return r
}

func (r ApiDownloadFileWorkspaceRequest) IfNoneMatch(ifNoneMatch string) ApiDownloadFileWorkspaceRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r ApiDownloadFileWorkspaceRequest) LinkDocumentId(linkDocumentId string) ApiDownloadFileWorkspaceRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiDownloadFileWorkspaceRequest) Execute() (*HttpFile, *http.Response, error) {
	return r.ApiService.DownloadFileWorkspaceExecute(r)
}

/*
DownloadFileWorkspace Method for DownloadFileWorkspace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wid
 @param eid
 @return ApiDownloadFileWorkspaceRequest
*/
func (a *BlobElementApiService) DownloadFileWorkspace(ctx context.Context, did string, wid string, eid string) ApiDownloadFileWorkspaceRequest {
	return ApiDownloadFileWorkspaceRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return HttpFile
func (a *BlobElementApiService) DownloadFileWorkspaceExecute(r ApiDownloadFileWorkspaceRequest) (*HttpFile, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *HttpFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlobElementApiService.DownloadFileWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blobelements/d/{did}/w/{wid}/e/{eid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contentDisposition != nil {
		localVarQueryParams.Add("contentDisposition", parameterToString(*r.contentDisposition, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v HttpFile
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUnitsRequest struct {
	ctx                     context.Context
	ApiService              *BlobElementApiService
	did                     string
	eid                     string
	wid                     string
	bTUpdateMeshUnitsParams *BTUpdateMeshUnitsParams
}

func (r ApiUpdateUnitsRequest) BTUpdateMeshUnitsParams(bTUpdateMeshUnitsParams BTUpdateMeshUnitsParams) ApiUpdateUnitsRequest {
	r.bTUpdateMeshUnitsParams = &bTUpdateMeshUnitsParams
	return r
}

func (r ApiUpdateUnitsRequest) Execute() (*BTDocumentElementProcessingInfo, *http.Response, error) {
	return r.ApiService.UpdateUnitsExecute(r)
}

/*
UpdateUnits Update mesh units of a previously imported STL or OBJ file by document ID, workspace ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param eid
 @param wid
 @return ApiUpdateUnitsRequest
*/
func (a *BlobElementApiService) UpdateUnits(ctx context.Context, did string, eid string, wid string) ApiUpdateUnitsRequest {
	return ApiUpdateUnitsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wid:        wid,
	}
}

// Execute executes the request
//  @return BTDocumentElementProcessingInfo
func (a *BlobElementApiService) UpdateUnitsExecute(r ApiUpdateUnitsRequest) (*BTDocumentElementProcessingInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTDocumentElementProcessingInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlobElementApiService.UpdateUnits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blobelements/d/{did}/w/{wid}/e/{eid}/units"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTUpdateMeshUnitsParams == nil {
		return localVarReturnValue, nil, reportError("bTUpdateMeshUnitsParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTUpdateMeshUnitsParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTDocumentElementProcessingInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadFileCreateElementRequest struct {
	ctx                                  context.Context
	ApiService                           *BlobElementApiService
	did                                  string
	wid                                  string
	file                                 *map[string]interface{}
	allowFaultyParts                     *bool
	createComposite                      *bool
	createDrawingIfPossible              *bool
	encodedFilename                      *string
	extractAssemblyHierarchy             *bool
	flattenAssemblies                    *bool
	formatName                           *string
	joinAdjacentSurfaces                 *bool
	locationElementId                    *string
	locationGroupId                      *string
	locationPosition                     *int32
	notifyUser                           *bool
	ownerId                              *string
	parentId                             *string
	projectId                            *string
	public                               *bool
	onePartPerDoc                        *bool
	splitAssembliesIntoMultipleDocuments *bool
	storeInDocument                      *bool
	translate                            *bool
	unit                                 *string
	uploadId                             *string
	versionString                        *string
	yAxisIsUp                            *bool
	importWithinDocument                 *bool
}

// The file to upload.
func (r ApiUploadFileCreateElementRequest) File(file map[string]interface{}) ApiUploadFileCreateElementRequest {
	r.file = &file
	return r
}

func (r ApiUploadFileCreateElementRequest) AllowFaultyParts(allowFaultyParts bool) ApiUploadFileCreateElementRequest {
	r.allowFaultyParts = &allowFaultyParts
	return r
}

func (r ApiUploadFileCreateElementRequest) CreateComposite(createComposite bool) ApiUploadFileCreateElementRequest {
	r.createComposite = &createComposite
	return r
}

func (r ApiUploadFileCreateElementRequest) CreateDrawingIfPossible(createDrawingIfPossible bool) ApiUploadFileCreateElementRequest {
	r.createDrawingIfPossible = &createDrawingIfPossible
	return r
}

func (r ApiUploadFileCreateElementRequest) EncodedFilename(encodedFilename string) ApiUploadFileCreateElementRequest {
	r.encodedFilename = &encodedFilename
	return r
}

func (r ApiUploadFileCreateElementRequest) ExtractAssemblyHierarchy(extractAssemblyHierarchy bool) ApiUploadFileCreateElementRequest {
	r.extractAssemblyHierarchy = &extractAssemblyHierarchy
	return r
}

func (r ApiUploadFileCreateElementRequest) FlattenAssemblies(flattenAssemblies bool) ApiUploadFileCreateElementRequest {
	r.flattenAssemblies = &flattenAssemblies
	return r
}

func (r ApiUploadFileCreateElementRequest) FormatName(formatName string) ApiUploadFileCreateElementRequest {
	r.formatName = &formatName
	return r
}

func (r ApiUploadFileCreateElementRequest) JoinAdjacentSurfaces(joinAdjacentSurfaces bool) ApiUploadFileCreateElementRequest {
	r.joinAdjacentSurfaces = &joinAdjacentSurfaces
	return r
}

func (r ApiUploadFileCreateElementRequest) LocationElementId(locationElementId string) ApiUploadFileCreateElementRequest {
	r.locationElementId = &locationElementId
	return r
}

func (r ApiUploadFileCreateElementRequest) LocationGroupId(locationGroupId string) ApiUploadFileCreateElementRequest {
	r.locationGroupId = &locationGroupId
	return r
}

func (r ApiUploadFileCreateElementRequest) LocationPosition(locationPosition int32) ApiUploadFileCreateElementRequest {
	r.locationPosition = &locationPosition
	return r
}

func (r ApiUploadFileCreateElementRequest) NotifyUser(notifyUser bool) ApiUploadFileCreateElementRequest {
	r.notifyUser = &notifyUser
	return r
}

func (r ApiUploadFileCreateElementRequest) OwnerId(ownerId string) ApiUploadFileCreateElementRequest {
	r.ownerId = &ownerId
	return r
}

func (r ApiUploadFileCreateElementRequest) ParentId(parentId string) ApiUploadFileCreateElementRequest {
	r.parentId = &parentId
	return r
}

func (r ApiUploadFileCreateElementRequest) ProjectId(projectId string) ApiUploadFileCreateElementRequest {
	r.projectId = &projectId
	return r
}

func (r ApiUploadFileCreateElementRequest) Public(public bool) ApiUploadFileCreateElementRequest {
	r.public = &public
	return r
}

func (r ApiUploadFileCreateElementRequest) OnePartPerDoc(onePartPerDoc bool) ApiUploadFileCreateElementRequest {
	r.onePartPerDoc = &onePartPerDoc
	return r
}

func (r ApiUploadFileCreateElementRequest) SplitAssembliesIntoMultipleDocuments(splitAssembliesIntoMultipleDocuments bool) ApiUploadFileCreateElementRequest {
	r.splitAssembliesIntoMultipleDocuments = &splitAssembliesIntoMultipleDocuments
	return r
}

func (r ApiUploadFileCreateElementRequest) StoreInDocument(storeInDocument bool) ApiUploadFileCreateElementRequest {
	r.storeInDocument = &storeInDocument
	return r
}

func (r ApiUploadFileCreateElementRequest) Translate(translate bool) ApiUploadFileCreateElementRequest {
	r.translate = &translate
	return r
}

func (r ApiUploadFileCreateElementRequest) Unit(unit string) ApiUploadFileCreateElementRequest {
	r.unit = &unit
	return r
}

func (r ApiUploadFileCreateElementRequest) UploadId(uploadId string) ApiUploadFileCreateElementRequest {
	r.uploadId = &uploadId
	return r
}

func (r ApiUploadFileCreateElementRequest) VersionString(versionString string) ApiUploadFileCreateElementRequest {
	r.versionString = &versionString
	return r
}

func (r ApiUploadFileCreateElementRequest) YAxisIsUp(yAxisIsUp bool) ApiUploadFileCreateElementRequest {
	r.yAxisIsUp = &yAxisIsUp
	return r
}

func (r ApiUploadFileCreateElementRequest) ImportWithinDocument(importWithinDocument bool) ApiUploadFileCreateElementRequest {
	r.importWithinDocument = &importWithinDocument
	return r
}

func (r ApiUploadFileCreateElementRequest) Execute() (*BTDocumentElementProcessingInfo, *http.Response, error) {
	return r.ApiService.UploadFileCreateElementExecute(r)
}

/*
UploadFileCreateElement Upload the file to a new tab by document ID and workspace ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wid
 @return ApiUploadFileCreateElementRequest
*/
func (a *BlobElementApiService) UploadFileCreateElement(ctx context.Context, did string, wid string) ApiUploadFileCreateElementRequest {
	return ApiUploadFileCreateElementRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
	}
}

// Execute executes the request
//  @return BTDocumentElementProcessingInfo
func (a *BlobElementApiService) UploadFileCreateElementExecute(r ApiUploadFileCreateElementRequest) (*BTDocumentElementProcessingInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTDocumentElementProcessingInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlobElementApiService.UploadFileCreateElement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blobelements/d/{did}/w/{wid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.file != nil {
		paramJson, err := parameterToJson(*r.file)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("file", paramJson)
	}
	if r.allowFaultyParts != nil {
		localVarFormParams.Add("allowFaultyParts", parameterToString(*r.allowFaultyParts, ""))
	}
	if r.createComposite != nil {
		localVarFormParams.Add("createComposite", parameterToString(*r.createComposite, ""))
	}
	if r.createDrawingIfPossible != nil {
		localVarFormParams.Add("createDrawingIfPossible", parameterToString(*r.createDrawingIfPossible, ""))
	}
	if r.encodedFilename != nil {
		localVarFormParams.Add("encodedFilename", parameterToString(*r.encodedFilename, ""))
	}
	if r.extractAssemblyHierarchy != nil {
		localVarFormParams.Add("extractAssemblyHierarchy", parameterToString(*r.extractAssemblyHierarchy, ""))
	}
	if r.flattenAssemblies != nil {
		localVarFormParams.Add("flattenAssemblies", parameterToString(*r.flattenAssemblies, ""))
	}
	if r.formatName != nil {
		localVarFormParams.Add("formatName", parameterToString(*r.formatName, ""))
	}
	if r.joinAdjacentSurfaces != nil {
		localVarFormParams.Add("joinAdjacentSurfaces", parameterToString(*r.joinAdjacentSurfaces, ""))
	}
	if r.locationElementId != nil {
		localVarFormParams.Add("locationElementId", parameterToString(*r.locationElementId, ""))
	}
	if r.locationGroupId != nil {
		localVarFormParams.Add("locationGroupId", parameterToString(*r.locationGroupId, ""))
	}
	if r.locationPosition != nil {
		localVarFormParams.Add("locationPosition", parameterToString(*r.locationPosition, ""))
	}
	if r.notifyUser != nil {
		localVarFormParams.Add("notifyUser", parameterToString(*r.notifyUser, ""))
	}
	if r.ownerId != nil {
		localVarFormParams.Add("ownerId", parameterToString(*r.ownerId, ""))
	}
	if r.parentId != nil {
		localVarFormParams.Add("parentId", parameterToString(*r.parentId, ""))
	}
	if r.projectId != nil {
		localVarFormParams.Add("projectId", parameterToString(*r.projectId, ""))
	}
	if r.public != nil {
		localVarFormParams.Add("public", parameterToString(*r.public, ""))
	}
	if r.onePartPerDoc != nil {
		localVarFormParams.Add("onePartPerDoc", parameterToString(*r.onePartPerDoc, ""))
	}
	if r.splitAssembliesIntoMultipleDocuments != nil {
		localVarFormParams.Add("splitAssembliesIntoMultipleDocuments", parameterToString(*r.splitAssembliesIntoMultipleDocuments, ""))
	}
	if r.storeInDocument != nil {
		localVarFormParams.Add("storeInDocument", parameterToString(*r.storeInDocument, ""))
	}
	if r.translate != nil {
		localVarFormParams.Add("translate", parameterToString(*r.translate, ""))
	}
	if r.unit != nil {
		localVarFormParams.Add("unit", parameterToString(*r.unit, ""))
	}
	if r.uploadId != nil {
		localVarFormParams.Add("uploadId", parameterToString(*r.uploadId, ""))
	}
	if r.versionString != nil {
		localVarFormParams.Add("versionString", parameterToString(*r.versionString, ""))
	}
	if r.yAxisIsUp != nil {
		localVarFormParams.Add("yAxisIsUp", parameterToString(*r.yAxisIsUp, ""))
	}
	if r.importWithinDocument != nil {
		localVarFormParams.Add("importWithinDocument", parameterToString(*r.importWithinDocument, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTDocumentElementProcessingInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadFileUpdateElementRequest struct {
	ctx                                  context.Context
	ApiService                           *BlobElementApiService
	did                                  string
	eid                                  string
	wid                                  string
	parentChangeId                       *string
	file                                 *map[string]interface{}
	allowFaultyParts                     *bool
	createComposite                      *bool
	createDrawingIfPossible              *bool
	encodedFilename                      *string
	extractAssemblyHierarchy             *bool
	flattenAssemblies                    *bool
	formatName                           *string
	joinAdjacentSurfaces                 *bool
	locationElementId                    *string
	locationGroupId                      *string
	locationPosition                     *int32
	notifyUser                           *bool
	ownerId                              *string
	parentId                             *string
	projectId                            *string
	public                               *bool
	onePartPerDoc                        *bool
	splitAssembliesIntoMultipleDocuments *bool
	storeInDocument                      *bool
	translate                            *bool
	unit                                 *string
	uploadId                             *string
	versionString                        *string
	yAxisIsUp                            *bool
	importWithinDocument                 *bool
}

func (r ApiUploadFileUpdateElementRequest) ParentChangeId(parentChangeId string) ApiUploadFileUpdateElementRequest {
	r.parentChangeId = &parentChangeId
	return r
}

// The file to upload.
func (r ApiUploadFileUpdateElementRequest) File(file map[string]interface{}) ApiUploadFileUpdateElementRequest {
	r.file = &file
	return r
}

func (r ApiUploadFileUpdateElementRequest) AllowFaultyParts(allowFaultyParts bool) ApiUploadFileUpdateElementRequest {
	r.allowFaultyParts = &allowFaultyParts
	return r
}

func (r ApiUploadFileUpdateElementRequest) CreateComposite(createComposite bool) ApiUploadFileUpdateElementRequest {
	r.createComposite = &createComposite
	return r
}

func (r ApiUploadFileUpdateElementRequest) CreateDrawingIfPossible(createDrawingIfPossible bool) ApiUploadFileUpdateElementRequest {
	r.createDrawingIfPossible = &createDrawingIfPossible
	return r
}

func (r ApiUploadFileUpdateElementRequest) EncodedFilename(encodedFilename string) ApiUploadFileUpdateElementRequest {
	r.encodedFilename = &encodedFilename
	return r
}

func (r ApiUploadFileUpdateElementRequest) ExtractAssemblyHierarchy(extractAssemblyHierarchy bool) ApiUploadFileUpdateElementRequest {
	r.extractAssemblyHierarchy = &extractAssemblyHierarchy
	return r
}

func (r ApiUploadFileUpdateElementRequest) FlattenAssemblies(flattenAssemblies bool) ApiUploadFileUpdateElementRequest {
	r.flattenAssemblies = &flattenAssemblies
	return r
}

func (r ApiUploadFileUpdateElementRequest) FormatName(formatName string) ApiUploadFileUpdateElementRequest {
	r.formatName = &formatName
	return r
}

func (r ApiUploadFileUpdateElementRequest) JoinAdjacentSurfaces(joinAdjacentSurfaces bool) ApiUploadFileUpdateElementRequest {
	r.joinAdjacentSurfaces = &joinAdjacentSurfaces
	return r
}

func (r ApiUploadFileUpdateElementRequest) LocationElementId(locationElementId string) ApiUploadFileUpdateElementRequest {
	r.locationElementId = &locationElementId
	return r
}

func (r ApiUploadFileUpdateElementRequest) LocationGroupId(locationGroupId string) ApiUploadFileUpdateElementRequest {
	r.locationGroupId = &locationGroupId
	return r
}

func (r ApiUploadFileUpdateElementRequest) LocationPosition(locationPosition int32) ApiUploadFileUpdateElementRequest {
	r.locationPosition = &locationPosition
	return r
}

func (r ApiUploadFileUpdateElementRequest) NotifyUser(notifyUser bool) ApiUploadFileUpdateElementRequest {
	r.notifyUser = &notifyUser
	return r
}

func (r ApiUploadFileUpdateElementRequest) OwnerId(ownerId string) ApiUploadFileUpdateElementRequest {
	r.ownerId = &ownerId
	return r
}

func (r ApiUploadFileUpdateElementRequest) ParentId(parentId string) ApiUploadFileUpdateElementRequest {
	r.parentId = &parentId
	return r
}

func (r ApiUploadFileUpdateElementRequest) ProjectId(projectId string) ApiUploadFileUpdateElementRequest {
	r.projectId = &projectId
	return r
}

func (r ApiUploadFileUpdateElementRequest) Public(public bool) ApiUploadFileUpdateElementRequest {
	r.public = &public
	return r
}

func (r ApiUploadFileUpdateElementRequest) OnePartPerDoc(onePartPerDoc bool) ApiUploadFileUpdateElementRequest {
	r.onePartPerDoc = &onePartPerDoc
	return r
}

func (r ApiUploadFileUpdateElementRequest) SplitAssembliesIntoMultipleDocuments(splitAssembliesIntoMultipleDocuments bool) ApiUploadFileUpdateElementRequest {
	r.splitAssembliesIntoMultipleDocuments = &splitAssembliesIntoMultipleDocuments
	return r
}

func (r ApiUploadFileUpdateElementRequest) StoreInDocument(storeInDocument bool) ApiUploadFileUpdateElementRequest {
	r.storeInDocument = &storeInDocument
	return r
}

func (r ApiUploadFileUpdateElementRequest) Translate(translate bool) ApiUploadFileUpdateElementRequest {
	r.translate = &translate
	return r
}

func (r ApiUploadFileUpdateElementRequest) Unit(unit string) ApiUploadFileUpdateElementRequest {
	r.unit = &unit
	return r
}

func (r ApiUploadFileUpdateElementRequest) UploadId(uploadId string) ApiUploadFileUpdateElementRequest {
	r.uploadId = &uploadId
	return r
}

func (r ApiUploadFileUpdateElementRequest) VersionString(versionString string) ApiUploadFileUpdateElementRequest {
	r.versionString = &versionString
	return r
}

func (r ApiUploadFileUpdateElementRequest) YAxisIsUp(yAxisIsUp bool) ApiUploadFileUpdateElementRequest {
	r.yAxisIsUp = &yAxisIsUp
	return r
}

func (r ApiUploadFileUpdateElementRequest) ImportWithinDocument(importWithinDocument bool) ApiUploadFileUpdateElementRequest {
	r.importWithinDocument = &importWithinDocument
	return r
}

func (r ApiUploadFileUpdateElementRequest) Execute() (*BTDocumentElementProcessingInfo, *http.Response, error) {
	return r.ApiService.UploadFileUpdateElementExecute(r)
}

/*
UploadFileUpdateElement Update a blob element by uploading a file by document ID, workspace ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param eid
 @param wid
 @return ApiUploadFileUpdateElementRequest
*/
func (a *BlobElementApiService) UploadFileUpdateElement(ctx context.Context, did string, eid string, wid string) ApiUploadFileUpdateElementRequest {
	return ApiUploadFileUpdateElementRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
		wid:        wid,
	}
}

// Execute executes the request
//  @return BTDocumentElementProcessingInfo
func (a *BlobElementApiService) UploadFileUpdateElementExecute(r ApiUploadFileUpdateElementRequest) (*BTDocumentElementProcessingInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTDocumentElementProcessingInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlobElementApiService.UploadFileUpdateElement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blobelements/d/{did}/w/{wid}/e/{eid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.parentChangeId != nil {
		localVarQueryParams.Add("parentChangeId", parameterToString(*r.parentChangeId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.file != nil {
		paramJson, err := parameterToJson(*r.file)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("file", paramJson)
	}
	if r.allowFaultyParts != nil {
		localVarFormParams.Add("allowFaultyParts", parameterToString(*r.allowFaultyParts, ""))
	}
	if r.createComposite != nil {
		localVarFormParams.Add("createComposite", parameterToString(*r.createComposite, ""))
	}
	if r.createDrawingIfPossible != nil {
		localVarFormParams.Add("createDrawingIfPossible", parameterToString(*r.createDrawingIfPossible, ""))
	}
	if r.encodedFilename != nil {
		localVarFormParams.Add("encodedFilename", parameterToString(*r.encodedFilename, ""))
	}
	if r.extractAssemblyHierarchy != nil {
		localVarFormParams.Add("extractAssemblyHierarchy", parameterToString(*r.extractAssemblyHierarchy, ""))
	}
	if r.flattenAssemblies != nil {
		localVarFormParams.Add("flattenAssemblies", parameterToString(*r.flattenAssemblies, ""))
	}
	if r.formatName != nil {
		localVarFormParams.Add("formatName", parameterToString(*r.formatName, ""))
	}
	if r.joinAdjacentSurfaces != nil {
		localVarFormParams.Add("joinAdjacentSurfaces", parameterToString(*r.joinAdjacentSurfaces, ""))
	}
	if r.locationElementId != nil {
		localVarFormParams.Add("locationElementId", parameterToString(*r.locationElementId, ""))
	}
	if r.locationGroupId != nil {
		localVarFormParams.Add("locationGroupId", parameterToString(*r.locationGroupId, ""))
	}
	if r.locationPosition != nil {
		localVarFormParams.Add("locationPosition", parameterToString(*r.locationPosition, ""))
	}
	if r.notifyUser != nil {
		localVarFormParams.Add("notifyUser", parameterToString(*r.notifyUser, ""))
	}
	if r.ownerId != nil {
		localVarFormParams.Add("ownerId", parameterToString(*r.ownerId, ""))
	}
	if r.parentId != nil {
		localVarFormParams.Add("parentId", parameterToString(*r.parentId, ""))
	}
	if r.projectId != nil {
		localVarFormParams.Add("projectId", parameterToString(*r.projectId, ""))
	}
	if r.public != nil {
		localVarFormParams.Add("public", parameterToString(*r.public, ""))
	}
	if r.onePartPerDoc != nil {
		localVarFormParams.Add("onePartPerDoc", parameterToString(*r.onePartPerDoc, ""))
	}
	if r.splitAssembliesIntoMultipleDocuments != nil {
		localVarFormParams.Add("splitAssembliesIntoMultipleDocuments", parameterToString(*r.splitAssembliesIntoMultipleDocuments, ""))
	}
	if r.storeInDocument != nil {
		localVarFormParams.Add("storeInDocument", parameterToString(*r.storeInDocument, ""))
	}
	if r.translate != nil {
		localVarFormParams.Add("translate", parameterToString(*r.translate, ""))
	}
	if r.unit != nil {
		localVarFormParams.Add("unit", parameterToString(*r.unit, ""))
	}
	if r.uploadId != nil {
		localVarFormParams.Add("uploadId", parameterToString(*r.uploadId, ""))
	}
	if r.versionString != nil {
		localVarFormParams.Add("versionString", parameterToString(*r.versionString, ""))
	}
	if r.yAxisIsUp != nil {
		localVarFormParams.Add("yAxisIsUp", parameterToString(*r.yAxisIsUp, ""))
	}
	if r.importWithinDocument != nil {
		localVarFormParams.Add("importWithinDocument", parameterToString(*r.importWithinDocument, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTDocumentElementProcessingInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
