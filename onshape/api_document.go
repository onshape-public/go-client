/*
Onshape REST API

The Onshape REST API consumed by all client. # Authorization The simplest way to authorize and enable the **Try it out** functionality is to sign in to Onshape and use the current session. The **Authorize** button enables other authorization techniques. To ensure the current session isn't used when trying other authentication techniques, make sure to remove the Onshape cookie as per the instructions for your particular browser. Alternatively, a private or incognito window may be used. Here's [how to remove a specific cookie on Chrome](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site). - **Current Session** authorization is enabled by default if the browser is already signed in to [Onshape](/). - **OAuth2** authorization uses an Onshape OAuth2 app created on the [Onshape Developer Portal](https://dev-portal.onshape.com/oauthApps). The redirect URL field should include `https://cad.onshape.com/glassworks/explorer/oauth2-redirect.html`. - **API Key** authorization using basic authentication is also available. The keys can be generated in the [Onshape Developer Portal](https://dev-portal.onshape.com/keys). In the authentication dialog, enter the access key in the `Username` field, and enter the secret key in the `Password` field. Basic authentication should only be used during the development process since sharing API Keys provides the same level of access as a username and password.

API version: 1.155.7070-d84f850e97a2
Contact: api-support@onshape.zendesk.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package onshape

import (
	"context"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// DocumentApiService DocumentApi service
type DocumentApiService service

type ApiCopyWorkspaceRequest struct {
	ctx                  context.Context
	ApiService           *DocumentApiService
	did                  string
	wid                  string
	bTCopyDocumentParams *BTCopyDocumentParams
}

func (r ApiCopyWorkspaceRequest) BTCopyDocumentParams(bTCopyDocumentParams BTCopyDocumentParams) ApiCopyWorkspaceRequest {
	r.bTCopyDocumentParams = &bTCopyDocumentParams
	return r
}

func (r ApiCopyWorkspaceRequest) Execute() (*BTCopyDocumentInfo, *http.Response, error) {
	return r.ApiService.CopyWorkspaceExecute(r)
}

/*
CopyWorkspace Copy workspace by document ID and workspace ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wid
 @return ApiCopyWorkspaceRequest
*/
func (a *DocumentApiService) CopyWorkspace(ctx context.Context, did string, wid string) ApiCopyWorkspaceRequest {
	return ApiCopyWorkspaceRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
	}
}

// Execute executes the request
//  @return BTCopyDocumentInfo
func (a *DocumentApiService) CopyWorkspaceExecute(r ApiCopyWorkspaceRequest) (*BTCopyDocumentInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTCopyDocumentInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.CopyWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/{did}/workspaces/{wid}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTCopyDocumentParams == nil {
		return localVarReturnValue, nil, reportError("bTCopyDocumentParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTCopyDocumentParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDocumentRequest struct {
	ctx              context.Context
	ApiService       *DocumentApiService
	bTDocumentParams *BTDocumentParams
}

func (r ApiCreateDocumentRequest) BTDocumentParams(bTDocumentParams BTDocumentParams) ApiCreateDocumentRequest {
	r.bTDocumentParams = &bTDocumentParams
	return r
}

func (r ApiCreateDocumentRequest) Execute() (*BTDocumentInfo, *http.Response, error) {
	return r.ApiService.CreateDocumentExecute(r)
}

/*
CreateDocument Create and upload a document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDocumentRequest
*/
func (a *DocumentApiService) CreateDocument(ctx context.Context) ApiCreateDocumentRequest {
	return ApiCreateDocumentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return BTDocumentInfo
func (a *DocumentApiService) CreateDocumentExecute(r ApiCreateDocumentRequest) (*BTDocumentInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTDocumentInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.CreateDocument")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTDocumentParams == nil {
		return localVarReturnValue, nil, reportError("bTDocumentParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTDocumentParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTDocumentInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateVersionRequest struct {
	ctx                        context.Context
	ApiService                 *DocumentApiService
	did                        string
	bTVersionOrWorkspaceParams *BTVersionOrWorkspaceParams
}

func (r ApiCreateVersionRequest) BTVersionOrWorkspaceParams(bTVersionOrWorkspaceParams BTVersionOrWorkspaceParams) ApiCreateVersionRequest {
	r.bTVersionOrWorkspaceParams = &bTVersionOrWorkspaceParams
	return r
}

func (r ApiCreateVersionRequest) Execute() (*BTVersionInfo, *http.Response, error) {
	return r.ApiService.CreateVersionExecute(r)
}

/*
CreateVersion Create version by document ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @return ApiCreateVersionRequest
*/
func (a *DocumentApiService) CreateVersion(ctx context.Context, did string) ApiCreateVersionRequest {
	return ApiCreateVersionRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
	}
}

// Execute executes the request
//  @return BTVersionInfo
func (a *DocumentApiService) CreateVersionExecute(r ApiCreateVersionRequest) (*BTVersionInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTVersionInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.CreateVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/d/{did}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTVersionOrWorkspaceParams == nil {
		return localVarReturnValue, nil, reportError("bTVersionOrWorkspaceParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTVersionOrWorkspaceParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTVersionInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateWorkspaceRequest struct {
	ctx                        context.Context
	ApiService                 *DocumentApiService
	did                        string
	bTVersionOrWorkspaceParams *BTVersionOrWorkspaceParams
}

func (r ApiCreateWorkspaceRequest) BTVersionOrWorkspaceParams(bTVersionOrWorkspaceParams BTVersionOrWorkspaceParams) ApiCreateWorkspaceRequest {
	r.bTVersionOrWorkspaceParams = &bTVersionOrWorkspaceParams
	return r
}

func (r ApiCreateWorkspaceRequest) Execute() (*BTWorkspaceInfo, *http.Response, error) {
	return r.ApiService.CreateWorkspaceExecute(r)
}

/*
CreateWorkspace Create workspace by document ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @return ApiCreateWorkspaceRequest
*/
func (a *DocumentApiService) CreateWorkspace(ctx context.Context, did string) ApiCreateWorkspaceRequest {
	return ApiCreateWorkspaceRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
	}
}

// Execute executes the request
//  @return BTWorkspaceInfo
func (a *DocumentApiService) CreateWorkspaceExecute(r ApiCreateWorkspaceRequest) (*BTWorkspaceInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTWorkspaceInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.CreateWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/d/{did}/workspaces"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTVersionOrWorkspaceParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTWorkspaceInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDocumentRequest struct {
	ctx        context.Context
	ApiService *DocumentApiService
	did        string
	forever    *bool
}

func (r ApiDeleteDocumentRequest) Forever(forever bool) ApiDeleteDocumentRequest {
	r.forever = &forever
	return r
}

func (r ApiDeleteDocumentRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteDocumentExecute(r)
}

/*
DeleteDocument Delete document by document ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @return ApiDeleteDocumentRequest
*/
func (a *DocumentApiService) DeleteDocument(ctx context.Context, did string) ApiDeleteDocumentRequest {
	return ApiDeleteDocumentRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DocumentApiService) DeleteDocumentExecute(r ApiDeleteDocumentRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.DeleteDocument")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/{did}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.forever != nil {
		localVarQueryParams.Add("forever", parameterToString(*r.forever, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteWorkspaceRequest struct {
	ctx        context.Context
	ApiService *DocumentApiService
	did        string
	wid        string
}

func (r ApiDeleteWorkspaceRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteWorkspaceExecute(r)
}

/*
DeleteWorkspace Delete workspace by document ID and workspace ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wid
 @return ApiDeleteWorkspaceRequest
*/
func (a *DocumentApiService) DeleteWorkspace(ctx context.Context, did string, wid string) ApiDeleteWorkspaceRequest {
	return ApiDeleteWorkspaceRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DocumentApiService) DeleteWorkspaceExecute(r ApiDeleteWorkspaceRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.DeleteWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/d/{did}/workspaces/{wid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadExternalDataRequest struct {
	ctx         context.Context
	ApiService  *DocumentApiService
	did         string
	fid         string
	ifNoneMatch *string
}

func (r ApiDownloadExternalDataRequest) IfNoneMatch(ifNoneMatch string) ApiDownloadExternalDataRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r ApiDownloadExternalDataRequest) Execute() (*HttpFile, *http.Response, error) {
	return r.ApiService.DownloadExternalDataExecute(r)
}

/*
DownloadExternalData Retrieve external data by document ID and foreign ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param fid
 @return ApiDownloadExternalDataRequest
*/
func (a *DocumentApiService) DownloadExternalData(ctx context.Context, did string, fid string) ApiDownloadExternalDataRequest {
	return ApiDownloadExternalDataRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		fid:        fid,
	}
}

// Execute executes the request
//  @return HttpFile
func (a *DocumentApiService) DownloadExternalDataExecute(r ApiDownloadExternalDataRequest) (*HttpFile, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *HttpFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.DownloadExternalData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/d/{did}/externaldata/{fid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fid"+"}", url.PathEscape(parameterToString(r.fid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExport2JsonRequest struct {
	ctx                  context.Context
	ApiService           *DocumentApiService
	did                  string
	wv                   string
	wvid                 string
	eid                  string
	linkDocumentId       *string
	bTBExportModelParams *BTBExportModelParams
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiExport2JsonRequest) LinkDocumentId(linkDocumentId string) ApiExport2JsonRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiExport2JsonRequest) BTBExportModelParams(bTBExportModelParams BTBExportModelParams) ApiExport2JsonRequest {
	r.bTBExportModelParams = &bTBExportModelParams
	return r
}

func (r ApiExport2JsonRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.Export2JsonExecute(r)
}

/*
Export2Json Export document by document ID, workspace or version ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wv
 @param wvid
 @param eid The id of the element in which to perform the operation.
 @return ApiExport2JsonRequest
*/
func (a *DocumentApiService) Export2Json(ctx context.Context, did string, wv string, wvid string, eid string) ApiExport2JsonRequest {
	return ApiExport2JsonRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wv:         wv,
		wvid:       wvid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DocumentApiService) Export2JsonExecute(r ApiExport2JsonRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.Export2Json")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/d/{did}/{wv}/{wvid}/e/{eid}/export"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wv"+"}", url.PathEscape(parameterToString(r.wv, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvid"+"}", url.PathEscape(parameterToString(r.wvid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTBExportModelParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrentMicroversionRequest struct {
	ctx        context.Context
	ApiService *DocumentApiService
	did        string
	wv         string
	wvid       string
}

func (r ApiGetCurrentMicroversionRequest) Execute() (*BTMicroversionInfo, *http.Response, error) {
	return r.ApiService.GetCurrentMicroversionExecute(r)
}

/*
GetCurrentMicroversion Retrieve current microversion by document ID and workspace or version ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wv
 @param wvid
 @return ApiGetCurrentMicroversionRequest
*/
func (a *DocumentApiService) GetCurrentMicroversion(ctx context.Context, did string, wv string, wvid string) ApiGetCurrentMicroversionRequest {
	return ApiGetCurrentMicroversionRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wv:         wv,
		wvid:       wvid,
	}
}

// Execute executes the request
//  @return BTMicroversionInfo
func (a *DocumentApiService) GetCurrentMicroversionExecute(r ApiGetCurrentMicroversionRequest) (*BTMicroversionInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTMicroversionInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.GetCurrentMicroversion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/d/{did}/{wv}/{wvid}/currentmicroversion"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wv"+"}", url.PathEscape(parameterToString(r.wv, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvid"+"}", url.PathEscape(parameterToString(r.wvid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTMicroversionInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDocumentRequest struct {
	ctx        context.Context
	ApiService *DocumentApiService
	did        string
}

func (r ApiGetDocumentRequest) Execute() (*BTDocumentInfo, *http.Response, error) {
	return r.ApiService.GetDocumentExecute(r)
}

/*
GetDocument Retrieve document by document ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @return ApiGetDocumentRequest
*/
func (a *DocumentApiService) GetDocument(ctx context.Context, did string) ApiGetDocumentRequest {
	return ApiGetDocumentRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
	}
}

// Execute executes the request
//  @return BTDocumentInfo
func (a *DocumentApiService) GetDocumentExecute(r ApiGetDocumentRequest) (*BTDocumentInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTDocumentInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.GetDocument")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/{did}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDocumentAclRequest struct {
	ctx        context.Context
	ApiService *DocumentApiService
	did        string
}

func (r ApiGetDocumentAclRequest) Execute() (*BTAclInfo, *http.Response, error) {
	return r.ApiService.GetDocumentAclExecute(r)
}

/*
GetDocumentAcl Retrieve access control list by document ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @return ApiGetDocumentAclRequest
*/
func (a *DocumentApiService) GetDocumentAcl(ctx context.Context, did string) ApiGetDocumentAclRequest {
	return ApiGetDocumentAclRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
	}
}

// Execute executes the request
//  @return BTAclInfo
func (a *DocumentApiService) GetDocumentAclExecute(r ApiGetDocumentAclRequest) (*BTAclInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAclInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.GetDocumentAcl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/{did}/acl"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAclInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDocumentHistoryRequest struct {
	ctx        context.Context
	ApiService *DocumentApiService
	did        string
	wm         string
	wmid       string
}

func (r ApiGetDocumentHistoryRequest) Execute() ([]BTDocumentHistoryInfo, *http.Response, error) {
	return r.ApiService.GetDocumentHistoryExecute(r)
}

/*
GetDocumentHistory Retrieve document history by document ID and workspace or microversion ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wm
 @param wmid
 @return ApiGetDocumentHistoryRequest
*/
func (a *DocumentApiService) GetDocumentHistory(ctx context.Context, did string, wm string, wmid string) ApiGetDocumentHistoryRequest {
	return ApiGetDocumentHistoryRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wm:         wm,
		wmid:       wmid,
	}
}

// Execute executes the request
//  @return []BTDocumentHistoryInfo
func (a *DocumentApiService) GetDocumentHistoryExecute(r ApiGetDocumentHistoryRequest) ([]BTDocumentHistoryInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []BTDocumentHistoryInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.GetDocumentHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/d/{did}/{wm}/{wmid}/documenthistory"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wm"+"}", url.PathEscape(parameterToString(r.wm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wmid"+"}", url.PathEscape(parameterToString(r.wmid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v []BTDocumentHistoryInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDocumentPermissionSetRequest struct {
	ctx        context.Context
	ApiService *DocumentApiService
	did        string
}

func (r ApiGetDocumentPermissionSetRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetDocumentPermissionSetExecute(r)
}

/*
GetDocumentPermissionSet Retrieve Document permissions by document ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @return ApiGetDocumentPermissionSetRequest
*/
func (a *DocumentApiService) GetDocumentPermissionSet(ctx context.Context, did string) ApiGetDocumentPermissionSetRequest {
	return ApiGetDocumentPermissionSetRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
	}
}

// Execute executes the request
//  @return []string
func (a *DocumentApiService) GetDocumentPermissionSetExecute(r ApiGetDocumentPermissionSetRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.GetDocumentPermissionSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/{did}/permissionset"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDocumentVersionsRequest struct {
	ctx        context.Context
	ApiService *DocumentApiService
	did        string
	offset     *int32
	limit      *int32
}

func (r ApiGetDocumentVersionsRequest) Offset(offset int32) ApiGetDocumentVersionsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetDocumentVersionsRequest) Limit(limit int32) ApiGetDocumentVersionsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetDocumentVersionsRequest) Execute() ([]BTVersionInfo, *http.Response, error) {
	return r.ApiService.GetDocumentVersionsExecute(r)
}

/*
GetDocumentVersions Retrieve versions by document ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @return ApiGetDocumentVersionsRequest
*/
func (a *DocumentApiService) GetDocumentVersions(ctx context.Context, did string) ApiGetDocumentVersionsRequest {
	return ApiGetDocumentVersionsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
	}
}

// Execute executes the request
//  @return []BTVersionInfo
func (a *DocumentApiService) GetDocumentVersionsExecute(r ApiGetDocumentVersionsRequest) ([]BTVersionInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []BTVersionInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.GetDocumentVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/d/{did}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v []BTVersionInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDocumentWorkspacesRequest struct {
	ctx        context.Context
	ApiService *DocumentApiService
	did        string
}

func (r ApiGetDocumentWorkspacesRequest) Execute() ([]BTWorkspaceInfo, *http.Response, error) {
	return r.ApiService.GetDocumentWorkspacesExecute(r)
}

/*
GetDocumentWorkspaces Retrieve workspaces by document ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @return ApiGetDocumentWorkspacesRequest
*/
func (a *DocumentApiService) GetDocumentWorkspaces(ctx context.Context, did string) ApiGetDocumentWorkspacesRequest {
	return ApiGetDocumentWorkspacesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
	}
}

// Execute executes the request
//  @return []BTWorkspaceInfo
func (a *DocumentApiService) GetDocumentWorkspacesExecute(r ApiGetDocumentWorkspacesRequest) ([]BTWorkspaceInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []BTWorkspaceInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.GetDocumentWorkspaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/d/{did}/workspaces"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v []BTWorkspaceInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDocumentsRequest struct {
	ctx        context.Context
	ApiService *DocumentApiService
	q          *string
	filter     *int32
	owner      *string
	ownerType  *int32
	sortColumn *string
	sortOrder  *string
	offset     *int32
	limit      *int32
	label      *string
	project    *string
	parentId   *string
}

func (r ApiGetDocumentsRequest) Q(q string) ApiGetDocumentsRequest {
	r.q = &q
	return r
}

func (r ApiGetDocumentsRequest) Filter(filter int32) ApiGetDocumentsRequest {
	r.filter = &filter
	return r
}

func (r ApiGetDocumentsRequest) Owner(owner string) ApiGetDocumentsRequest {
	r.owner = &owner
	return r
}

func (r ApiGetDocumentsRequest) OwnerType(ownerType int32) ApiGetDocumentsRequest {
	r.ownerType = &ownerType
	return r
}

func (r ApiGetDocumentsRequest) SortColumn(sortColumn string) ApiGetDocumentsRequest {
	r.sortColumn = &sortColumn
	return r
}

func (r ApiGetDocumentsRequest) SortOrder(sortOrder string) ApiGetDocumentsRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiGetDocumentsRequest) Offset(offset int32) ApiGetDocumentsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetDocumentsRequest) Limit(limit int32) ApiGetDocumentsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetDocumentsRequest) Label(label string) ApiGetDocumentsRequest {
	r.label = &label
	return r
}

func (r ApiGetDocumentsRequest) Project(project string) ApiGetDocumentsRequest {
	r.project = &project
	return r
}

func (r ApiGetDocumentsRequest) ParentId(parentId string) ApiGetDocumentsRequest {
	r.parentId = &parentId
	return r
}

func (r ApiGetDocumentsRequest) Execute() (*BTGlobalTreeNodeListResponse, *http.Response, error) {
	return r.ApiService.GetDocumentsExecute(r)
}

/*
GetDocuments Retrieve a document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDocumentsRequest
*/
func (a *DocumentApiService) GetDocuments(ctx context.Context) ApiGetDocumentsRequest {
	return ApiGetDocumentsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return BTGlobalTreeNodeListResponse
func (a *DocumentApiService) GetDocumentsExecute(r ApiGetDocumentsRequest) (*BTGlobalTreeNodeListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTGlobalTreeNodeListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.GetDocuments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.owner != nil {
		localVarQueryParams.Add("owner", parameterToString(*r.owner, ""))
	}
	if r.ownerType != nil {
		localVarQueryParams.Add("ownerType", parameterToString(*r.ownerType, ""))
	}
	if r.sortColumn != nil {
		localVarQueryParams.Add("sortColumn", parameterToString(*r.sortColumn, ""))
	}
	if r.sortOrder != nil {
		localVarQueryParams.Add("sortOrder", parameterToString(*r.sortOrder, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.label != nil {
		localVarQueryParams.Add("label", parameterToString(*r.label, ""))
	}
	if r.project != nil {
		localVarQueryParams.Add("project", parameterToString(*r.project, ""))
	}
	if r.parentId != nil {
		localVarQueryParams.Add("parentId", parameterToString(*r.parentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetElementsInDocumentRequest struct {
	ctx            context.Context
	ApiService     *DocumentApiService
	did            string
	wvm            string
	wvmid          string
	linkDocumentId *string
	elementType    *string
	elementId      *string
	withThumbnails *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetElementsInDocumentRequest) LinkDocumentId(linkDocumentId string) ApiGetElementsInDocumentRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetElementsInDocumentRequest) ElementType(elementType string) ApiGetElementsInDocumentRequest {
	r.elementType = &elementType
	return r
}

func (r ApiGetElementsInDocumentRequest) ElementId(elementId string) ApiGetElementsInDocumentRequest {
	r.elementId = &elementId
	return r
}

func (r ApiGetElementsInDocumentRequest) WithThumbnails(withThumbnails bool) ApiGetElementsInDocumentRequest {
	r.withThumbnails = &withThumbnails
	return r
}

func (r ApiGetElementsInDocumentRequest) Execute() ([]BTDocumentElementInfo, *http.Response, error) {
	return r.ApiService.GetElementsInDocumentExecute(r)
}

/*
GetElementsInDocument Retrieve tabs by document ID and workspace or version or microversion ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace id, version id, or document microversion id is specified below.
 @param wvmid The id of the workspace, version, or document microversion in which the operation should be performed.
 @return ApiGetElementsInDocumentRequest
*/
func (a *DocumentApiService) GetElementsInDocument(ctx context.Context, did string, wvm string, wvmid string) ApiGetElementsInDocumentRequest {
	return ApiGetElementsInDocumentRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
	}
}

// Execute executes the request
//  @return []BTDocumentElementInfo
func (a *DocumentApiService) GetElementsInDocumentExecute(r ApiGetElementsInDocumentRequest) ([]BTDocumentElementInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []BTDocumentElementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.GetElementsInDocument")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/d/{did}/{wvm}/{wvmid}/elements"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.elementType != nil {
		localVarQueryParams.Add("elementType", parameterToString(*r.elementType, ""))
	}
	if r.elementId != nil {
		localVarQueryParams.Add("elementId", parameterToString(*r.elementId, ""))
	}
	if r.withThumbnails != nil {
		localVarQueryParams.Add("withThumbnails", parameterToString(*r.withThumbnails, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInsertablesRequest struct {
	ctx                                    context.Context
	ApiService                             *DocumentApiService
	did                                    string
	wv                                     string
	wvid                                   string
	elementId                              *string
	configuration                          *string
	betaCapabilityIds                      *[]string
	includeParts                           *bool
	includeSurfaces                        *bool
	includeSketches                        *bool
	includeReferenceFeatures               *bool
	includeAssemblies                      *bool
	includeFeatureStudios                  *bool
	includeBlobs                           *bool
	allowedBlobMimeTypes                   *string
	excludeNewerFSVersions                 *bool
	maxFeatureScriptVersion                *int32
	includePartStudios                     *bool
	includeFeatures                        *bool
	includeMeshes                          *bool
	includeWires                           *bool
	includeFlattenedBodies                 *bool
	includeApplications                    *bool
	allowedApplicationMimeTypes            *string
	includeCompositeParts                  *bool
	includeFSTables                        *bool
	includeFSComputedPartPropertyFunctions *bool
	includeVariables                       *bool
	includeVariableStudios                 *bool
	allowedBlobExtensions                  *string
}

func (r ApiGetInsertablesRequest) ElementId(elementId string) ApiGetInsertablesRequest {
	r.elementId = &elementId
	return r
}

func (r ApiGetInsertablesRequest) Configuration(configuration string) ApiGetInsertablesRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetInsertablesRequest) BetaCapabilityIds(betaCapabilityIds []string) ApiGetInsertablesRequest {
	r.betaCapabilityIds = &betaCapabilityIds
	return r
}

func (r ApiGetInsertablesRequest) IncludeParts(includeParts bool) ApiGetInsertablesRequest {
	r.includeParts = &includeParts
	return r
}

func (r ApiGetInsertablesRequest) IncludeSurfaces(includeSurfaces bool) ApiGetInsertablesRequest {
	r.includeSurfaces = &includeSurfaces
	return r
}

func (r ApiGetInsertablesRequest) IncludeSketches(includeSketches bool) ApiGetInsertablesRequest {
	r.includeSketches = &includeSketches
	return r
}

func (r ApiGetInsertablesRequest) IncludeReferenceFeatures(includeReferenceFeatures bool) ApiGetInsertablesRequest {
	r.includeReferenceFeatures = &includeReferenceFeatures
	return r
}

func (r ApiGetInsertablesRequest) IncludeAssemblies(includeAssemblies bool) ApiGetInsertablesRequest {
	r.includeAssemblies = &includeAssemblies
	return r
}

func (r ApiGetInsertablesRequest) IncludeFeatureStudios(includeFeatureStudios bool) ApiGetInsertablesRequest {
	r.includeFeatureStudios = &includeFeatureStudios
	return r
}

func (r ApiGetInsertablesRequest) IncludeBlobs(includeBlobs bool) ApiGetInsertablesRequest {
	r.includeBlobs = &includeBlobs
	return r
}

func (r ApiGetInsertablesRequest) AllowedBlobMimeTypes(allowedBlobMimeTypes string) ApiGetInsertablesRequest {
	r.allowedBlobMimeTypes = &allowedBlobMimeTypes
	return r
}

func (r ApiGetInsertablesRequest) ExcludeNewerFSVersions(excludeNewerFSVersions bool) ApiGetInsertablesRequest {
	r.excludeNewerFSVersions = &excludeNewerFSVersions
	return r
}

func (r ApiGetInsertablesRequest) MaxFeatureScriptVersion(maxFeatureScriptVersion int32) ApiGetInsertablesRequest {
	r.maxFeatureScriptVersion = &maxFeatureScriptVersion
	return r
}

func (r ApiGetInsertablesRequest) IncludePartStudios(includePartStudios bool) ApiGetInsertablesRequest {
	r.includePartStudios = &includePartStudios
	return r
}

func (r ApiGetInsertablesRequest) IncludeFeatures(includeFeatures bool) ApiGetInsertablesRequest {
	r.includeFeatures = &includeFeatures
	return r
}

func (r ApiGetInsertablesRequest) IncludeMeshes(includeMeshes bool) ApiGetInsertablesRequest {
	r.includeMeshes = &includeMeshes
	return r
}

func (r ApiGetInsertablesRequest) IncludeWires(includeWires bool) ApiGetInsertablesRequest {
	r.includeWires = &includeWires
	return r
}

func (r ApiGetInsertablesRequest) IncludeFlattenedBodies(includeFlattenedBodies bool) ApiGetInsertablesRequest {
	r.includeFlattenedBodies = &includeFlattenedBodies
	return r
}

func (r ApiGetInsertablesRequest) IncludeApplications(includeApplications bool) ApiGetInsertablesRequest {
	r.includeApplications = &includeApplications
	return r
}

func (r ApiGetInsertablesRequest) AllowedApplicationMimeTypes(allowedApplicationMimeTypes string) ApiGetInsertablesRequest {
	r.allowedApplicationMimeTypes = &allowedApplicationMimeTypes
	return r
}

func (r ApiGetInsertablesRequest) IncludeCompositeParts(includeCompositeParts bool) ApiGetInsertablesRequest {
	r.includeCompositeParts = &includeCompositeParts
	return r
}

func (r ApiGetInsertablesRequest) IncludeFSTables(includeFSTables bool) ApiGetInsertablesRequest {
	r.includeFSTables = &includeFSTables
	return r
}

func (r ApiGetInsertablesRequest) IncludeFSComputedPartPropertyFunctions(includeFSComputedPartPropertyFunctions bool) ApiGetInsertablesRequest {
	r.includeFSComputedPartPropertyFunctions = &includeFSComputedPartPropertyFunctions
	return r
}

func (r ApiGetInsertablesRequest) IncludeVariables(includeVariables bool) ApiGetInsertablesRequest {
	r.includeVariables = &includeVariables
	return r
}

func (r ApiGetInsertablesRequest) IncludeVariableStudios(includeVariableStudios bool) ApiGetInsertablesRequest {
	r.includeVariableStudios = &includeVariableStudios
	return r
}

func (r ApiGetInsertablesRequest) AllowedBlobExtensions(allowedBlobExtensions string) ApiGetInsertablesRequest {
	r.allowedBlobExtensions = &allowedBlobExtensions
	return r
}

func (r ApiGetInsertablesRequest) Execute() (*BTInsertablesListResponse, *http.Response, error) {
	return r.ApiService.GetInsertablesExecute(r)
}

/*
GetInsertables Retrieve insertables by document ID and workspace or version ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wv
 @param wvid
 @return ApiGetInsertablesRequest
*/
func (a *DocumentApiService) GetInsertables(ctx context.Context, did string, wv string, wvid string) ApiGetInsertablesRequest {
	return ApiGetInsertablesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wv:         wv,
		wvid:       wvid,
	}
}

// Execute executes the request
//  @return BTInsertablesListResponse
func (a *DocumentApiService) GetInsertablesExecute(r ApiGetInsertablesRequest) (*BTInsertablesListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTInsertablesListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.GetInsertables")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/d/{did}/{wv}/{wvid}/insertables"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wv"+"}", url.PathEscape(parameterToString(r.wv, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvid"+"}", url.PathEscape(parameterToString(r.wvid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.elementId != nil {
		localVarQueryParams.Add("elementId", parameterToString(*r.elementId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.betaCapabilityIds != nil {
		t := *r.betaCapabilityIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("betaCapabilityIds", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("betaCapabilityIds", parameterToString(t, "multi"))
		}
	}
	if r.includeParts != nil {
		localVarQueryParams.Add("includeParts", parameterToString(*r.includeParts, ""))
	}
	if r.includeSurfaces != nil {
		localVarQueryParams.Add("includeSurfaces", parameterToString(*r.includeSurfaces, ""))
	}
	if r.includeSketches != nil {
		localVarQueryParams.Add("includeSketches", parameterToString(*r.includeSketches, ""))
	}
	if r.includeReferenceFeatures != nil {
		localVarQueryParams.Add("includeReferenceFeatures", parameterToString(*r.includeReferenceFeatures, ""))
	}
	if r.includeAssemblies != nil {
		localVarQueryParams.Add("includeAssemblies", parameterToString(*r.includeAssemblies, ""))
	}
	if r.includeFeatureStudios != nil {
		localVarQueryParams.Add("includeFeatureStudios", parameterToString(*r.includeFeatureStudios, ""))
	}
	if r.includeBlobs != nil {
		localVarQueryParams.Add("includeBlobs", parameterToString(*r.includeBlobs, ""))
	}
	if r.allowedBlobMimeTypes != nil {
		localVarQueryParams.Add("allowedBlobMimeTypes", parameterToString(*r.allowedBlobMimeTypes, ""))
	}
	if r.excludeNewerFSVersions != nil {
		localVarQueryParams.Add("excludeNewerFSVersions", parameterToString(*r.excludeNewerFSVersions, ""))
	}
	if r.maxFeatureScriptVersion != nil {
		localVarQueryParams.Add("maxFeatureScriptVersion", parameterToString(*r.maxFeatureScriptVersion, ""))
	}
	if r.includePartStudios != nil {
		localVarQueryParams.Add("includePartStudios", parameterToString(*r.includePartStudios, ""))
	}
	if r.includeFeatures != nil {
		localVarQueryParams.Add("includeFeatures", parameterToString(*r.includeFeatures, ""))
	}
	if r.includeMeshes != nil {
		localVarQueryParams.Add("includeMeshes", parameterToString(*r.includeMeshes, ""))
	}
	if r.includeWires != nil {
		localVarQueryParams.Add("includeWires", parameterToString(*r.includeWires, ""))
	}
	if r.includeFlattenedBodies != nil {
		localVarQueryParams.Add("includeFlattenedBodies", parameterToString(*r.includeFlattenedBodies, ""))
	}
	if r.includeApplications != nil {
		localVarQueryParams.Add("includeApplications", parameterToString(*r.includeApplications, ""))
	}
	if r.allowedApplicationMimeTypes != nil {
		localVarQueryParams.Add("allowedApplicationMimeTypes", parameterToString(*r.allowedApplicationMimeTypes, ""))
	}
	if r.includeCompositeParts != nil {
		localVarQueryParams.Add("includeCompositeParts", parameterToString(*r.includeCompositeParts, ""))
	}
	if r.includeFSTables != nil {
		localVarQueryParams.Add("includeFSTables", parameterToString(*r.includeFSTables, ""))
	}
	if r.includeFSComputedPartPropertyFunctions != nil {
		localVarQueryParams.Add("includeFSComputedPartPropertyFunctions", parameterToString(*r.includeFSComputedPartPropertyFunctions, ""))
	}
	if r.includeVariables != nil {
		localVarQueryParams.Add("includeVariables", parameterToString(*r.includeVariables, ""))
	}
	if r.includeVariableStudios != nil {
		localVarQueryParams.Add("includeVariableStudios", parameterToString(*r.includeVariableStudios, ""))
	}
	if r.allowedBlobExtensions != nil {
		localVarQueryParams.Add("allowedBlobExtensions", parameterToString(*r.allowedBlobExtensions, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTInsertablesListResponse
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUnitInfoRequest struct {
	ctx            context.Context
	ApiService     *DocumentApiService
	did            string
	wvm            string
	wvmid          string
	linkDocumentId *string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetUnitInfoRequest) LinkDocumentId(linkDocumentId string) ApiGetUnitInfoRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetUnitInfoRequest) Execute() (*BTUnitInfo, *http.Response, error) {
	return r.ApiService.GetUnitInfoExecute(r)
}

/*
GetUnitInfo Get the selected units and precision by document ID and workspace or version or microversion ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace id, version id, or document microversion id is specified below.
 @param wvmid The id of the workspace, version, or document microversion in which the operation should be performed.
 @return ApiGetUnitInfoRequest
*/
func (a *DocumentApiService) GetUnitInfo(ctx context.Context, did string, wvm string, wvmid string) ApiGetUnitInfoRequest {
	return ApiGetUnitInfoRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
	}
}

// Execute executes the request
//  @return BTUnitInfo
func (a *DocumentApiService) GetUnitInfoExecute(r ApiGetUnitInfoRequest) (*BTUnitInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTUnitInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.GetUnitInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/d/{did}/{wvm}/{wvmid}/unitinfo"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTUnitInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVersionRequest struct {
	ctx            context.Context
	ApiService     *DocumentApiService
	did            string
	vid            string
	parents        *bool
	linkDocumentId *string
}

func (r ApiGetVersionRequest) Parents(parents bool) ApiGetVersionRequest {
	r.parents = &parents
	return r
}

func (r ApiGetVersionRequest) LinkDocumentId(linkDocumentId string) ApiGetVersionRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetVersionRequest) Execute() (*BTVersionInfo, *http.Response, error) {
	return r.ApiService.GetVersionExecute(r)
}

/*
GetVersion Retrieve version by document ID and version ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param vid
 @return ApiGetVersionRequest
*/
func (a *DocumentApiService) GetVersion(ctx context.Context, did string, vid string) ApiGetVersionRequest {
	return ApiGetVersionRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		vid:        vid,
	}
}

// Execute executes the request
//  @return BTVersionInfo
func (a *DocumentApiService) GetVersionExecute(r ApiGetVersionRequest) (*BTVersionInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTVersionInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.GetVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/d/{did}/versions/{vid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vid"+"}", url.PathEscape(parameterToString(r.vid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.parents != nil {
		localVarQueryParams.Add("parents", parameterToString(*r.parents, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMergeIntoWorkspaceRequest struct {
	ctx                           context.Context
	ApiService                    *DocumentApiService
	did                           string
	wid                           string
	bTVersionOrWorkspaceMergeInfo *BTVersionOrWorkspaceMergeInfo
}

func (r ApiMergeIntoWorkspaceRequest) BTVersionOrWorkspaceMergeInfo(bTVersionOrWorkspaceMergeInfo BTVersionOrWorkspaceMergeInfo) ApiMergeIntoWorkspaceRequest {
	r.bTVersionOrWorkspaceMergeInfo = &bTVersionOrWorkspaceMergeInfo
	return r
}

func (r ApiMergeIntoWorkspaceRequest) Execute() (*BTDocumentMergeInfo, *http.Response, error) {
	return r.ApiService.MergeIntoWorkspaceExecute(r)
}

/*
MergeIntoWorkspace Merge into workspace by document ID and workspace ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wid
 @return ApiMergeIntoWorkspaceRequest
*/
func (a *DocumentApiService) MergeIntoWorkspace(ctx context.Context, did string, wid string) ApiMergeIntoWorkspaceRequest {
	return ApiMergeIntoWorkspaceRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
	}
}

// Execute executes the request
//  @return BTDocumentMergeInfo
func (a *DocumentApiService) MergeIntoWorkspaceExecute(r ApiMergeIntoWorkspaceRequest) (*BTDocumentMergeInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTDocumentMergeInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.MergeIntoWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/{did}/workspaces/{wid}/merge"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTVersionOrWorkspaceMergeInfo == nil {
		return localVarReturnValue, nil, reportError("bTVersionOrWorkspaceMergeInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTVersionOrWorkspaceMergeInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTDocumentMergeInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMergePreviewRequest struct {
	ctx            context.Context
	ApiService     *DocumentApiService
	did            string
	wid            string
	sourceType     *string
	sourceId       *string
	linkDocumentId *string
}

func (r ApiMergePreviewRequest) SourceType(sourceType string) ApiMergePreviewRequest {
	r.sourceType = &sourceType
	return r
}

func (r ApiMergePreviewRequest) SourceId(sourceId string) ApiMergePreviewRequest {
	r.sourceId = &sourceId
	return r
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiMergePreviewRequest) LinkDocumentId(linkDocumentId string) ApiMergePreviewRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiMergePreviewRequest) Execute() (*BTMergePreviewInfo, *http.Response, error) {
	return r.ApiService.MergePreviewExecute(r)
}

/*
MergePreview Merge preview of changes that will occur based on document ID, workspace ID and source workspace/version ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wid The id of the workspace in which to perform the operation.
 @return ApiMergePreviewRequest
*/
func (a *DocumentApiService) MergePreview(ctx context.Context, did string, wid string) ApiMergePreviewRequest {
	return ApiMergePreviewRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
	}
}

// Execute executes the request
//  @return BTMergePreviewInfo
func (a *DocumentApiService) MergePreviewExecute(r ApiMergePreviewRequest) (*BTMergePreviewInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTMergePreviewInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.MergePreview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/{did}/w/{wid}/mergePreview"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sourceType == nil {
		return localVarReturnValue, nil, reportError("sourceType is required and must be specified")
	}
	if r.sourceId == nil {
		return localVarReturnValue, nil, reportError("sourceId is required and must be specified")
	}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	localVarQueryParams.Add("sourceType", parameterToString(*r.sourceType, ""))
	localVarQueryParams.Add("sourceId", parameterToString(*r.sourceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTMergePreviewInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoveElementsToDocumentRequest struct {
	ctx                 context.Context
	ApiService          *DocumentApiService
	did                 string
	wid                 string
	bTMoveElementParams *BTMoveElementParams
}

func (r ApiMoveElementsToDocumentRequest) BTMoveElementParams(bTMoveElementParams BTMoveElementParams) ApiMoveElementsToDocumentRequest {
	r.bTMoveElementParams = &bTMoveElementParams
	return r
}

func (r ApiMoveElementsToDocumentRequest) Execute() (*BTMoveElementInfo, *http.Response, error) {
	return r.ApiService.MoveElementsToDocumentExecute(r)
}

/*
MoveElementsToDocument Move tab by document ID and workspace ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wid
 @return ApiMoveElementsToDocumentRequest
*/
func (a *DocumentApiService) MoveElementsToDocument(ctx context.Context, did string, wid string) ApiMoveElementsToDocumentRequest {
	return ApiMoveElementsToDocumentRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
	}
}

// Execute executes the request
//  @return BTMoveElementInfo
func (a *DocumentApiService) MoveElementsToDocumentExecute(r ApiMoveElementsToDocumentRequest) (*BTMoveElementInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTMoveElementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.MoveElementsToDocument")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/d/{did}/w/{wid}/moveelement"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTMoveElementParams == nil {
		return localVarReturnValue, nil, reportError("bTMoveElementParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTMoveElementParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTMoveElementInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestoreFromHistoryRequest struct {
	ctx            context.Context
	ApiService     *DocumentApiService
	did            string
	wid            string
	vm             string
	vmid           string
	linkDocumentId *string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiRestoreFromHistoryRequest) LinkDocumentId(linkDocumentId string) ApiRestoreFromHistoryRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiRestoreFromHistoryRequest) Execute() (*BTRestoreFromHistoryInfo, *http.Response, error) {
	return r.ApiService.RestoreFromHistoryExecute(r)
}

/*
RestoreFromHistory Restore version or microversion to workspace by document ID, workspace ID, and version or microversion ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wid The id of the workspace in which to perform the operation.
 @param vm
 @param vmid
 @return ApiRestoreFromHistoryRequest
*/
func (a *DocumentApiService) RestoreFromHistory(ctx context.Context, did string, wid string, vm string, vmid string) ApiRestoreFromHistoryRequest {
	return ApiRestoreFromHistoryRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		vm:         vm,
		vmid:       vmid,
	}
}

// Execute executes the request
//  @return BTRestoreFromHistoryInfo
func (a *DocumentApiService) RestoreFromHistoryExecute(r ApiRestoreFromHistoryRequest) (*BTRestoreFromHistoryInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTRestoreFromHistoryInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.RestoreFromHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/{did}/w/{wid}/restore/{vm}/{vmid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vm"+"}", url.PathEscape(parameterToString(r.vm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmid"+"}", url.PathEscape(parameterToString(r.vmid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTRestoreFromHistoryInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRevertUnchangedToRevisionsRequest struct {
	ctx                     context.Context
	ApiService              *DocumentApiService
	did                     string
	wid                     string
	bTRevertUnchangedParams *BTRevertUnchangedParams
}

func (r ApiRevertUnchangedToRevisionsRequest) BTRevertUnchangedParams(bTRevertUnchangedParams BTRevertUnchangedParams) ApiRevertUnchangedToRevisionsRequest {
	r.bTRevertUnchangedParams = &bTRevertUnchangedParams
	return r
}

func (r ApiRevertUnchangedToRevisionsRequest) Execute() ([]BTUnchangedElementInfo, *http.Response, error) {
	return r.ApiService.RevertUnchangedToRevisionsExecute(r)
}

/*
RevertUnchangedToRevisions Method for RevertUnchangedToRevisions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wid
 @return ApiRevertUnchangedToRevisionsRequest
*/
func (a *DocumentApiService) RevertUnchangedToRevisions(ctx context.Context, did string, wid string) ApiRevertUnchangedToRevisionsRequest {
	return ApiRevertUnchangedToRevisionsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
	}
}

// Execute executes the request
//  @return []BTUnchangedElementInfo
func (a *DocumentApiService) RevertUnchangedToRevisionsExecute(r ApiRevertUnchangedToRevisionsRequest) ([]BTUnchangedElementInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []BTUnchangedElementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.RevertUnchangedToRevisions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/d/{did}/w/{wid}/revertunchangedtorevisions"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTRevertUnchangedParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v []BTUnchangedElementInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchRequest struct {
	ctx                    context.Context
	ApiService             *DocumentApiService
	bTDocumentSearchParams *BTDocumentSearchParams
}

func (r ApiSearchRequest) BTDocumentSearchParams(bTDocumentSearchParams BTDocumentSearchParams) ApiSearchRequest {
	r.bTDocumentSearchParams = &bTDocumentSearchParams
	return r
}

func (r ApiSearchRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SearchExecute(r)
}

/*
Search Search document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchRequest
*/
func (a *DocumentApiService) Search(ctx context.Context) ApiSearchRequest {
	return ApiSearchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DocumentApiService) SearchExecute(r ApiSearchRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.Search")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTDocumentSearchParams == nil {
		return localVarReturnValue, nil, reportError("bTDocumentSearchParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTDocumentSearchParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShareDocumentRequest struct {
	ctx           context.Context
	ApiService    *DocumentApiService
	did           string
	bTShareParams *BTShareParams
}

func (r ApiShareDocumentRequest) BTShareParams(bTShareParams BTShareParams) ApiShareDocumentRequest {
	r.bTShareParams = &bTShareParams
	return r
}

func (r ApiShareDocumentRequest) Execute() (*BTAclInfo, *http.Response, error) {
	return r.ApiService.ShareDocumentExecute(r)
}

/*
ShareDocument Share document by document ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @return ApiShareDocumentRequest
*/
func (a *DocumentApiService) ShareDocument(ctx context.Context, did string) ApiShareDocumentRequest {
	return ApiShareDocumentRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
	}
}

// Execute executes the request
//  @return BTAclInfo
func (a *DocumentApiService) ShareDocumentExecute(r ApiShareDocumentRequest) (*BTAclInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTAclInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.ShareDocument")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/{did}/share"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTShareParams == nil {
		return localVarReturnValue, nil, reportError("bTShareParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTShareParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTAclInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShareWithSupportRequest struct {
	ctx        context.Context
	ApiService *DocumentApiService
	did        string
}

func (r ApiShareWithSupportRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ShareWithSupportExecute(r)
}

/*
ShareWithSupport Share document by document ID with Onshape support.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did Document ID.
 @return ApiShareWithSupportRequest
*/
func (a *DocumentApiService) ShareWithSupport(ctx context.Context, did string) ApiShareWithSupportRequest {
	return ApiShareWithSupportRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DocumentApiService) ShareWithSupportExecute(r ApiShareWithSupportRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.ShareWithSupport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/{did}/shareWithSupport"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSyncApplicationElementsRequest struct {
	ctx                    context.Context
	ApiService             *DocumentApiService
	did                    string
	wid                    string
	bTSyncAppElementParams *BTSyncAppElementParams
}

func (r ApiSyncApplicationElementsRequest) BTSyncAppElementParams(bTSyncAppElementParams BTSyncAppElementParams) ApiSyncApplicationElementsRequest {
	r.bTSyncAppElementParams = &bTSyncAppElementParams
	return r
}

func (r ApiSyncApplicationElementsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SyncApplicationElementsExecute(r)
}

/*
SyncApplicationElements Method for SyncApplicationElements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wid
 @return ApiSyncApplicationElementsRequest
*/
func (a *DocumentApiService) SyncApplicationElements(ctx context.Context, did string, wid string) ApiSyncApplicationElementsRequest {
	return ApiSyncApplicationElementsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DocumentApiService) SyncApplicationElementsExecute(r ApiSyncApplicationElementsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.SyncApplicationElements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/d/{did}/w/{wid}/syncAppElements"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTSyncAppElementParams == nil {
		return localVarReturnValue, nil, reportError("bTSyncAppElementParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTSyncAppElementParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnShareDocumentRequest struct {
	ctx        context.Context
	ApiService *DocumentApiService
	did        string
	eid        string
	entryType  *int32
}

func (r ApiUnShareDocumentRequest) EntryType(entryType int32) ApiUnShareDocumentRequest {
	r.entryType = &entryType
	return r
}

func (r ApiUnShareDocumentRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UnShareDocumentExecute(r)
}

/*
UnShareDocument Unshare document by document ID and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param eid
 @return ApiUnShareDocumentRequest
*/
func (a *DocumentApiService) UnShareDocument(ctx context.Context, did string, eid string) ApiUnShareDocumentRequest {
	return ApiUnShareDocumentRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DocumentApiService) UnShareDocumentExecute(r ApiUnShareDocumentRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.UnShareDocument")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/{did}/share/{eid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.entryType != nil {
		localVarQueryParams.Add("entryType", parameterToString(*r.entryType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnshareFromSupportRequest struct {
	ctx        context.Context
	ApiService *DocumentApiService
	did        string
}

func (r ApiUnshareFromSupportRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UnshareFromSupportExecute(r)
}

/*
UnshareFromSupport Unshare document with support.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did Document ID.
 @return ApiUnshareFromSupportRequest
*/
func (a *DocumentApiService) UnshareFromSupport(ctx context.Context, did string) ApiUnshareFromSupportRequest {
	return ApiUnshareFromSupportRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DocumentApiService) UnshareFromSupportExecute(r ApiUnshareFromSupportRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.UnshareFromSupport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/{did}/shareWithSupport"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDocumentAttributesRequest struct {
	ctx              context.Context
	ApiService       *DocumentApiService
	did              string
	bTDocumentParams *BTDocumentParams
}

func (r ApiUpdateDocumentAttributesRequest) BTDocumentParams(bTDocumentParams BTDocumentParams) ApiUpdateDocumentAttributesRequest {
	r.bTDocumentParams = &bTDocumentParams
	return r
}

func (r ApiUpdateDocumentAttributesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateDocumentAttributesExecute(r)
}

/*
UpdateDocumentAttributes Update document attributes by document ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @return ApiUpdateDocumentAttributesRequest
*/
func (a *DocumentApiService) UpdateDocumentAttributes(ctx context.Context, did string) ApiUpdateDocumentAttributesRequest {
	return ApiUpdateDocumentAttributesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DocumentApiService) UpdateDocumentAttributesExecute(r ApiUpdateDocumentAttributesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.UpdateDocumentAttributes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/{did}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTDocumentParams == nil {
		return localVarReturnValue, nil, reportError("bTDocumentParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTDocumentParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateExternalReferencesToLatestDocumentsRequest struct {
	ctx                          context.Context
	ApiService                   *DocumentApiService
	did                          string
	wid                          string
	eid                          string
	bTLinkToLatestDocumentParams *BTLinkToLatestDocumentParams
}

func (r ApiUpdateExternalReferencesToLatestDocumentsRequest) BTLinkToLatestDocumentParams(bTLinkToLatestDocumentParams BTLinkToLatestDocumentParams) ApiUpdateExternalReferencesToLatestDocumentsRequest {
	r.bTLinkToLatestDocumentParams = &bTLinkToLatestDocumentParams
	return r
}

func (r ApiUpdateExternalReferencesToLatestDocumentsRequest) Execute() (*BTLinkToLatestDocumentInfo, *http.Response, error) {
	return r.ApiService.UpdateExternalReferencesToLatestDocumentsExecute(r)
}

/*
UpdateExternalReferencesToLatestDocuments Update external references to latest by document ID, workspace ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wid
 @param eid
 @return ApiUpdateExternalReferencesToLatestDocumentsRequest
*/
func (a *DocumentApiService) UpdateExternalReferencesToLatestDocuments(ctx context.Context, did string, wid string, eid string) ApiUpdateExternalReferencesToLatestDocumentsRequest {
	return ApiUpdateExternalReferencesToLatestDocumentsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTLinkToLatestDocumentInfo
func (a *DocumentApiService) UpdateExternalReferencesToLatestDocumentsExecute(r ApiUpdateExternalReferencesToLatestDocumentsRequest) (*BTLinkToLatestDocumentInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTLinkToLatestDocumentInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.UpdateExternalReferencesToLatestDocuments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/documents/d/{did}/w/{wid}/e/{eid}/latestdocumentreferences"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTLinkToLatestDocumentParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
