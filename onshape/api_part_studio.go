/*
Onshape REST API

## Welcome to the Onshape REST API Explorer  To use this API explorer, sign in to your [Onshape](https://cad.onshape.com) account in another tab, then click the **Try it out** button below (it toggles to a **Cancel** button when selected).  See the **[API Explorer Guide](https://onshape-public.github.io/docs/api-intro/explorer/)** for help navigating this API Explorer, including **[authentication](https://onshape-public.github.io/docs/api-intro/explorer/#authentication)**.  **Tip:** To ensure the current session isn't used when trying other authentication techniques, make sure to [remove the Onshape cookie](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site) as per the instructions for your browser. Alternatively, you can use a private or incognito window.  ## See Also  * [Onshape API Guide](https://onshape-public.github.io/docs/): Our full suite of developer guides, to be used as an accompaniment to this API Explorer. * [Onshape Developer Portal](https://dev-portal.onshape.com/): The Onshape portal for managing your API keys, OAuth2 credentials, your Onshape applications, and your Onshape App Store entries. * [Authentication Guide](https://onshape-public.github.io/docs/auth/): Our guide to using API keys, request signatures, and OAuth2 in  your Onshape applications.

Contact: api-support@onshape.zendesk.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package onshape

import (
	"context"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// PartStudioApiService PartStudioApi service
type PartStudioApiService service

type ApiAddPartStudioFeatureRequest struct {
	ctx                         context.Context
	ApiService                  *PartStudioApiService
	did                         string
	wvm                         string
	wvmid                       string
	eid                         string
	bTFeatureDefinitionCall1406 *BTFeatureDefinitionCall1406
}

func (r ApiAddPartStudioFeatureRequest) BTFeatureDefinitionCall1406(bTFeatureDefinitionCall1406 BTFeatureDefinitionCall1406) ApiAddPartStudioFeatureRequest {
	r.bTFeatureDefinitionCall1406 = &bTFeatureDefinitionCall1406
	return r
}

func (r ApiAddPartStudioFeatureRequest) Execute() (*BTFeatureDefinitionResponse1617, *http.Response, error) {
	return r.ApiService.AddPartStudioFeatureExecute(r)
}

/*
AddPartStudioFeature Add a feature to the Part Studio's Feature List.

The feature is added immediately before the rollback bar. Any geometry IDs specified in the feature must be valid at that point in the feature tree.

See the [Features API Guide](https://onshape-public.github.io/docs/api-adv/featureaccess/) for additional information.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param wvm
	@param wvmid
	@param eid
	@return ApiAddPartStudioFeatureRequest
*/
func (a *PartStudioApiService) AddPartStudioFeature(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiAddPartStudioFeatureRequest {
	return ApiAddPartStudioFeatureRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTFeatureDefinitionResponse1617
func (a *PartStudioApiService) AddPartStudioFeatureExecute(r ApiAddPartStudioFeatureRequest) (*BTFeatureDefinitionResponse1617, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTFeatureDefinitionResponse1617
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.AddPartStudioFeature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTFeatureDefinitionCall1406
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTFeatureDefinitionResponse1617
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComparePartStudiosRequest struct {
	ctx                 context.Context
	ApiService          *PartStudioApiService
	did                 string
	wvm                 string
	wvmid               string
	eid                 string
	workspaceId         *string
	versionId           *string
	microversionId      *string
	sourceConfiguration *string
	targetConfiguration *string
	linkDocumentId      *string
}

func (r ApiComparePartStudiosRequest) WorkspaceId(workspaceId string) ApiComparePartStudiosRequest {
	r.workspaceId = &workspaceId
	return r
}

func (r ApiComparePartStudiosRequest) VersionId(versionId string) ApiComparePartStudiosRequest {
	r.versionId = &versionId
	return r
}

func (r ApiComparePartStudiosRequest) MicroversionId(microversionId string) ApiComparePartStudiosRequest {
	r.microversionId = &microversionId
	return r
}

func (r ApiComparePartStudiosRequest) SourceConfiguration(sourceConfiguration string) ApiComparePartStudiosRequest {
	r.sourceConfiguration = &sourceConfiguration
	return r
}

func (r ApiComparePartStudiosRequest) TargetConfiguration(targetConfiguration string) ApiComparePartStudiosRequest {
	r.targetConfiguration = &targetConfiguration
	return r
}

func (r ApiComparePartStudiosRequest) LinkDocumentId(linkDocumentId string) ApiComparePartStudiosRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiComparePartStudiosRequest) Execute() (*BTRootDiffInfo, *http.Response, error) {
	return r.ApiService.ComparePartStudiosExecute(r)
}

/*
ComparePartStudios Get the differences between two Part Studios in a single document.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did Document ID.
	@param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
	@param wvmid Workspace (w), Version (v) or Microversion (m) ID.
	@param eid Element ID.
	@return ApiComparePartStudiosRequest
*/
func (a *PartStudioApiService) ComparePartStudios(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiComparePartStudiosRequest {
	return ApiComparePartStudiosRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTRootDiffInfo
func (a *PartStudioApiService) ComparePartStudiosExecute(r ApiComparePartStudiosRequest) (*BTRootDiffInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTRootDiffInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.ComparePartStudios")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/compare"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.workspaceId != nil {
		localVarQueryParams.Add("workspaceId", parameterToString(*r.workspaceId, ""))
	}
	if r.versionId != nil {
		localVarQueryParams.Add("versionId", parameterToString(*r.versionId, ""))
	}
	if r.microversionId != nil {
		localVarQueryParams.Add("microversionId", parameterToString(*r.microversionId, ""))
	}
	if r.sourceConfiguration != nil {
		localVarQueryParams.Add("sourceConfiguration", parameterToString(*r.sourceConfiguration, ""))
	}
	if r.targetConfiguration != nil {
		localVarQueryParams.Add("targetConfiguration", parameterToString(*r.targetConfiguration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTRootDiffInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePartStudioRequest struct {
	ctx                  context.Context
	ApiService           *PartStudioApiService
	did                  string
	wid                  string
	bTModelElementParams *BTModelElementParams
}

func (r ApiCreatePartStudioRequest) BTModelElementParams(bTModelElementParams BTModelElementParams) ApiCreatePartStudioRequest {
	r.bTModelElementParams = &bTModelElementParams
	return r
}

func (r ApiCreatePartStudioRequest) Execute() (*BTDocumentElementInfo, *http.Response, error) {
	return r.ApiService.CreatePartStudioExecute(r)
}

/*
CreatePartStudio Create a new Part Studio in a document.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did Document ID.
	@param wid Workspace ID.
	@return ApiCreatePartStudioRequest
*/
func (a *PartStudioApiService) CreatePartStudio(ctx context.Context, did string, wid string) ApiCreatePartStudioRequest {
	return ApiCreatePartStudioRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
	}
}

// Execute executes the request
//
//	@return BTDocumentElementInfo
func (a *PartStudioApiService) CreatePartStudioExecute(r ApiCreatePartStudioRequest) (*BTDocumentElementInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTDocumentElementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.CreatePartStudio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/w/{wid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTModelElementParams == nil {
		return localVarReturnValue, nil, reportError("bTModelElementParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTModelElementParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTDocumentElementInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePartStudioTranslationRequest struct {
	ctx                     context.Context
	ApiService              *PartStudioApiService
	did                     string
	wv                      string
	wvid                    string
	eid                     string
	bTTranslateFormatParams *BTTranslateFormatParams
}

func (r ApiCreatePartStudioTranslationRequest) BTTranslateFormatParams(bTTranslateFormatParams BTTranslateFormatParams) ApiCreatePartStudioTranslationRequest {
	r.bTTranslateFormatParams = &bTTranslateFormatParams
	return r
}

func (r ApiCreatePartStudioTranslationRequest) Execute() (*BTTranslationRequestInfo, *http.Response, error) {
	return r.ApiService.CreatePartStudioTranslationExecute(r)
}

/*
CreatePartStudioTranslation Export a Part Studio to another format.

* Use `formatName` in the JSON request body to specify the export file type. Use [Translations/getAllTranslatorFormats](https://cad.onshape.com/glassworks/explorer/#/Translation/getAllTranslatorFormats) to get a list of valid export file formats. `
* Set `storeInDocument` to `true` to export to a data file. Set to `false` to export to a blob element in the same document.
* See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/) for more details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did Document ID.
	@param wv One of w or v corresponding to whether a workspace or version was specified.
	@param wvid Workspace (w) or Version (v) ID.
	@param eid Element ID.
	@return ApiCreatePartStudioTranslationRequest
*/
func (a *PartStudioApiService) CreatePartStudioTranslation(ctx context.Context, did string, wv string, wvid string, eid string) ApiCreatePartStudioTranslationRequest {
	return ApiCreatePartStudioTranslationRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wv:         wv,
		wvid:       wvid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTTranslationRequestInfo
func (a *PartStudioApiService) CreatePartStudioTranslationExecute(r ApiCreatePartStudioTranslationRequest) (*BTTranslationRequestInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTTranslationRequestInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.CreatePartStudioTranslation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wv}/{wvid}/e/{eid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wv"+"}", url.PathEscape(parameterToString(r.wv, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvid"+"}", url.PathEscape(parameterToString(r.wvid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTTranslateFormatParams == nil {
		return localVarReturnValue, nil, reportError("bTTranslateFormatParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTTranslateFormatParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTTranslationRequestInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePartStudioFeatureRequest struct {
	ctx        context.Context
	ApiService *PartStudioApiService
	did        string
	wid        string
	eid        string
	fid        string
}

func (r ApiDeletePartStudioFeatureRequest) Execute() (*BTFeatureApiBase1430, *http.Response, error) {
	return r.ApiService.DeletePartStudioFeatureExecute(r)
}

/*
DeletePartStudioFeature Delete a Part Studio feature.

See the [Features API Guide](https://onshape-public.github.io/docs/api-adv/featureaccess/) for additional information.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did Document ID.
	@param wid Workspace ID.
	@param eid Element ID.
	@param fid The id of the feature being updated. This id should be URL encoded and must match the featureId found in the serialized structure
	@return ApiDeletePartStudioFeatureRequest
*/
func (a *PartStudioApiService) DeletePartStudioFeature(ctx context.Context, did string, wid string, eid string, fid string) ApiDeletePartStudioFeatureRequest {
	return ApiDeletePartStudioFeatureRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
		fid:        fid,
	}
}

// Execute executes the request
//
//	@return BTFeatureApiBase1430
func (a *PartStudioApiService) DeletePartStudioFeatureExecute(r ApiDeletePartStudioFeatureRequest) (*BTFeatureApiBase1430, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTFeatureApiBase1430
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.DeletePartStudioFeature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/w/{wid}/e/{eid}/features/featureid/{fid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fid"+"}", url.PathEscape(parameterToString(r.fid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTFeatureApiBase1430
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEvalFeatureScriptRequest struct {
	ctx                         context.Context
	ApiService                  *PartStudioApiService
	did                         string
	wvm                         string
	wvmid                       string
	eid                         string
	linkDocumentId              *string
	configuration               *string
	rollbackBarIndex            *int32
	elementMicroversionId       *string
	bTFeatureScriptEvalCall2377 *BTFeatureScriptEvalCall2377
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiEvalFeatureScriptRequest) LinkDocumentId(linkDocumentId string) ApiEvalFeatureScriptRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;) for the feature definition.
func (r ApiEvalFeatureScriptRequest) Configuration(configuration string) ApiEvalFeatureScriptRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiEvalFeatureScriptRequest) RollbackBarIndex(rollbackBarIndex int32) ApiEvalFeatureScriptRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

// A specific element microversion in which to evaluate the request.
func (r ApiEvalFeatureScriptRequest) ElementMicroversionId(elementMicroversionId string) ApiEvalFeatureScriptRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiEvalFeatureScriptRequest) BTFeatureScriptEvalCall2377(bTFeatureScriptEvalCall2377 BTFeatureScriptEvalCall2377) ApiEvalFeatureScriptRequest {
	r.bTFeatureScriptEvalCall2377 = &bTFeatureScriptEvalCall2377
	return r
}

func (r ApiEvalFeatureScriptRequest) Execute() (*BTFeatureScriptEvalResponse1859, *http.Response, error) {
	return r.ApiService.EvalFeatureScriptExecute(r)
}

/*
EvalFeatureScript Evaluate the FeatureScript snippet for a Part Studio.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiEvalFeatureScriptRequest
*/
func (a *PartStudioApiService) EvalFeatureScript(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiEvalFeatureScriptRequest {
	return ApiEvalFeatureScriptRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTFeatureScriptEvalResponse1859
func (a *PartStudioApiService) EvalFeatureScriptExecute(r ApiEvalFeatureScriptRequest) (*BTFeatureScriptEvalResponse1859, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTFeatureScriptEvalResponse1859
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.EvalFeatureScript")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/featurescript"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTFeatureScriptEvalCall2377
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTFeatureScriptEvalResponse1859
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportParasolidRequest struct {
	ctx              context.Context
	ApiService       *PartStudioApiService
	did              string
	wvm              string
	wvmid            string
	eid              string
	partIds          *string
	version          *string
	includeExportIds *bool
	configuration    *string
	linkDocumentId   *string
	binaryExport     *bool
}

// IDs of the parts to retrieve. Use comma-separated IDs for multiple parts (example: partIds&#x3D;JHK,JHD).
func (r ApiExportParasolidRequest) PartIds(partIds string) ApiExportParasolidRequest {
	r.partIds = &partIds
	return r
}

// Parasolid version
func (r ApiExportParasolidRequest) Version(version string) ApiExportParasolidRequest {
	r.version = &version
	return r
}

// Whether topology ids should be exported as parasolid attributes
func (r ApiExportParasolidRequest) IncludeExportIds(includeExportIds bool) ApiExportParasolidRequest {
	r.includeExportIds = &includeExportIds
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;) for the feature definition.
func (r ApiExportParasolidRequest) Configuration(configuration string) ApiExportParasolidRequest {
	r.configuration = &configuration
	return r
}

// Id of document that links to the document being accessed. This may provide additional access rights to the document. Allowed only with version (v) path parameter.
func (r ApiExportParasolidRequest) LinkDocumentId(linkDocumentId string) ApiExportParasolidRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// Whether to use binary parasolid format instead of text
func (r ApiExportParasolidRequest) BinaryExport(binaryExport bool) ApiExportParasolidRequest {
	r.binaryExport = &binaryExport
	return r
}

func (r ApiExportParasolidRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExportParasolidExecute(r)
}

/*
ExportParasolid Export the Part Studio as a Parasolid file.

Returns a 307 redirect from which to download the exported file. See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/) for more details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did Document ID.
	@param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
	@param wvmid Workspace (w), Version (v) or Microversion (m) ID.
	@param eid Element ID.
	@return ApiExportParasolidRequest
*/
func (a *PartStudioApiService) ExportParasolid(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiExportParasolidRequest {
	return ApiExportParasolidRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
func (a *PartStudioApiService) ExportParasolidExecute(r ApiExportParasolidRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.ExportParasolid")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/parasolid"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.partIds != nil {
		localVarQueryParams.Add("partIds", parameterToString(*r.partIds, ""))
	}
	if r.version != nil {
		localVarQueryParams.Add("version", parameterToString(*r.version, ""))
	}
	if r.includeExportIds != nil {
		localVarQueryParams.Add("includeExportIds", parameterToString(*r.includeExportIds, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.binaryExport != nil {
		localVarQueryParams.Add("binaryExport", parameterToString(*r.binaryExport, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExportPartStudioGltfRequest struct {
	ctx                      context.Context
	ApiService               *PartStudioApiService
	did                      string
	wvm                      string
	wvmid                    string
	eid                      string
	linkDocumentId           *string
	configuration            *string
	rollbackBarIndex         *int32
	elementMicroversionId    *string
	partId                   *[]string
	angleTolerance           *float64
	chordTolerance           *float64
	precomputedLevelOfDetail *string
	outputSeparateFaceNodes  *bool
	faceId                   *[]string
	outputFaceAppearances    *bool
	maxFacetWidth            *float64
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiExportPartStudioGltfRequest) LinkDocumentId(linkDocumentId string) ApiExportPartStudioGltfRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;) for the feature definition.
func (r ApiExportPartStudioGltfRequest) Configuration(configuration string) ApiExportPartStudioGltfRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiExportPartStudioGltfRequest) RollbackBarIndex(rollbackBarIndex int32) ApiExportPartStudioGltfRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

// A specific element microversion in which to evaluate the request.
func (r ApiExportPartStudioGltfRequest) ElementMicroversionId(elementMicroversionId string) ApiExportPartStudioGltfRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiExportPartStudioGltfRequest) PartId(partId []string) ApiExportPartStudioGltfRequest {
	r.partId = &partId
	return r
}

func (r ApiExportPartStudioGltfRequest) AngleTolerance(angleTolerance float64) ApiExportPartStudioGltfRequest {
	r.angleTolerance = &angleTolerance
	return r
}

func (r ApiExportPartStudioGltfRequest) ChordTolerance(chordTolerance float64) ApiExportPartStudioGltfRequest {
	r.chordTolerance = &chordTolerance
	return r
}

func (r ApiExportPartStudioGltfRequest) PrecomputedLevelOfDetail(precomputedLevelOfDetail string) ApiExportPartStudioGltfRequest {
	r.precomputedLevelOfDetail = &precomputedLevelOfDetail
	return r
}

func (r ApiExportPartStudioGltfRequest) OutputSeparateFaceNodes(outputSeparateFaceNodes bool) ApiExportPartStudioGltfRequest {
	r.outputSeparateFaceNodes = &outputSeparateFaceNodes
	return r
}

func (r ApiExportPartStudioGltfRequest) FaceId(faceId []string) ApiExportPartStudioGltfRequest {
	r.faceId = &faceId
	return r
}

func (r ApiExportPartStudioGltfRequest) OutputFaceAppearances(outputFaceAppearances bool) ApiExportPartStudioGltfRequest {
	r.outputFaceAppearances = &outputFaceAppearances
	return r
}

func (r ApiExportPartStudioGltfRequest) MaxFacetWidth(maxFacetWidth float64) ApiExportPartStudioGltfRequest {
	r.maxFacetWidth = &maxFacetWidth
	return r
}

func (r ApiExportPartStudioGltfRequest) Execute() (*GlTF, *http.Response, error) {
	return r.ApiService.ExportPartStudioGltfExecute(r)
}

/*
ExportPartStudioGltf Export the Part Studio as a glTF file.

Returns the glTF representation. See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiExportPartStudioGltfRequest
*/
func (a *PartStudioApiService) ExportPartStudioGltf(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiExportPartStudioGltfRequest {
	return ApiExportPartStudioGltfRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return GlTF
func (a *PartStudioApiService) ExportPartStudioGltfExecute(r ApiExportPartStudioGltfRequest) (*GlTF, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GlTF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.ExportPartStudioGltf")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/gltf"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	if r.partId != nil {
		t := *r.partId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("partId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("partId", parameterToString(t, "multi"))
		}
	}
	if r.angleTolerance != nil {
		localVarQueryParams.Add("angleTolerance", parameterToString(*r.angleTolerance, ""))
	}
	if r.chordTolerance != nil {
		localVarQueryParams.Add("chordTolerance", parameterToString(*r.chordTolerance, ""))
	}
	if r.precomputedLevelOfDetail != nil {
		localVarQueryParams.Add("precomputedLevelOfDetail", parameterToString(*r.precomputedLevelOfDetail, ""))
	}
	if r.outputSeparateFaceNodes != nil {
		localVarQueryParams.Add("outputSeparateFaceNodes", parameterToString(*r.outputSeparateFaceNodes, ""))
	}
	if r.faceId != nil {
		t := *r.faceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("faceId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("faceId", parameterToString(t, "multi"))
		}
	}
	if r.outputFaceAppearances != nil {
		localVarQueryParams.Add("outputFaceAppearances", parameterToString(*r.outputFaceAppearances, ""))
	}
	if r.maxFacetWidth != nil {
		localVarQueryParams.Add("maxFacetWidth", parameterToString(*r.maxFacetWidth, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"model/gltf+json;charset=UTF-8;qs=0.08", "model/gltf-binary;qs=0.08"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportPartStudioStlRequest struct {
	ctx            context.Context
	ApiService     *PartStudioApiService
	did            string
	wvm            string
	wvmid          string
	eid            string
	partIds        *string
	mode           *string
	grouping       *bool
	scale          *float64
	units          *string
	angleTolerance *float64
	chordTolerance *float64
	maxFacetWidth  *float64
	minFacetWidth  *float64
	configuration  *string
	linkDocumentId *string
}

// IDs of the parts to retrieve. Use comma-separated IDs for multiple parts (example: partIds&#x3D;JHK,JHD).
func (r ApiExportPartStudioStlRequest) PartIds(partIds string) ApiExportPartStudioStlRequest {
	r.partIds = &partIds
	return r
}

// Type of file: text, binary
func (r ApiExportPartStudioStlRequest) Mode(mode string) ApiExportPartStudioStlRequest {
	r.mode = &mode
	return r
}

// Whether parts should be exported as a group or individually in a .zip file
func (r ApiExportPartStudioStlRequest) Grouping(grouping bool) ApiExportPartStudioStlRequest {
	r.grouping = &grouping
	return r
}

// Scale for measurements.
func (r ApiExportPartStudioStlRequest) Scale(scale float64) ApiExportPartStudioStlRequest {
	r.scale = &scale
	return r
}

// Units for the element: &#x60;METER&#x60; | &#x60;CENTIMETER&#x60; | &#x60;MILLIMETER&#x60; | &#x60;INCH&#x60; | &#x60;FOOT&#x60; | &#x60;YARD&#x60;
func (r ApiExportPartStudioStlRequest) Units(units string) ApiExportPartStudioStlRequest {
	r.units = &units
	return r
}

// Angle tolerance (in radians). This specifies the limit on the sum of the angular deviations of a tessellation chord from the tangent vectors at two chord endpoints. The specified value must be less than PI/2. This parameter currently has a default value chosen based on the complexity of the parts being tessellated.
func (r ApiExportPartStudioStlRequest) AngleTolerance(angleTolerance float64) ApiExportPartStudioStlRequest {
	r.angleTolerance = &angleTolerance
	return r
}

// Chord tolerance (in meters). This specifies the limit on the maximum deviation of a tessellation chord from the true surface/edge. This parameter currently has a default value chosen based on the size and complexity of the parts being tessellated.
func (r ApiExportPartStudioStlRequest) ChordTolerance(chordTolerance float64) ApiExportPartStudioStlRequest {
	r.chordTolerance = &chordTolerance
	return r
}

// Max facet width. This specifies the limit on the size of any side of a tessellation facet.
func (r ApiExportPartStudioStlRequest) MaxFacetWidth(maxFacetWidth float64) ApiExportPartStudioStlRequest {
	r.maxFacetWidth = &maxFacetWidth
	return r
}

// Max facet width. This specifies the limit on the size of any side of a tessellation facet.
func (r ApiExportPartStudioStlRequest) MinFacetWidth(minFacetWidth float64) ApiExportPartStudioStlRequest {
	r.minFacetWidth = &minFacetWidth
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;) for the feature definition.
func (r ApiExportPartStudioStlRequest) Configuration(configuration string) ApiExportPartStudioStlRequest {
	r.configuration = &configuration
	return r
}

// Id of document that links to the document being accessed. This may provide additional access rights to the document. Allowed only with version (v) path parameter.
func (r ApiExportPartStudioStlRequest) LinkDocumentId(linkDocumentId string) ApiExportPartStudioStlRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiExportPartStudioStlRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExportPartStudioStlExecute(r)
}

/*
ExportPartStudioStl Export the Part Studio as an STL file.

Returns a 307 redirect from which to download the exported file. See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did Document ID.
	@param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
	@param wvmid Workspace (w), Version (v) or Microversion (m) ID.
	@param eid Element ID.
	@return ApiExportPartStudioStlRequest
*/
func (a *PartStudioApiService) ExportPartStudioStl(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiExportPartStudioStlRequest {
	return ApiExportPartStudioStlRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
func (a *PartStudioApiService) ExportPartStudioStlExecute(r ApiExportPartStudioStlRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.ExportPartStudioStl")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/stl"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.partIds != nil {
		localVarQueryParams.Add("partIds", parameterToString(*r.partIds, ""))
	}
	if r.mode != nil {
		localVarQueryParams.Add("mode", parameterToString(*r.mode, ""))
	}
	if r.grouping != nil {
		localVarQueryParams.Add("grouping", parameterToString(*r.grouping, ""))
	}
	if r.scale != nil {
		localVarQueryParams.Add("scale", parameterToString(*r.scale, ""))
	}
	if r.units != nil {
		localVarQueryParams.Add("units", parameterToString(*r.units, ""))
	}
	if r.angleTolerance != nil {
		localVarQueryParams.Add("angleTolerance", parameterToString(*r.angleTolerance, ""))
	}
	if r.chordTolerance != nil {
		localVarQueryParams.Add("chordTolerance", parameterToString(*r.chordTolerance, ""))
	}
	if r.maxFacetWidth != nil {
		localVarQueryParams.Add("maxFacetWidth", parameterToString(*r.maxFacetWidth, ""))
	}
	if r.minFacetWidth != nil {
		localVarQueryParams.Add("minFacetWidth", parameterToString(*r.minFacetWidth, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetFeatureScriptRepresentationRequest struct {
	ctx                   context.Context
	ApiService            *PartStudioApiService
	did                   string
	wvm                   string
	wvmid                 string
	eid                   string
	linkDocumentId        *string
	configuration         *string
	rollbackBarIndex      *int32
	elementMicroversionId *string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetFeatureScriptRepresentationRequest) LinkDocumentId(linkDocumentId string) ApiGetFeatureScriptRepresentationRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;) for the feature definition.
func (r ApiGetFeatureScriptRepresentationRequest) Configuration(configuration string) ApiGetFeatureScriptRepresentationRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiGetFeatureScriptRepresentationRequest) RollbackBarIndex(rollbackBarIndex int32) ApiGetFeatureScriptRepresentationRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

// A specific element microversion in which to evaluate the request.
func (r ApiGetFeatureScriptRepresentationRequest) ElementMicroversionId(elementMicroversionId string) ApiGetFeatureScriptRepresentationRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiGetFeatureScriptRepresentationRequest) Execute() (*BTPModule234, *http.Response, error) {
	return r.ApiService.GetFeatureScriptRepresentationExecute(r)
}

/*
GetFeatureScriptRepresentation Get the FeatureScript representation of a Part Studio.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiGetFeatureScriptRepresentationRequest
*/
func (a *PartStudioApiService) GetFeatureScriptRepresentation(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetFeatureScriptRepresentationRequest {
	return ApiGetFeatureScriptRepresentationRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTPModule234
func (a *PartStudioApiService) GetFeatureScriptRepresentationExecute(r ApiGetFeatureScriptRepresentationRequest) (*BTPModule234, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTPModule234
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.GetFeatureScriptRepresentation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/featurescriptrepresentation"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTPModule234
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFeatureScriptTableRequest struct {
	ctx             context.Context
	ApiService      *PartStudioApiService
	did             string
	wvm             string
	wvmid           string
	eid             string
	tableType       *string
	configuration   *string
	tableNamespace  *string
	tableParameters *string
	partId          *string
	linkDocumentId  *string
}

func (r ApiGetFeatureScriptTableRequest) TableType(tableType string) ApiGetFeatureScriptTableRequest {
	r.tableType = &tableType
	return r
}

func (r ApiGetFeatureScriptTableRequest) Configuration(configuration string) ApiGetFeatureScriptTableRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetFeatureScriptTableRequest) TableNamespace(tableNamespace string) ApiGetFeatureScriptTableRequest {
	r.tableNamespace = &tableNamespace
	return r
}

func (r ApiGetFeatureScriptTableRequest) TableParameters(tableParameters string) ApiGetFeatureScriptTableRequest {
	r.tableParameters = &tableParameters
	return r
}

func (r ApiGetFeatureScriptTableRequest) PartId(partId string) ApiGetFeatureScriptTableRequest {
	r.partId = &partId
	return r
}

func (r ApiGetFeatureScriptTableRequest) LinkDocumentId(linkDocumentId string) ApiGetFeatureScriptTableRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetFeatureScriptTableRequest) Execute() (*BTApiTableList1223, *http.Response, error) {
	return r.ApiService.GetFeatureScriptTableExecute(r)
}

/*
GetFeatureScriptTable Compute and return a FeatureScript table for a Part Studio.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param wvm
	@param wvmid
	@param eid
	@return ApiGetFeatureScriptTableRequest
*/
func (a *PartStudioApiService) GetFeatureScriptTable(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetFeatureScriptTableRequest {
	return ApiGetFeatureScriptTableRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTApiTableList1223
func (a *PartStudioApiService) GetFeatureScriptTableExecute(r ApiGetFeatureScriptTableRequest) (*BTApiTableList1223, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTApiTableList1223
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.GetFeatureScriptTable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/fstable"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tableType == nil {
		return localVarReturnValue, nil, reportError("tableType is required and must be specified")
	}

	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.tableNamespace != nil {
		localVarQueryParams.Add("tableNamespace", parameterToString(*r.tableNamespace, ""))
	}
	localVarQueryParams.Add("tableType", parameterToString(*r.tableType, ""))
	if r.tableParameters != nil {
		localVarQueryParams.Add("tableParameters", parameterToString(*r.tableParameters, ""))
	}
	if r.partId != nil {
		localVarQueryParams.Add("partId", parameterToString(*r.partId, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTApiTableList1223
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartStudioBodyDetailsRequest struct {
	ctx                   context.Context
	ApiService            *PartStudioApiService
	did                   string
	wvm                   string
	wvmid                 string
	eid                   string
	linkDocumentId        *string
	configuration         *string
	rollbackBarIndex      *int32
	elementMicroversionId *string
	partIds               *[]string
	includeSurfaces       *bool
	includeCompositeParts *bool
	includeGeometricData  *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetPartStudioBodyDetailsRequest) LinkDocumentId(linkDocumentId string) ApiGetPartStudioBodyDetailsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;) for the feature definition.
func (r ApiGetPartStudioBodyDetailsRequest) Configuration(configuration string) ApiGetPartStudioBodyDetailsRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiGetPartStudioBodyDetailsRequest) RollbackBarIndex(rollbackBarIndex int32) ApiGetPartStudioBodyDetailsRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

// A specific element microversion in which to evaluate the request.
func (r ApiGetPartStudioBodyDetailsRequest) ElementMicroversionId(elementMicroversionId string) ApiGetPartStudioBodyDetailsRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

// If specified, the response will only include body details for the specific parts as indicated here by their corresponding Id
func (r ApiGetPartStudioBodyDetailsRequest) PartIds(partIds []string) ApiGetPartStudioBodyDetailsRequest {
	r.partIds = &partIds
	return r
}

// Whether or not surfaces should be included in the response.
func (r ApiGetPartStudioBodyDetailsRequest) IncludeSurfaces(includeSurfaces bool) ApiGetPartStudioBodyDetailsRequest {
	r.includeSurfaces = &includeSurfaces
	return r
}

// Whether or not composite parts should be included in the response.
func (r ApiGetPartStudioBodyDetailsRequest) IncludeCompositeParts(includeCompositeParts bool) ApiGetPartStudioBodyDetailsRequest {
	r.includeCompositeParts = &includeCompositeParts
	return r
}

// Whether or not geometric data should be included in the response.
func (r ApiGetPartStudioBodyDetailsRequest) IncludeGeometricData(includeGeometricData bool) ApiGetPartStudioBodyDetailsRequest {
	r.includeGeometricData = &includeGeometricData
	return r
}

func (r ApiGetPartStudioBodyDetailsRequest) Execute() (*BTExportModelBodiesResponse734, *http.Response, error) {
	return r.ApiService.GetPartStudioBodyDetailsExecute(r)
}

/*
GetPartStudioBodyDetails Get the body details for a Part Studio.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiGetPartStudioBodyDetailsRequest
*/
func (a *PartStudioApiService) GetPartStudioBodyDetails(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetPartStudioBodyDetailsRequest {
	return ApiGetPartStudioBodyDetailsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTExportModelBodiesResponse734
func (a *PartStudioApiService) GetPartStudioBodyDetailsExecute(r ApiGetPartStudioBodyDetailsRequest) (*BTExportModelBodiesResponse734, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTExportModelBodiesResponse734
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.GetPartStudioBodyDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/bodydetails"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	if r.partIds != nil {
		t := *r.partIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("partIds", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("partIds", parameterToString(t, "multi"))
		}
	}
	if r.includeSurfaces != nil {
		localVarQueryParams.Add("includeSurfaces", parameterToString(*r.includeSurfaces, ""))
	}
	if r.includeCompositeParts != nil {
		localVarQueryParams.Add("includeCompositeParts", parameterToString(*r.includeCompositeParts, ""))
	}
	if r.includeGeometricData != nil {
		localVarQueryParams.Add("includeGeometricData", parameterToString(*r.includeGeometricData, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTExportModelBodiesResponse734
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartStudioBoundingBoxesRequest struct {
	ctx               context.Context
	ApiService        *PartStudioApiService
	did               string
	wvm               string
	wvmid             string
	eid               string
	includeHidden     *bool
	includeWireBodies *bool
	configuration     *string
	linkDocumentId    *string
}

// Whether or not to include bounding boxes for hidden parts.
func (r ApiGetPartStudioBoundingBoxesRequest) IncludeHidden(includeHidden bool) ApiGetPartStudioBoundingBoxesRequest {
	r.includeHidden = &includeHidden
	return r
}

// Whether to include wire bodies in the bounding box.
func (r ApiGetPartStudioBoundingBoxesRequest) IncludeWireBodies(includeWireBodies bool) ApiGetPartStudioBoundingBoxesRequest {
	r.includeWireBodies = &includeWireBodies
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;) for the feature definition.
func (r ApiGetPartStudioBoundingBoxesRequest) Configuration(configuration string) ApiGetPartStudioBoundingBoxesRequest {
	r.configuration = &configuration
	return r
}

// Id of document that links to the document being accessed. This may provide additional access rights to the document. Allowed only with version (v) path parameter.
func (r ApiGetPartStudioBoundingBoxesRequest) LinkDocumentId(linkDocumentId string) ApiGetPartStudioBoundingBoxesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetPartStudioBoundingBoxesRequest) Execute() (*BTBoundingBoxInfo, *http.Response, error) {
	return r.ApiService.GetPartStudioBoundingBoxesExecute(r)
}

/*
GetPartStudioBoundingBoxes Get the bounding boxes for a Part Studio.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did Document ID.
	@param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
	@param wvmid Workspace (w), Version (v) or Microversion (m) ID.
	@param eid Element ID.
	@return ApiGetPartStudioBoundingBoxesRequest
*/
func (a *PartStudioApiService) GetPartStudioBoundingBoxes(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetPartStudioBoundingBoxesRequest {
	return ApiGetPartStudioBoundingBoxesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTBoundingBoxInfo
func (a *PartStudioApiService) GetPartStudioBoundingBoxesExecute(r ApiGetPartStudioBoundingBoxesRequest) (*BTBoundingBoxInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTBoundingBoxInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.GetPartStudioBoundingBoxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/boundingboxes"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeHidden != nil {
		localVarQueryParams.Add("includeHidden", parameterToString(*r.includeHidden, ""))
	}
	if r.includeWireBodies != nil {
		localVarQueryParams.Add("includeWireBodies", parameterToString(*r.includeWireBodies, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTBoundingBoxInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartStudioEdgesRequest struct {
	ctx                      context.Context
	ApiService               *PartStudioApiService
	did                      string
	wvm                      string
	wvmid                    string
	eid                      string
	linkDocumentId           *string
	configuration            *string
	rollbackBarIndex         *int32
	elementMicroversionId    *string
	partId                   *[]string
	angleTolerance           *float64
	chordTolerance           *float64
	precomputedLevelOfDetail *string
	edgeId                   *[]string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetPartStudioEdgesRequest) LinkDocumentId(linkDocumentId string) ApiGetPartStudioEdgesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;) for the feature definition.
func (r ApiGetPartStudioEdgesRequest) Configuration(configuration string) ApiGetPartStudioEdgesRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiGetPartStudioEdgesRequest) RollbackBarIndex(rollbackBarIndex int32) ApiGetPartStudioEdgesRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

// A specific element microversion in which to evaluate the request.
func (r ApiGetPartStudioEdgesRequest) ElementMicroversionId(elementMicroversionId string) ApiGetPartStudioEdgesRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiGetPartStudioEdgesRequest) PartId(partId []string) ApiGetPartStudioEdgesRequest {
	r.partId = &partId
	return r
}

func (r ApiGetPartStudioEdgesRequest) AngleTolerance(angleTolerance float64) ApiGetPartStudioEdgesRequest {
	r.angleTolerance = &angleTolerance
	return r
}

func (r ApiGetPartStudioEdgesRequest) ChordTolerance(chordTolerance float64) ApiGetPartStudioEdgesRequest {
	r.chordTolerance = &chordTolerance
	return r
}

func (r ApiGetPartStudioEdgesRequest) PrecomputedLevelOfDetail(precomputedLevelOfDetail string) ApiGetPartStudioEdgesRequest {
	r.precomputedLevelOfDetail = &precomputedLevelOfDetail
	return r
}

func (r ApiGetPartStudioEdgesRequest) EdgeId(edgeId []string) ApiGetPartStudioEdgesRequest {
	r.edgeId = &edgeId
	return r
}

func (r ApiGetPartStudioEdgesRequest) Execute() (*BTExportTessellatedEdgesResponse327, *http.Response, error) {
	return r.ApiService.GetPartStudioEdgesExecute(r)
}

/*
GetPartStudioEdges Get a list of all edges in a Part Studio.

Returns the edges as tessellated data and includes display data.
Coordinates are in meters (m).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiGetPartStudioEdgesRequest
*/
func (a *PartStudioApiService) GetPartStudioEdges(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetPartStudioEdgesRequest {
	return ApiGetPartStudioEdgesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTExportTessellatedEdgesResponse327
func (a *PartStudioApiService) GetPartStudioEdgesExecute(r ApiGetPartStudioEdgesRequest) (*BTExportTessellatedEdgesResponse327, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTExportTessellatedEdgesResponse327
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.GetPartStudioEdges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/tessellatededges"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	if r.partId != nil {
		t := *r.partId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("partId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("partId", parameterToString(t, "multi"))
		}
	}
	if r.angleTolerance != nil {
		localVarQueryParams.Add("angleTolerance", parameterToString(*r.angleTolerance, ""))
	}
	if r.chordTolerance != nil {
		localVarQueryParams.Add("chordTolerance", parameterToString(*r.chordTolerance, ""))
	}
	if r.precomputedLevelOfDetail != nil {
		localVarQueryParams.Add("precomputedLevelOfDetail", parameterToString(*r.precomputedLevelOfDetail, ""))
	}
	if r.edgeId != nil {
		t := *r.edgeId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("edgeId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("edgeId", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTExportTessellatedEdgesResponse327
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartStudioFacesRequest struct {
	ctx                              context.Context
	ApiService                       *PartStudioApiService
	did                              string
	wvm                              string
	wvmid                            string
	eid                              string
	linkDocumentId                   *string
	configuration                    *string
	rollbackBarIndex                 *int32
	elementMicroversionId            *string
	partId                           *[]string
	angleTolerance                   *float64
	chordTolerance                   *float64
	precomputedLevelOfDetail         *string
	faceId                           *[]string
	outputFaceAppearances            *bool
	maxFacetWidth                    *float64
	outputVertexNormals              *bool
	outputFacetNormals               *bool
	outputTextureCoordinates         *bool
	outputIndexTable                 *bool
	outputErrorFaces                 *bool
	combineCompositePartConstituents *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetPartStudioFacesRequest) LinkDocumentId(linkDocumentId string) ApiGetPartStudioFacesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;) for the feature definition.
func (r ApiGetPartStudioFacesRequest) Configuration(configuration string) ApiGetPartStudioFacesRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiGetPartStudioFacesRequest) RollbackBarIndex(rollbackBarIndex int32) ApiGetPartStudioFacesRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

// A specific element microversion in which to evaluate the request.
func (r ApiGetPartStudioFacesRequest) ElementMicroversionId(elementMicroversionId string) ApiGetPartStudioFacesRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiGetPartStudioFacesRequest) PartId(partId []string) ApiGetPartStudioFacesRequest {
	r.partId = &partId
	return r
}

func (r ApiGetPartStudioFacesRequest) AngleTolerance(angleTolerance float64) ApiGetPartStudioFacesRequest {
	r.angleTolerance = &angleTolerance
	return r
}

func (r ApiGetPartStudioFacesRequest) ChordTolerance(chordTolerance float64) ApiGetPartStudioFacesRequest {
	r.chordTolerance = &chordTolerance
	return r
}

func (r ApiGetPartStudioFacesRequest) PrecomputedLevelOfDetail(precomputedLevelOfDetail string) ApiGetPartStudioFacesRequest {
	r.precomputedLevelOfDetail = &precomputedLevelOfDetail
	return r
}

func (r ApiGetPartStudioFacesRequest) FaceId(faceId []string) ApiGetPartStudioFacesRequest {
	r.faceId = &faceId
	return r
}

func (r ApiGetPartStudioFacesRequest) OutputFaceAppearances(outputFaceAppearances bool) ApiGetPartStudioFacesRequest {
	r.outputFaceAppearances = &outputFaceAppearances
	return r
}

func (r ApiGetPartStudioFacesRequest) MaxFacetWidth(maxFacetWidth float64) ApiGetPartStudioFacesRequest {
	r.maxFacetWidth = &maxFacetWidth
	return r
}

func (r ApiGetPartStudioFacesRequest) OutputVertexNormals(outputVertexNormals bool) ApiGetPartStudioFacesRequest {
	r.outputVertexNormals = &outputVertexNormals
	return r
}

func (r ApiGetPartStudioFacesRequest) OutputFacetNormals(outputFacetNormals bool) ApiGetPartStudioFacesRequest {
	r.outputFacetNormals = &outputFacetNormals
	return r
}

func (r ApiGetPartStudioFacesRequest) OutputTextureCoordinates(outputTextureCoordinates bool) ApiGetPartStudioFacesRequest {
	r.outputTextureCoordinates = &outputTextureCoordinates
	return r
}

func (r ApiGetPartStudioFacesRequest) OutputIndexTable(outputIndexTable bool) ApiGetPartStudioFacesRequest {
	r.outputIndexTable = &outputIndexTable
	return r
}

func (r ApiGetPartStudioFacesRequest) OutputErrorFaces(outputErrorFaces bool) ApiGetPartStudioFacesRequest {
	r.outputErrorFaces = &outputErrorFaces
	return r
}

func (r ApiGetPartStudioFacesRequest) CombineCompositePartConstituents(combineCompositePartConstituents bool) ApiGetPartStudioFacesRequest {
	r.combineCompositePartConstituents = &combineCompositePartConstituents
	return r
}

func (r ApiGetPartStudioFacesRequest) Execute() (*BTExportTessellatedFacesResponse898, *http.Response, error) {
	return r.ApiService.GetPartStudioFacesExecute(r)
}

/*
GetPartStudioFaces Get a list of all faces in a Part Studio.

Coordinates are in meters (m).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiGetPartStudioFacesRequest
*/
func (a *PartStudioApiService) GetPartStudioFaces(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetPartStudioFacesRequest {
	return ApiGetPartStudioFacesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTExportTessellatedFacesResponse898
func (a *PartStudioApiService) GetPartStudioFacesExecute(r ApiGetPartStudioFacesRequest) (*BTExportTessellatedFacesResponse898, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTExportTessellatedFacesResponse898
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.GetPartStudioFaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/tessellatedfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	if r.partId != nil {
		t := *r.partId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("partId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("partId", parameterToString(t, "multi"))
		}
	}
	if r.angleTolerance != nil {
		localVarQueryParams.Add("angleTolerance", parameterToString(*r.angleTolerance, ""))
	}
	if r.chordTolerance != nil {
		localVarQueryParams.Add("chordTolerance", parameterToString(*r.chordTolerance, ""))
	}
	if r.precomputedLevelOfDetail != nil {
		localVarQueryParams.Add("precomputedLevelOfDetail", parameterToString(*r.precomputedLevelOfDetail, ""))
	}
	if r.faceId != nil {
		t := *r.faceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("faceId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("faceId", parameterToString(t, "multi"))
		}
	}
	if r.outputFaceAppearances != nil {
		localVarQueryParams.Add("outputFaceAppearances", parameterToString(*r.outputFaceAppearances, ""))
	}
	if r.maxFacetWidth != nil {
		localVarQueryParams.Add("maxFacetWidth", parameterToString(*r.maxFacetWidth, ""))
	}
	if r.outputVertexNormals != nil {
		localVarQueryParams.Add("outputVertexNormals", parameterToString(*r.outputVertexNormals, ""))
	}
	if r.outputFacetNormals != nil {
		localVarQueryParams.Add("outputFacetNormals", parameterToString(*r.outputFacetNormals, ""))
	}
	if r.outputTextureCoordinates != nil {
		localVarQueryParams.Add("outputTextureCoordinates", parameterToString(*r.outputTextureCoordinates, ""))
	}
	if r.outputIndexTable != nil {
		localVarQueryParams.Add("outputIndexTable", parameterToString(*r.outputIndexTable, ""))
	}
	if r.outputErrorFaces != nil {
		localVarQueryParams.Add("outputErrorFaces", parameterToString(*r.outputErrorFaces, ""))
	}
	if r.combineCompositePartConstituents != nil {
		localVarQueryParams.Add("combineCompositePartConstituents", parameterToString(*r.combineCompositePartConstituents, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTExportTessellatedFacesResponse898
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartStudioFeatureSpecsRequest struct {
	ctx        context.Context
	ApiService *PartStudioApiService
	did        string
	wvm        string
	wvmid      string
	eid        string
}

func (r ApiGetPartStudioFeatureSpecsRequest) Execute() (*BTFeatureSpecsResponse664, *http.Response, error) {
	return r.ApiService.GetPartStudioFeatureSpecsExecute(r)
}

/*
GetPartStudioFeatureSpecs Get the specs for a Part Studio feature.

Returns a list of feature specs available within the Part Studio. A feature spec provides a data description of the feature's interface to a feature.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did Document ID.
	@param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
	@param wvmid Workspace (w), Version (v) or Microversion (m) ID.
	@param eid Element ID.
	@return ApiGetPartStudioFeatureSpecsRequest
*/
func (a *PartStudioApiService) GetPartStudioFeatureSpecs(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetPartStudioFeatureSpecsRequest {
	return ApiGetPartStudioFeatureSpecsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTFeatureSpecsResponse664
func (a *PartStudioApiService) GetPartStudioFeatureSpecsExecute(r ApiGetPartStudioFeatureSpecsRequest) (*BTFeatureSpecsResponse664, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTFeatureSpecsResponse664
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.GetPartStudioFeatureSpecs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/featurespecs"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTFeatureSpecsResponse664
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartStudioFeaturesRequest struct {
	ctx                   context.Context
	ApiService            *PartStudioApiService
	did                   string
	wvm                   string
	wvmid                 string
	eid                   string
	linkDocumentId        *string
	configuration         *string
	rollbackBarIndex      *int32
	elementMicroversionId *string
	includeGeometryIds    *bool
	featureId             *[]string
	noSketchGeometry      *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetPartStudioFeaturesRequest) LinkDocumentId(linkDocumentId string) ApiGetPartStudioFeaturesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;) for the feature definition.
func (r ApiGetPartStudioFeaturesRequest) Configuration(configuration string) ApiGetPartStudioFeaturesRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiGetPartStudioFeaturesRequest) RollbackBarIndex(rollbackBarIndex int32) ApiGetPartStudioFeaturesRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

// A specific element microversion in which to evaluate the request.
func (r ApiGetPartStudioFeaturesRequest) ElementMicroversionId(elementMicroversionId string) ApiGetPartStudioFeaturesRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

// If true, include the underlying geometry IDs in the feature definition.
func (r ApiGetPartStudioFeaturesRequest) IncludeGeometryIds(includeGeometryIds bool) ApiGetPartStudioFeaturesRequest {
	r.includeGeometryIds = &includeGeometryIds
	return r
}

// ID of a feature; repeat query param to add more than one
func (r ApiGetPartStudioFeaturesRequest) FeatureId(featureId []string) ApiGetPartStudioFeaturesRequest {
	r.featureId = &featureId
	return r
}

// Whether or not to output simple sketch info without geometry
func (r ApiGetPartStudioFeaturesRequest) NoSketchGeometry(noSketchGeometry bool) ApiGetPartStudioFeaturesRequest {
	r.noSketchGeometry = &noSketchGeometry
	return r
}

func (r ApiGetPartStudioFeaturesRequest) Execute() (*BTFeatureListResponse2457, *http.Response, error) {
	return r.ApiService.GetPartStudioFeaturesExecute(r)
}

/*
GetPartStudioFeatures Get a list of features instantiated in the Part Studio.

See the [Features API Guide](https://onshape-public.github.io/docs/api-adv/featureaccess/) for additional information.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiGetPartStudioFeaturesRequest
*/
func (a *PartStudioApiService) GetPartStudioFeatures(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetPartStudioFeaturesRequest {
	return ApiGetPartStudioFeaturesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTFeatureListResponse2457
func (a *PartStudioApiService) GetPartStudioFeaturesExecute(r ApiGetPartStudioFeaturesRequest) (*BTFeatureListResponse2457, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTFeatureListResponse2457
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.GetPartStudioFeatures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	if r.includeGeometryIds != nil {
		localVarQueryParams.Add("includeGeometryIds", parameterToString(*r.includeGeometryIds, ""))
	}
	if r.featureId != nil {
		t := *r.featureId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("featureId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("featureId", parameterToString(t, "multi"))
		}
	}
	if r.noSketchGeometry != nil {
		localVarQueryParams.Add("noSketchGeometry", parameterToString(*r.noSketchGeometry, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTFeatureListResponse2457
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartStudioMassPropertiesRequest struct {
	ctx                      context.Context
	ApiService               *PartStudioApiService
	did                      string
	wvm                      string
	wvmid                    string
	eid                      string
	linkDocumentId           *string
	configuration            *string
	rollbackBarIndex         *int32
	elementMicroversionId    *string
	partId                   *[]string
	massAsGroup              *bool
	useMassPropertyOverrides *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetPartStudioMassPropertiesRequest) LinkDocumentId(linkDocumentId string) ApiGetPartStudioMassPropertiesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;) for the feature definition.
func (r ApiGetPartStudioMassPropertiesRequest) Configuration(configuration string) ApiGetPartStudioMassPropertiesRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiGetPartStudioMassPropertiesRequest) RollbackBarIndex(rollbackBarIndex int32) ApiGetPartStudioMassPropertiesRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

// A specific element microversion in which to evaluate the request.
func (r ApiGetPartStudioMassPropertiesRequest) ElementMicroversionId(elementMicroversionId string) ApiGetPartStudioMassPropertiesRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiGetPartStudioMassPropertiesRequest) PartId(partId []string) ApiGetPartStudioMassPropertiesRequest {
	r.partId = &partId
	return r
}

// If true, specified parts will be evaluated as a single object instead of individually
func (r ApiGetPartStudioMassPropertiesRequest) MassAsGroup(massAsGroup bool) ApiGetPartStudioMassPropertiesRequest {
	r.massAsGroup = &massAsGroup
	return r
}

// If true, use the user mass property overrides when calculated mass properties
func (r ApiGetPartStudioMassPropertiesRequest) UseMassPropertyOverrides(useMassPropertyOverrides bool) ApiGetPartStudioMassPropertiesRequest {
	r.useMassPropertyOverrides = &useMassPropertyOverrides
	return r
}

func (r ApiGetPartStudioMassPropertiesRequest) Execute() (*BTMassPropertiesBulkInfo, *http.Response, error) {
	return r.ApiService.GetPartStudioMassPropertiesExecute(r)
}

/*
GetPartStudioMassProperties Get the mass properties for a Part Studio.

If three mass properties are returned, the first is the calculated mass; the second and third are the minimum and maximum possible values considering tolerance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@return ApiGetPartStudioMassPropertiesRequest
*/
func (a *PartStudioApiService) GetPartStudioMassProperties(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetPartStudioMassPropertiesRequest {
	return ApiGetPartStudioMassPropertiesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTMassPropertiesBulkInfo
func (a *PartStudioApiService) GetPartStudioMassPropertiesExecute(r ApiGetPartStudioMassPropertiesRequest) (*BTMassPropertiesBulkInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTMassPropertiesBulkInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.GetPartStudioMassProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/massproperties"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	if r.partId != nil {
		t := *r.partId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("partId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("partId", parameterToString(t, "multi"))
		}
	}
	if r.massAsGroup != nil {
		localVarQueryParams.Add("massAsGroup", parameterToString(*r.massAsGroup, ""))
	}
	if r.useMassPropertyOverrides != nil {
		localVarQueryParams.Add("useMassPropertyOverrides", parameterToString(*r.useMassPropertyOverrides, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTMassPropertiesBulkInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartStudioNamedViewsRequest struct {
	ctx                    context.Context
	ApiService             *PartStudioApiService
	did                    string
	eid                    string
	linkDocumentId         *string
	skipPerspective        *bool
	includeSectionCutViews *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetPartStudioNamedViewsRequest) LinkDocumentId(linkDocumentId string) ApiGetPartStudioNamedViewsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetPartStudioNamedViewsRequest) SkipPerspective(skipPerspective bool) ApiGetPartStudioNamedViewsRequest {
	r.skipPerspective = &skipPerspective
	return r
}

func (r ApiGetPartStudioNamedViewsRequest) IncludeSectionCutViews(includeSectionCutViews bool) ApiGetPartStudioNamedViewsRequest {
	r.includeSectionCutViews = &includeSectionCutViews
	return r
}

func (r ApiGetPartStudioNamedViewsRequest) Execute() (*BTNamedViewsInfo, *http.Response, error) {
	return r.ApiService.GetPartStudioNamedViewsExecute(r)
}

/*
GetPartStudioNamedViews Get a list of all named views that exist in the Part Studio.

Returns a map from view name to view data for the given element

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param eid
	@return ApiGetPartStudioNamedViewsRequest
*/
func (a *PartStudioApiService) GetPartStudioNamedViews(ctx context.Context, did string, eid string) ApiGetPartStudioNamedViewsRequest {
	return ApiGetPartStudioNamedViewsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTNamedViewsInfo
func (a *PartStudioApiService) GetPartStudioNamedViewsExecute(r ApiGetPartStudioNamedViewsRequest) (*BTNamedViewsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTNamedViewsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.GetPartStudioNamedViews")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/e/{eid}/namedViews"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.skipPerspective != nil {
		localVarQueryParams.Add("skipPerspective", parameterToString(*r.skipPerspective, ""))
	}
	if r.includeSectionCutViews != nil {
		localVarQueryParams.Add("includeSectionCutViews", parameterToString(*r.includeSectionCutViews, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTNamedViewsInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartStudioShadedViewsRequest struct {
	ctx             context.Context
	ApiService      *PartStudioApiService
	did             string
	wvm             string
	wvmid           string
	eid             string
	viewMatrix      *string
	outputHeight    *int32
	outputWidth     *int32
	pixelSize       *float64
	edges           *string
	showAllParts    *bool
	includeSurfaces *bool
	useAntiAliasing *bool
	includeWires    *bool
	configuration   *string
	linkDocumentId  *string
}

// 12-number view matrix (comma-separated), or one of the following named views: top, bottom, front, back, left, right The 12 entries in the view matrix form three rows and four columns, which is a linear transformation applied to the model itself. The matrix&#39;s first three columns maps the coordinate axes of the model to the coordinate axes of the view, and the fourth column translates the origin (in meters). The view coordinates have x pointing right, y pointing up, and z pointing towards the viewer, while a front view of the model has x pointing right, y pointing away from the viewer, and z pointing up. For example, the identity matrix viewMatrix&#x3D;1,0,0,0,0,1,0,0,0,0,1,0 corresponds to the top view, and viewMatrix&#x3D;0.612,0.612,0,0,-0.354,0.354,0.707,0,0.707,-0.707,0.707,0 corresponds (approximately) to the isometric view. The first three columns of the view matrix should be orthonormal and have a positive determinant.  If this is not the case, view behavior may be undefined.
func (r ApiGetPartStudioShadedViewsRequest) ViewMatrix(viewMatrix string) ApiGetPartStudioShadedViewsRequest {
	r.viewMatrix = &viewMatrix
	return r
}

// Output image height (in pixels)
func (r ApiGetPartStudioShadedViewsRequest) OutputHeight(outputHeight int32) ApiGetPartStudioShadedViewsRequest {
	r.outputHeight = &outputHeight
	return r
}

// Output image width (in pixels)
func (r ApiGetPartStudioShadedViewsRequest) OutputWidth(outputWidth int32) ApiGetPartStudioShadedViewsRequest {
	r.outputWidth = &outputWidth
	return r
}

// Height and width represented by each pixel (in meters). If the value is 0, the display will be sized to fit the output image dimensions.
func (r ApiGetPartStudioShadedViewsRequest) PixelSize(pixelSize float64) ApiGetPartStudioShadedViewsRequest {
	r.pixelSize = &pixelSize
	return r
}

// The treatment to be applied to edges in the display. Options are show: show visible edges, hide: hide visible edges.
func (r ApiGetPartStudioShadedViewsRequest) Edges(edges string) ApiGetPartStudioShadedViewsRequest {
	r.edges = &edges
	return r
}

// Whether or not all parts should be shown in the element, regardless of user setting. If false, the visibility setting made by the user will be reflected in the image. If true, all parts will be shown.
func (r ApiGetPartStudioShadedViewsRequest) ShowAllParts(showAllParts bool) ApiGetPartStudioShadedViewsRequest {
	r.showAllParts = &showAllParts
	return r
}

// Whether or not surfaces should be shown in the element. It is applicable only when showAllParts is true. If false, surfaces will be excluded. If true, all surfaces will be shown.
func (r ApiGetPartStudioShadedViewsRequest) IncludeSurfaces(includeSurfaces bool) ApiGetPartStudioShadedViewsRequest {
	r.includeSurfaces = &includeSurfaces
	return r
}

// If true, an anti-aliasing factor will be used to smooth model boundaries in the final image result. If false, the image will be rasterized at the given resolution. Setting to true can have negative performance implications with respect to rendering time and memory usage. If a high-resolution image is requested and anti-aliasing is turned on, the server may not be able to fulfill the request.
func (r ApiGetPartStudioShadedViewsRequest) UseAntiAliasing(useAntiAliasing bool) ApiGetPartStudioShadedViewsRequest {
	r.useAntiAliasing = &useAntiAliasing
	return r
}

func (r ApiGetPartStudioShadedViewsRequest) IncludeWires(includeWires bool) ApiGetPartStudioShadedViewsRequest {
	r.includeWires = &includeWires
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;) for the feature definition.
func (r ApiGetPartStudioShadedViewsRequest) Configuration(configuration string) ApiGetPartStudioShadedViewsRequest {
	r.configuration = &configuration
	return r
}

// Id of document that links to the document being accessed. This may provide additional access rights to the document. Allowed only with version (v) path parameter.
func (r ApiGetPartStudioShadedViewsRequest) LinkDocumentId(linkDocumentId string) ApiGetPartStudioShadedViewsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetPartStudioShadedViewsRequest) Execute() (*BTShadedViewsInfo, *http.Response, error) {
	return r.ApiService.GetPartStudioShadedViewsExecute(r)
}

/*
GetPartStudioShadedViews Get a list of shaded views for a Part Studio.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did Document ID.
	@param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
	@param wvmid Workspace (w), Version (v) or Microversion (m) ID.
	@param eid Element ID.
	@return ApiGetPartStudioShadedViewsRequest
*/
func (a *PartStudioApiService) GetPartStudioShadedViews(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetPartStudioShadedViewsRequest {
	return ApiGetPartStudioShadedViewsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTShadedViewsInfo
func (a *PartStudioApiService) GetPartStudioShadedViewsExecute(r ApiGetPartStudioShadedViewsRequest) (*BTShadedViewsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTShadedViewsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.GetPartStudioShadedViews")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/shadedviews"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.viewMatrix != nil {
		localVarQueryParams.Add("viewMatrix", parameterToString(*r.viewMatrix, ""))
	}
	if r.outputHeight != nil {
		localVarQueryParams.Add("outputHeight", parameterToString(*r.outputHeight, ""))
	}
	if r.outputWidth != nil {
		localVarQueryParams.Add("outputWidth", parameterToString(*r.outputWidth, ""))
	}
	if r.pixelSize != nil {
		localVarQueryParams.Add("pixelSize", parameterToString(*r.pixelSize, ""))
	}
	if r.edges != nil {
		localVarQueryParams.Add("edges", parameterToString(*r.edges, ""))
	}
	if r.showAllParts != nil {
		localVarQueryParams.Add("showAllParts", parameterToString(*r.showAllParts, ""))
	}
	if r.includeSurfaces != nil {
		localVarQueryParams.Add("includeSurfaces", parameterToString(*r.includeSurfaces, ""))
	}
	if r.useAntiAliasing != nil {
		localVarQueryParams.Add("useAntiAliasing", parameterToString(*r.useAntiAliasing, ""))
	}
	if r.includeWires != nil {
		localVarQueryParams.Add("includeWires", parameterToString(*r.includeWires, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTShadedViewsInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateIdsRequest struct {
	ctx                   context.Context
	ApiService            *PartStudioApiService
	did                   string
	wvm                   string
	wvmid                 string
	eid                   string
	bTIdTranslationParams *BTIdTranslationParams
}

func (r ApiTranslateIdsRequest) BTIdTranslationParams(bTIdTranslationParams BTIdTranslationParams) ApiTranslateIdsRequest {
	r.bTIdTranslationParams = &bTIdTranslationParams
	return r
}

func (r ApiTranslateIdsRequest) Execute() (*BTIdTranslationInfo, *http.Response, error) {
	return r.ApiService.TranslateIdsExecute(r)
}

/*
TranslateIds Find corresponding deterministic IDs from a source document microversion at the target version.

* Deterministic IDs are only valid for one microversion.
* This maps deterministic IDs between microversions in an attempt to find the corresponding entities in each version.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did Document ID.
	@param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
	@param wvmid Workspace (w), Version (v) or Microversion (m) ID.
	@param eid Element ID.
	@return ApiTranslateIdsRequest
*/
func (a *PartStudioApiService) TranslateIds(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiTranslateIdsRequest {
	return ApiTranslateIdsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTIdTranslationInfo
func (a *PartStudioApiService) TranslateIdsExecute(r ApiTranslateIdsRequest) (*BTIdTranslationInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTIdTranslationInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.TranslateIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/idtranslations"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTIdTranslationParams == nil {
		return localVarReturnValue, nil, reportError("bTIdTranslationParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTIdTranslationParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTIdTranslationInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFeaturesRequest struct {
	ctx                      context.Context
	ApiService               *PartStudioApiService
	did                      string
	wid                      string
	eid                      string
	bTUpdateFeaturesCall1748 *BTUpdateFeaturesCall1748
}

// feature The serialized feature definition
func (r ApiUpdateFeaturesRequest) BTUpdateFeaturesCall1748(bTUpdateFeaturesCall1748 BTUpdateFeaturesCall1748) ApiUpdateFeaturesRequest {
	r.bTUpdateFeaturesCall1748 = &bTUpdateFeaturesCall1748
	return r
}

func (r ApiUpdateFeaturesRequest) Execute() (*BTUpdateFeaturesResponse1333, *http.Response, error) {
	return r.ApiService.UpdateFeaturesExecute(r)
}

/*
UpdateFeatures Update multiple features in a Part Studio

This API accepts a list of features (that must already exist in the Part Studio) to update. This call does not fully redefine the features; it updates only the parameters supplied in the top-level feature structure, and optionally can update feature suppression attributes.
See the [Features API Guide](https://onshape-public.github.io/docs/api-adv/featureaccess/) for additional information.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did Document ID.
	@param wid Workspace ID.
	@param eid Element ID.
	@return ApiUpdateFeaturesRequest
*/
func (a *PartStudioApiService) UpdateFeatures(ctx context.Context, did string, wid string, eid string) ApiUpdateFeaturesRequest {
	return ApiUpdateFeaturesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTUpdateFeaturesResponse1333
func (a *PartStudioApiService) UpdateFeaturesExecute(r ApiUpdateFeaturesRequest) (*BTUpdateFeaturesResponse1333, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTUpdateFeaturesResponse1333
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.UpdateFeatures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/w/{wid}/e/{eid}/features/updates"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTUpdateFeaturesCall1748
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTUpdateFeaturesResponse1333
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePartStudioFeatureRequest struct {
	ctx                         context.Context
	ApiService                  *PartStudioApiService
	did                         string
	wid                         string
	eid                         string
	fid                         string
	bTFeatureDefinitionCall1406 *BTFeatureDefinitionCall1406
}

// feature The serialized feature definition
func (r ApiUpdatePartStudioFeatureRequest) BTFeatureDefinitionCall1406(bTFeatureDefinitionCall1406 BTFeatureDefinitionCall1406) ApiUpdatePartStudioFeatureRequest {
	r.bTFeatureDefinitionCall1406 = &bTFeatureDefinitionCall1406
	return r
}

func (r ApiUpdatePartStudioFeatureRequest) Execute() (*BTFeatureDefinitionResponse1617, *http.Response, error) {
	return r.ApiService.UpdatePartStudioFeatureExecute(r)
}

/*
UpdatePartStudioFeature Update the definition of a Part Studio feature.

Replaces an existing feature in the location of the existing feature. See the [Features API Guide](https://onshape-public.github.io/docs/api-adv/featureaccess/) for additional information.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did Document ID.
	@param wid Workspace ID.
	@param eid Element ID.
	@param fid The id of the feature being updated. This id should be URL encoded and must match the featureId found in the serialized structure
	@return ApiUpdatePartStudioFeatureRequest
*/
func (a *PartStudioApiService) UpdatePartStudioFeature(ctx context.Context, did string, wid string, eid string, fid string) ApiUpdatePartStudioFeatureRequest {
	return ApiUpdatePartStudioFeatureRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
		fid:        fid,
	}
}

// Execute executes the request
//
//	@return BTFeatureDefinitionResponse1617
func (a *PartStudioApiService) UpdatePartStudioFeatureExecute(r ApiUpdatePartStudioFeatureRequest) (*BTFeatureDefinitionResponse1617, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTFeatureDefinitionResponse1617
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.UpdatePartStudioFeature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/w/{wid}/e/{eid}/features/featureid/{fid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fid"+"}", url.PathEscape(parameterToString(r.fid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTFeatureDefinitionCall1406
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTFeatureDefinitionResponse1617
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateRollbackRequest struct {
	ctx        context.Context
	ApiService *PartStudioApiService
	did        string
	wid        string
	eid        string
	body       *string
}

// The index at which the rollback index should be placed. Features  with entry index (0-based) higher than or equal to the value are rolled back. Value of -1 is treated  as an alias for \&quot;end of feature list\&quot;. Otherwise the value must be in the range 0 to the number of  entries in the feature list
func (r ApiUpdateRollbackRequest) Body(body string) ApiUpdateRollbackRequest {
	r.body = &body
	return r
}

func (r ApiUpdateRollbackRequest) Execute() (*BTSetFeatureRollbackResponse1042, *http.Response, error) {
	return r.ApiService.UpdateRollbackExecute(r)
}

/*
UpdateRollback Move the Feature List rollback bar in the Part Studio.

Set to -1 to move the rollback bar to the end of the list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did Document ID.
	@param wid Workspace ID.
	@param eid Element ID.
	@return ApiUpdateRollbackRequest
*/
func (a *PartStudioApiService) UpdateRollback(ctx context.Context, did string, wid string, eid string) ApiUpdateRollbackRequest {
	return ApiUpdateRollbackRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return BTSetFeatureRollbackResponse1042
func (a *PartStudioApiService) UpdateRollbackExecute(r ApiUpdateRollbackRequest) (*BTSetFeatureRollbackResponse1042, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTSetFeatureRollbackResponse1042
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.UpdateRollback")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/w/{wid}/e/{eid}/features/rollback"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTSetFeatureRollbackResponse1042
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
