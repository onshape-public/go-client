/*
Onshape REST API

The Onshape REST API consumed by all client. # Authorization The simplest way to authorize and enable the **Try it out** functionality is to sign in to Onshape and use the current session. The **Authorize** button enables other authorization techniques. To ensure the current session isn't used when trying other authentication techniques, make sure to remove the Onshape cookie as per the instructions for your particular browser. Alternatively, a private or incognito window may be used. Here's [how to remove a specific cookie on Chrome](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site). - **Current Session** authorization is enabled by default if the browser is already signed in to [Onshape](/). - **OAuth2** authorization uses an Onshape OAuth2 app created on the [Onshape Developer Portal](https://dev-portal.onshape.com/oauthApps). The redirect URL field should include `https://cad.onshape.com/glassworks/explorer/oauth2-redirect.html`. - **API Key** authorization using basic authentication is also available. The keys can be generated in the [Onshape Developer Portal](https://dev-portal.onshape.com/keys). In the authentication dialog, enter the access key in the `Username` field, and enter the secret key in the `Password` field. Basic authentication should only be used during the development process since sharing API Keys provides the same level of access as a username and password.

API version: 1.153.6415-48a6b2252b8c
Contact: api-support@onshape.zendesk.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package onshape

import (
	"context"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// PartStudioApiService PartStudioApi service
type PartStudioApiService service

type ApiAddPartStudioFeatureRequest struct {
	ctx                         context.Context
	ApiService                  *PartStudioApiService
	did                         string
	wvm                         string
	wvmid                       string
	eid                         string
	bTFeatureDefinitionCall1406 *BTFeatureDefinitionCall1406
}

func (r ApiAddPartStudioFeatureRequest) BTFeatureDefinitionCall1406(bTFeatureDefinitionCall1406 BTFeatureDefinitionCall1406) ApiAddPartStudioFeatureRequest {
	r.bTFeatureDefinitionCall1406 = &bTFeatureDefinitionCall1406
	return r
}

func (r ApiAddPartStudioFeatureRequest) Execute() (*BTFeatureDefinitionResponse1617, *http.Response, error) {
	return r.ApiService.AddPartStudioFeatureExecute(r)
}

/*
AddPartStudioFeature Add feature to the feature list for a Part Studio by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wvm
 @param wvmid
 @param eid
 @return ApiAddPartStudioFeatureRequest
*/
func (a *PartStudioApiService) AddPartStudioFeature(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiAddPartStudioFeatureRequest {
	return ApiAddPartStudioFeatureRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTFeatureDefinitionResponse1617
func (a *PartStudioApiService) AddPartStudioFeatureExecute(r ApiAddPartStudioFeatureRequest) (*BTFeatureDefinitionResponse1617, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTFeatureDefinitionResponse1617
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.AddPartStudioFeature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTFeatureDefinitionCall1406
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTFeatureDefinitionResponse1617
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComparePartStudiosRequest struct {
	ctx                 context.Context
	ApiService          *PartStudioApiService
	did                 string
	wvm                 string
	wvmid               string
	eid                 string
	workspaceId         *string
	versionId           *string
	microversionId      *string
	sourceConfiguration *string
	targetConfiguration *string
	linkDocumentId      *string
}

func (r ApiComparePartStudiosRequest) WorkspaceId(workspaceId string) ApiComparePartStudiosRequest {
	r.workspaceId = &workspaceId
	return r
}

func (r ApiComparePartStudiosRequest) VersionId(versionId string) ApiComparePartStudiosRequest {
	r.versionId = &versionId
	return r
}

func (r ApiComparePartStudiosRequest) MicroversionId(microversionId string) ApiComparePartStudiosRequest {
	r.microversionId = &microversionId
	return r
}

func (r ApiComparePartStudiosRequest) SourceConfiguration(sourceConfiguration string) ApiComparePartStudiosRequest {
	r.sourceConfiguration = &sourceConfiguration
	return r
}

func (r ApiComparePartStudiosRequest) TargetConfiguration(targetConfiguration string) ApiComparePartStudiosRequest {
	r.targetConfiguration = &targetConfiguration
	return r
}

func (r ApiComparePartStudiosRequest) LinkDocumentId(linkDocumentId string) ApiComparePartStudiosRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiComparePartStudiosRequest) Execute() (*BTRootDiffInfo, *http.Response, error) {
	return r.ApiService.ComparePartStudiosExecute(r)
}

/*
ComparePartStudios Compare Part Studios by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did Document ID.
 @param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
 @param wvmid Workspace (w), Version (v) or Microversion (m) ID.
 @param eid Element ID.
 @return ApiComparePartStudiosRequest
*/
func (a *PartStudioApiService) ComparePartStudios(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiComparePartStudiosRequest {
	return ApiComparePartStudiosRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTRootDiffInfo
func (a *PartStudioApiService) ComparePartStudiosExecute(r ApiComparePartStudiosRequest) (*BTRootDiffInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTRootDiffInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.ComparePartStudios")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/compare"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.workspaceId != nil {
		localVarQueryParams.Add("workspaceId", parameterToString(*r.workspaceId, ""))
	}
	if r.versionId != nil {
		localVarQueryParams.Add("versionId", parameterToString(*r.versionId, ""))
	}
	if r.microversionId != nil {
		localVarQueryParams.Add("microversionId", parameterToString(*r.microversionId, ""))
	}
	if r.sourceConfiguration != nil {
		localVarQueryParams.Add("sourceConfiguration", parameterToString(*r.sourceConfiguration, ""))
	}
	if r.targetConfiguration != nil {
		localVarQueryParams.Add("targetConfiguration", parameterToString(*r.targetConfiguration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTRootDiffInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePartStudioRequest struct {
	ctx                  context.Context
	ApiService           *PartStudioApiService
	did                  string
	wid                  string
	bTModelElementParams *BTModelElementParams
}

func (r ApiCreatePartStudioRequest) BTModelElementParams(bTModelElementParams BTModelElementParams) ApiCreatePartStudioRequest {
	r.bTModelElementParams = &bTModelElementParams
	return r
}

func (r ApiCreatePartStudioRequest) Execute() (*BTDocumentElementInfo, *http.Response, error) {
	return r.ApiService.CreatePartStudioExecute(r)
}

/*
CreatePartStudio Create Part Studio by document ID and workspace ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did Document ID.
 @param wid Workspace ID.
 @return ApiCreatePartStudioRequest
*/
func (a *PartStudioApiService) CreatePartStudio(ctx context.Context, did string, wid string) ApiCreatePartStudioRequest {
	return ApiCreatePartStudioRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
	}
}

// Execute executes the request
//  @return BTDocumentElementInfo
func (a *PartStudioApiService) CreatePartStudioExecute(r ApiCreatePartStudioRequest) (*BTDocumentElementInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTDocumentElementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.CreatePartStudio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/w/{wid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTModelElementParams == nil {
		return localVarReturnValue, nil, reportError("bTModelElementParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTModelElementParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTDocumentElementInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePartStudioTranslationRequest struct {
	ctx                     context.Context
	ApiService              *PartStudioApiService
	did                     string
	wv                      string
	wvid                    string
	eid                     string
	bTTranslateFormatParams *BTTranslateFormatParams
}

func (r ApiCreatePartStudioTranslationRequest) BTTranslateFormatParams(bTTranslateFormatParams BTTranslateFormatParams) ApiCreatePartStudioTranslationRequest {
	r.bTTranslateFormatParams = &bTTranslateFormatParams
	return r
}

func (r ApiCreatePartStudioTranslationRequest) Execute() (*BTTranslationRequestInfo, *http.Response, error) {
	return r.ApiService.CreatePartStudioTranslationExecute(r)
}

/*
CreatePartStudioTranslation Create Part Studio translation by document ID, workspace or version ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did Document ID.
 @param wv One of w or v corresponding to whether a workspace or version was specified.
 @param wvid Workspace (w) or Version (v) ID.
 @param eid Element ID.
 @return ApiCreatePartStudioTranslationRequest
*/
func (a *PartStudioApiService) CreatePartStudioTranslation(ctx context.Context, did string, wv string, wvid string, eid string) ApiCreatePartStudioTranslationRequest {
	return ApiCreatePartStudioTranslationRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wv:         wv,
		wvid:       wvid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTTranslationRequestInfo
func (a *PartStudioApiService) CreatePartStudioTranslationExecute(r ApiCreatePartStudioTranslationRequest) (*BTTranslationRequestInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTTranslationRequestInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.CreatePartStudioTranslation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wv}/{wvid}/e/{eid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wv"+"}", url.PathEscape(parameterToString(r.wv, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvid"+"}", url.PathEscape(parameterToString(r.wvid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTTranslateFormatParams == nil {
		return localVarReturnValue, nil, reportError("bTTranslateFormatParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTTranslateFormatParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTTranslationRequestInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePartStudioFeatureRequest struct {
	ctx        context.Context
	ApiService *PartStudioApiService
	did        string
	wid        string
	eid        string
	fid        string
}

func (r ApiDeletePartStudioFeatureRequest) Execute() (*BTFeatureApiBase1430, *http.Response, error) {
	return r.ApiService.DeletePartStudioFeatureExecute(r)
}

/*
DeletePartStudioFeature Delete feature by document ID, workspace ID, tab ID, and feature ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did Document ID.
 @param wid Workspace ID.
 @param eid Element ID.
 @param fid The id of the feature being updated. This id should be URL encoded and must match the featureId found in the serialized structure
 @return ApiDeletePartStudioFeatureRequest
*/
func (a *PartStudioApiService) DeletePartStudioFeature(ctx context.Context, did string, wid string, eid string, fid string) ApiDeletePartStudioFeatureRequest {
	return ApiDeletePartStudioFeatureRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
		fid:        fid,
	}
}

// Execute executes the request
//  @return BTFeatureApiBase1430
func (a *PartStudioApiService) DeletePartStudioFeatureExecute(r ApiDeletePartStudioFeatureRequest) (*BTFeatureApiBase1430, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTFeatureApiBase1430
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.DeletePartStudioFeature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/w/{wid}/e/{eid}/features/featureid/{fid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fid"+"}", url.PathEscape(parameterToString(r.fid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTFeatureApiBase1430
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEvalFeatureScriptRequest struct {
	ctx                         context.Context
	ApiService                  *PartStudioApiService
	did                         string
	wvm                         string
	wvmid                       string
	eid                         string
	linkDocumentId              *string
	configuration               *string
	rollbackBarIndex            *int32
	elementMicroversionId       *string
	bTFeatureScriptEvalCall2377 *BTFeatureScriptEvalCall2377
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiEvalFeatureScriptRequest) LinkDocumentId(linkDocumentId string) ApiEvalFeatureScriptRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiEvalFeatureScriptRequest) Configuration(configuration string) ApiEvalFeatureScriptRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiEvalFeatureScriptRequest) RollbackBarIndex(rollbackBarIndex int32) ApiEvalFeatureScriptRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

func (r ApiEvalFeatureScriptRequest) ElementMicroversionId(elementMicroversionId string) ApiEvalFeatureScriptRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiEvalFeatureScriptRequest) BTFeatureScriptEvalCall2377(bTFeatureScriptEvalCall2377 BTFeatureScriptEvalCall2377) ApiEvalFeatureScriptRequest {
	r.bTFeatureScriptEvalCall2377 = &bTFeatureScriptEvalCall2377
	return r
}

func (r ApiEvalFeatureScriptRequest) Execute() (*BTFeatureScriptEvalResponse1859, *http.Response, error) {
	return r.ApiService.EvalFeatureScriptExecute(r)
}

/*
EvalFeatureScript Evaluate FeatureScript for a Part Studio by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace id, version id, or document microversion id is specified below.
 @param wvmid The id of the workspace, version, or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @return ApiEvalFeatureScriptRequest
*/
func (a *PartStudioApiService) EvalFeatureScript(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiEvalFeatureScriptRequest {
	return ApiEvalFeatureScriptRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTFeatureScriptEvalResponse1859
func (a *PartStudioApiService) EvalFeatureScriptExecute(r ApiEvalFeatureScriptRequest) (*BTFeatureScriptEvalResponse1859, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTFeatureScriptEvalResponse1859
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.EvalFeatureScript")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/featurescript"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTFeatureScriptEvalCall2377
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTFeatureScriptEvalResponse1859
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportParasolidRequest struct {
	ctx              context.Context
	ApiService       *PartStudioApiService
	did              string
	wvm              string
	wvmid            string
	eid              string
	partIds          *string
	version          *string
	includeExportIds *bool
	configuration    *string
	linkDocumentId   *string
}

// IDs of the parts to retrieve. Repeat query param to add more than one (i.e. partId&#x3D;JHK&amp;partId&#x3D;JHD). May not be combined with other ID filters
func (r ApiExportParasolidRequest) PartIds(partIds string) ApiExportParasolidRequest {
	r.partIds = &partIds
	return r
}

// Parasolid version
func (r ApiExportParasolidRequest) Version(version string) ApiExportParasolidRequest {
	r.version = &version
	return r
}

// Whether topolgy ids should be exported as parasolid attributes
func (r ApiExportParasolidRequest) IncludeExportIds(includeExportIds bool) ApiExportParasolidRequest {
	r.includeExportIds = &includeExportIds
	return r
}

// Configuration string.
func (r ApiExportParasolidRequest) Configuration(configuration string) ApiExportParasolidRequest {
	r.configuration = &configuration
	return r
}

// Id of document that links to the document being accessed. This may provide additional access rights to the document. Allowed only with version (v) path parameter.
func (r ApiExportParasolidRequest) LinkDocumentId(linkDocumentId string) ApiExportParasolidRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiExportParasolidRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExportParasolidExecute(r)
}

/*
ExportParasolid Export Part Studio to Parasolid by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did Document ID.
 @param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
 @param wvmid Workspace (w), Version (v) or Microversion (m) ID.
 @param eid Element ID.
 @return ApiExportParasolidRequest
*/
func (a *PartStudioApiService) ExportParasolid(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiExportParasolidRequest {
	return ApiExportParasolidRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
func (a *PartStudioApiService) ExportParasolidExecute(r ApiExportParasolidRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.ExportParasolid")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/parasolid"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.partIds != nil {
		localVarQueryParams.Add("partIds", parameterToString(*r.partIds, ""))
	}
	if r.version != nil {
		localVarQueryParams.Add("version", parameterToString(*r.version, ""))
	}
	if r.includeExportIds != nil {
		localVarQueryParams.Add("includeExportIds", parameterToString(*r.includeExportIds, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExportPartStudioGltfRequest struct {
	ctx                      context.Context
	ApiService               *PartStudioApiService
	did                      string
	wvm                      string
	wvmid                    string
	eid                      string
	linkDocumentId           *string
	configuration            *string
	rollbackBarIndex         *int32
	elementMicroversionId    *string
	partId                   *[]string
	angleTolerance           *float64
	chordTolerance           *float64
	precomputedLevelOfDetail *string
	outputSeparateFaceNodes  *bool
	faceId                   *[]string
	outputFaceAppearances    *bool
	maxFacetWidth            *float64
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiExportPartStudioGltfRequest) LinkDocumentId(linkDocumentId string) ApiExportPartStudioGltfRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiExportPartStudioGltfRequest) Configuration(configuration string) ApiExportPartStudioGltfRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiExportPartStudioGltfRequest) RollbackBarIndex(rollbackBarIndex int32) ApiExportPartStudioGltfRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

func (r ApiExportPartStudioGltfRequest) ElementMicroversionId(elementMicroversionId string) ApiExportPartStudioGltfRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiExportPartStudioGltfRequest) PartId(partId []string) ApiExportPartStudioGltfRequest {
	r.partId = &partId
	return r
}

func (r ApiExportPartStudioGltfRequest) AngleTolerance(angleTolerance float64) ApiExportPartStudioGltfRequest {
	r.angleTolerance = &angleTolerance
	return r
}

func (r ApiExportPartStudioGltfRequest) ChordTolerance(chordTolerance float64) ApiExportPartStudioGltfRequest {
	r.chordTolerance = &chordTolerance
	return r
}

func (r ApiExportPartStudioGltfRequest) PrecomputedLevelOfDetail(precomputedLevelOfDetail string) ApiExportPartStudioGltfRequest {
	r.precomputedLevelOfDetail = &precomputedLevelOfDetail
	return r
}

func (r ApiExportPartStudioGltfRequest) OutputSeparateFaceNodes(outputSeparateFaceNodes bool) ApiExportPartStudioGltfRequest {
	r.outputSeparateFaceNodes = &outputSeparateFaceNodes
	return r
}

func (r ApiExportPartStudioGltfRequest) FaceId(faceId []string) ApiExportPartStudioGltfRequest {
	r.faceId = &faceId
	return r
}

func (r ApiExportPartStudioGltfRequest) OutputFaceAppearances(outputFaceAppearances bool) ApiExportPartStudioGltfRequest {
	r.outputFaceAppearances = &outputFaceAppearances
	return r
}

func (r ApiExportPartStudioGltfRequest) MaxFacetWidth(maxFacetWidth float64) ApiExportPartStudioGltfRequest {
	r.maxFacetWidth = &maxFacetWidth
	return r
}

func (r ApiExportPartStudioGltfRequest) Execute() (*HttpFile, *http.Response, error) {
	return r.ApiService.ExportPartStudioGltfExecute(r)
}

/*
ExportPartStudioGltf Export GLTF representation for parts in a Part Studio by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace id, version id, or document microversion id is specified below.
 @param wvmid The id of the workspace, version, or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @return ApiExportPartStudioGltfRequest
*/
func (a *PartStudioApiService) ExportPartStudioGltf(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiExportPartStudioGltfRequest {
	return ApiExportPartStudioGltfRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return HttpFile
func (a *PartStudioApiService) ExportPartStudioGltfExecute(r ApiExportPartStudioGltfRequest) (*HttpFile, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *HttpFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.ExportPartStudioGltf")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/gltf"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	if r.partId != nil {
		t := *r.partId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("partId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("partId", parameterToString(t, "multi"))
		}
	}
	if r.angleTolerance != nil {
		localVarQueryParams.Add("angleTolerance", parameterToString(*r.angleTolerance, ""))
	}
	if r.chordTolerance != nil {
		localVarQueryParams.Add("chordTolerance", parameterToString(*r.chordTolerance, ""))
	}
	if r.precomputedLevelOfDetail != nil {
		localVarQueryParams.Add("precomputedLevelOfDetail", parameterToString(*r.precomputedLevelOfDetail, ""))
	}
	if r.outputSeparateFaceNodes != nil {
		localVarQueryParams.Add("outputSeparateFaceNodes", parameterToString(*r.outputSeparateFaceNodes, ""))
	}
	if r.faceId != nil {
		t := *r.faceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("faceId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("faceId", parameterToString(t, "multi"))
		}
	}
	if r.outputFaceAppearances != nil {
		localVarQueryParams.Add("outputFaceAppearances", parameterToString(*r.outputFaceAppearances, ""))
	}
	if r.maxFacetWidth != nil {
		localVarQueryParams.Add("maxFacetWidth", parameterToString(*r.maxFacetWidth, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"model/gltf-binary;qs=0.08"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportPartStudioStlRequest struct {
	ctx            context.Context
	ApiService     *PartStudioApiService
	did            string
	wvm            string
	wvmid          string
	eid            string
	partIds        *string
	mode           *string
	grouping       *bool
	scale          *float64
	units          *string
	angleTolerance *float64
	chordTolerance *float64
	maxFacetWidth  *float64
	minFacetWidth  *float64
	configuration  *string
	linkDocumentId *string
}

// IDs of the parts to retrieve. Repeat query param to add more than one (i.e. partId&#x3D;JHK&amp;partId&#x3D;JHD). May not be combined with other ID filters
func (r ApiExportPartStudioStlRequest) PartIds(partIds string) ApiExportPartStudioStlRequest {
	r.partIds = &partIds
	return r
}

// Type of file: text, binary
func (r ApiExportPartStudioStlRequest) Mode(mode string) ApiExportPartStudioStlRequest {
	r.mode = &mode
	return r
}

// Whether parts should be exported as a group or individually in a .zip file
func (r ApiExportPartStudioStlRequest) Grouping(grouping bool) ApiExportPartStudioStlRequest {
	r.grouping = &grouping
	return r
}

// Scale for measurements.
func (r ApiExportPartStudioStlRequest) Scale(scale float64) ApiExportPartStudioStlRequest {
	r.scale = &scale
	return r
}

// Name of base unit (meter, centimeter, millimeter, inch, foot, or yard)
func (r ApiExportPartStudioStlRequest) Units(units string) ApiExportPartStudioStlRequest {
	r.units = &units
	return r
}

// Angle tolerance (in radians). This specifies the limit on the sum of the angular deviations of a tessellation chord from the tangent vectors at two chord endpoints. The specified value must be less than PI/2. This parameter currently has a default value chosen based on the complexity of the parts being tessellated.
func (r ApiExportPartStudioStlRequest) AngleTolerance(angleTolerance float64) ApiExportPartStudioStlRequest {
	r.angleTolerance = &angleTolerance
	return r
}

// Chord tolerance (in meters). This specifies the limit on the maximum deviation of a tessellation chord from the true surface/edge. This parameter currently has a default value chosen based on the size and complexity of the parts being tessellated.
func (r ApiExportPartStudioStlRequest) ChordTolerance(chordTolerance float64) ApiExportPartStudioStlRequest {
	r.chordTolerance = &chordTolerance
	return r
}

// Max facet width. This specifies the limit on the size of any side of a tessellation facet.
func (r ApiExportPartStudioStlRequest) MaxFacetWidth(maxFacetWidth float64) ApiExportPartStudioStlRequest {
	r.maxFacetWidth = &maxFacetWidth
	return r
}

// Max facet width. This specifies the limit on the size of any side of a tessellation facet.
func (r ApiExportPartStudioStlRequest) MinFacetWidth(minFacetWidth float64) ApiExportPartStudioStlRequest {
	r.minFacetWidth = &minFacetWidth
	return r
}

// Configuration string.
func (r ApiExportPartStudioStlRequest) Configuration(configuration string) ApiExportPartStudioStlRequest {
	r.configuration = &configuration
	return r
}

// Id of document that links to the document being accessed. This may provide additional access rights to the document. Allowed only with version (v) path parameter.
func (r ApiExportPartStudioStlRequest) LinkDocumentId(linkDocumentId string) ApiExportPartStudioStlRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiExportPartStudioStlRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExportPartStudioStlExecute(r)
}

/*
ExportPartStudioStl Export Part Studio to STL by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did Document ID.
 @param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
 @param wvmid Workspace (w), Version (v) or Microversion (m) ID.
 @param eid Element ID.
 @return ApiExportPartStudioStlRequest
*/
func (a *PartStudioApiService) ExportPartStudioStl(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiExportPartStudioStlRequest {
	return ApiExportPartStudioStlRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
func (a *PartStudioApiService) ExportPartStudioStlExecute(r ApiExportPartStudioStlRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.ExportPartStudioStl")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/stl"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.partIds != nil {
		localVarQueryParams.Add("partIds", parameterToString(*r.partIds, ""))
	}
	if r.mode != nil {
		localVarQueryParams.Add("mode", parameterToString(*r.mode, ""))
	}
	if r.grouping != nil {
		localVarQueryParams.Add("grouping", parameterToString(*r.grouping, ""))
	}
	if r.scale != nil {
		localVarQueryParams.Add("scale", parameterToString(*r.scale, ""))
	}
	if r.units != nil {
		localVarQueryParams.Add("units", parameterToString(*r.units, ""))
	}
	if r.angleTolerance != nil {
		localVarQueryParams.Add("angleTolerance", parameterToString(*r.angleTolerance, ""))
	}
	if r.chordTolerance != nil {
		localVarQueryParams.Add("chordTolerance", parameterToString(*r.chordTolerance, ""))
	}
	if r.maxFacetWidth != nil {
		localVarQueryParams.Add("maxFacetWidth", parameterToString(*r.maxFacetWidth, ""))
	}
	if r.minFacetWidth != nil {
		localVarQueryParams.Add("minFacetWidth", parameterToString(*r.minFacetWidth, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetFeatureScriptRepresentationRequest struct {
	ctx                   context.Context
	ApiService            *PartStudioApiService
	did                   string
	wvm                   string
	wvmid                 string
	eid                   string
	linkDocumentId        *string
	configuration         *string
	rollbackBarIndex      *int32
	elementMicroversionId *string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetFeatureScriptRepresentationRequest) LinkDocumentId(linkDocumentId string) ApiGetFeatureScriptRepresentationRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetFeatureScriptRepresentationRequest) Configuration(configuration string) ApiGetFeatureScriptRepresentationRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiGetFeatureScriptRepresentationRequest) RollbackBarIndex(rollbackBarIndex int32) ApiGetFeatureScriptRepresentationRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

func (r ApiGetFeatureScriptRepresentationRequest) ElementMicroversionId(elementMicroversionId string) ApiGetFeatureScriptRepresentationRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiGetFeatureScriptRepresentationRequest) Execute() (*BTPModule234, *http.Response, error) {
	return r.ApiService.GetFeatureScriptRepresentationExecute(r)
}

/*
GetFeatureScriptRepresentation Retrieve FeatureScript representation of the Part Studio by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace id, version id, or document microversion id is specified below.
 @param wvmid The id of the workspace, version, or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @return ApiGetFeatureScriptRepresentationRequest
*/
func (a *PartStudioApiService) GetFeatureScriptRepresentation(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetFeatureScriptRepresentationRequest {
	return ApiGetFeatureScriptRepresentationRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTPModule234
func (a *PartStudioApiService) GetFeatureScriptRepresentationExecute(r ApiGetFeatureScriptRepresentationRequest) (*BTPModule234, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTPModule234
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.GetFeatureScriptRepresentation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/featurescriptrepresentation"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTPModule234
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFeatureScriptTableRequest struct {
	ctx             context.Context
	ApiService      *PartStudioApiService
	did             string
	wvm             string
	wvmid           string
	eid             string
	tableType       *string
	configuration   *string
	tableNamespace  *string
	tableParameters *string
	partId          *string
	linkDocumentId  *string
}

func (r ApiGetFeatureScriptTableRequest) TableType(tableType string) ApiGetFeatureScriptTableRequest {
	r.tableType = &tableType
	return r
}

func (r ApiGetFeatureScriptTableRequest) Configuration(configuration string) ApiGetFeatureScriptTableRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetFeatureScriptTableRequest) TableNamespace(tableNamespace string) ApiGetFeatureScriptTableRequest {
	r.tableNamespace = &tableNamespace
	return r
}

func (r ApiGetFeatureScriptTableRequest) TableParameters(tableParameters string) ApiGetFeatureScriptTableRequest {
	r.tableParameters = &tableParameters
	return r
}

func (r ApiGetFeatureScriptTableRequest) PartId(partId string) ApiGetFeatureScriptTableRequest {
	r.partId = &partId
	return r
}

func (r ApiGetFeatureScriptTableRequest) LinkDocumentId(linkDocumentId string) ApiGetFeatureScriptTableRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetFeatureScriptTableRequest) Execute() (*BTApiTableList1223, *http.Response, error) {
	return r.ApiService.GetFeatureScriptTableExecute(r)
}

/*
GetFeatureScriptTable Retrieve FeatureScript table of the Part Studio or part by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wvm
 @param wvmid
 @param eid
 @return ApiGetFeatureScriptTableRequest
*/
func (a *PartStudioApiService) GetFeatureScriptTable(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetFeatureScriptTableRequest {
	return ApiGetFeatureScriptTableRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTApiTableList1223
func (a *PartStudioApiService) GetFeatureScriptTableExecute(r ApiGetFeatureScriptTableRequest) (*BTApiTableList1223, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTApiTableList1223
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.GetFeatureScriptTable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/fstable"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tableType == nil {
		return localVarReturnValue, nil, reportError("tableType is required and must be specified")
	}

	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.tableNamespace != nil {
		localVarQueryParams.Add("tableNamespace", parameterToString(*r.tableNamespace, ""))
	}
	localVarQueryParams.Add("tableType", parameterToString(*r.tableType, ""))
	if r.tableParameters != nil {
		localVarQueryParams.Add("tableParameters", parameterToString(*r.tableParameters, ""))
	}
	if r.partId != nil {
		localVarQueryParams.Add("partId", parameterToString(*r.partId, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTApiTableList1223
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartStudioBodyDetailsRequest struct {
	ctx                   context.Context
	ApiService            *PartStudioApiService
	did                   string
	wvm                   string
	wvmid                 string
	eid                   string
	linkDocumentId        *string
	configuration         *string
	rollbackBarIndex      *int32
	elementMicroversionId *string
	includeSurfaces       *bool
	includeCompositeParts *bool
	includeGeometricData  *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetPartStudioBodyDetailsRequest) LinkDocumentId(linkDocumentId string) ApiGetPartStudioBodyDetailsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetPartStudioBodyDetailsRequest) Configuration(configuration string) ApiGetPartStudioBodyDetailsRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiGetPartStudioBodyDetailsRequest) RollbackBarIndex(rollbackBarIndex int32) ApiGetPartStudioBodyDetailsRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

func (r ApiGetPartStudioBodyDetailsRequest) ElementMicroversionId(elementMicroversionId string) ApiGetPartStudioBodyDetailsRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

// Whether or not surfaces should be included in the response.
func (r ApiGetPartStudioBodyDetailsRequest) IncludeSurfaces(includeSurfaces bool) ApiGetPartStudioBodyDetailsRequest {
	r.includeSurfaces = &includeSurfaces
	return r
}

// Whether or not composite parts should be included in the response.
func (r ApiGetPartStudioBodyDetailsRequest) IncludeCompositeParts(includeCompositeParts bool) ApiGetPartStudioBodyDetailsRequest {
	r.includeCompositeParts = &includeCompositeParts
	return r
}

// Whether or not geometric data should be included in the response.
func (r ApiGetPartStudioBodyDetailsRequest) IncludeGeometricData(includeGeometricData bool) ApiGetPartStudioBodyDetailsRequest {
	r.includeGeometricData = &includeGeometricData
	return r
}

func (r ApiGetPartStudioBodyDetailsRequest) Execute() (*BTExportModelBodiesResponse734, *http.Response, error) {
	return r.ApiService.GetPartStudioBodyDetailsExecute(r)
}

/*
GetPartStudioBodyDetails Retrieve an array of body details by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace id, version id, or document microversion id is specified below.
 @param wvmid The id of the workspace, version, or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @return ApiGetPartStudioBodyDetailsRequest
*/
func (a *PartStudioApiService) GetPartStudioBodyDetails(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetPartStudioBodyDetailsRequest {
	return ApiGetPartStudioBodyDetailsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTExportModelBodiesResponse734
func (a *PartStudioApiService) GetPartStudioBodyDetailsExecute(r ApiGetPartStudioBodyDetailsRequest) (*BTExportModelBodiesResponse734, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTExportModelBodiesResponse734
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.GetPartStudioBodyDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/bodydetails"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	if r.includeSurfaces != nil {
		localVarQueryParams.Add("includeSurfaces", parameterToString(*r.includeSurfaces, ""))
	}
	if r.includeCompositeParts != nil {
		localVarQueryParams.Add("includeCompositeParts", parameterToString(*r.includeCompositeParts, ""))
	}
	if r.includeGeometricData != nil {
		localVarQueryParams.Add("includeGeometricData", parameterToString(*r.includeGeometricData, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTExportModelBodiesResponse734
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartStudioBoundingBoxesRequest struct {
	ctx               context.Context
	ApiService        *PartStudioApiService
	did               string
	wvm               string
	wvmid             string
	eid               string
	includeHidden     *bool
	includeWireBodies *bool
	configuration     *string
	linkDocumentId    *string
}

// Whether or not to include bounding boxes for hidden parts.
func (r ApiGetPartStudioBoundingBoxesRequest) IncludeHidden(includeHidden bool) ApiGetPartStudioBoundingBoxesRequest {
	r.includeHidden = &includeHidden
	return r
}

// Whether to include wire bodies in the bounding box.
func (r ApiGetPartStudioBoundingBoxesRequest) IncludeWireBodies(includeWireBodies bool) ApiGetPartStudioBoundingBoxesRequest {
	r.includeWireBodies = &includeWireBodies
	return r
}

// Configuration string.
func (r ApiGetPartStudioBoundingBoxesRequest) Configuration(configuration string) ApiGetPartStudioBoundingBoxesRequest {
	r.configuration = &configuration
	return r
}

// Id of document that links to the document being accessed. This may provide additional access rights to the document. Allowed only with version (v) path parameter.
func (r ApiGetPartStudioBoundingBoxesRequest) LinkDocumentId(linkDocumentId string) ApiGetPartStudioBoundingBoxesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetPartStudioBoundingBoxesRequest) Execute() (*BTBoundingBoxInfo, *http.Response, error) {
	return r.ApiService.GetPartStudioBoundingBoxesExecute(r)
}

/*
GetPartStudioBoundingBoxes Retrieve an array of Mass properties of parts or a Part Studio by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did Document ID.
 @param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
 @param wvmid Workspace (w), Version (v) or Microversion (m) ID.
 @param eid Element ID.
 @return ApiGetPartStudioBoundingBoxesRequest
*/
func (a *PartStudioApiService) GetPartStudioBoundingBoxes(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetPartStudioBoundingBoxesRequest {
	return ApiGetPartStudioBoundingBoxesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTBoundingBoxInfo
func (a *PartStudioApiService) GetPartStudioBoundingBoxesExecute(r ApiGetPartStudioBoundingBoxesRequest) (*BTBoundingBoxInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTBoundingBoxInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.GetPartStudioBoundingBoxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/boundingboxes"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeHidden != nil {
		localVarQueryParams.Add("includeHidden", parameterToString(*r.includeHidden, ""))
	}
	if r.includeWireBodies != nil {
		localVarQueryParams.Add("includeWireBodies", parameterToString(*r.includeWireBodies, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTBoundingBoxInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartStudioEdgesRequest struct {
	ctx                      context.Context
	ApiService               *PartStudioApiService
	did                      string
	wvm                      string
	wvmid                    string
	eid                      string
	linkDocumentId           *string
	configuration            *string
	rollbackBarIndex         *int32
	elementMicroversionId    *string
	partId                   *[]string
	angleTolerance           *float64
	chordTolerance           *float64
	precomputedLevelOfDetail *string
	edgeId                   *[]string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetPartStudioEdgesRequest) LinkDocumentId(linkDocumentId string) ApiGetPartStudioEdgesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetPartStudioEdgesRequest) Configuration(configuration string) ApiGetPartStudioEdgesRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiGetPartStudioEdgesRequest) RollbackBarIndex(rollbackBarIndex int32) ApiGetPartStudioEdgesRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

func (r ApiGetPartStudioEdgesRequest) ElementMicroversionId(elementMicroversionId string) ApiGetPartStudioEdgesRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiGetPartStudioEdgesRequest) PartId(partId []string) ApiGetPartStudioEdgesRequest {
	r.partId = &partId
	return r
}

func (r ApiGetPartStudioEdgesRequest) AngleTolerance(angleTolerance float64) ApiGetPartStudioEdgesRequest {
	r.angleTolerance = &angleTolerance
	return r
}

func (r ApiGetPartStudioEdgesRequest) ChordTolerance(chordTolerance float64) ApiGetPartStudioEdgesRequest {
	r.chordTolerance = &chordTolerance
	return r
}

func (r ApiGetPartStudioEdgesRequest) PrecomputedLevelOfDetail(precomputedLevelOfDetail string) ApiGetPartStudioEdgesRequest {
	r.precomputedLevelOfDetail = &precomputedLevelOfDetail
	return r
}

func (r ApiGetPartStudioEdgesRequest) EdgeId(edgeId []string) ApiGetPartStudioEdgesRequest {
	r.edgeId = &edgeId
	return r
}

func (r ApiGetPartStudioEdgesRequest) Execute() (*BTExportTessellatedEdgesResponse327, *http.Response, error) {
	return r.ApiService.GetPartStudioEdgesExecute(r)
}

/*
GetPartStudioEdges Retrieve tessellated edges of the parts in the Part Studio by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace id, version id, or document microversion id is specified below.
 @param wvmid The id of the workspace, version, or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @return ApiGetPartStudioEdgesRequest
*/
func (a *PartStudioApiService) GetPartStudioEdges(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetPartStudioEdgesRequest {
	return ApiGetPartStudioEdgesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTExportTessellatedEdgesResponse327
func (a *PartStudioApiService) GetPartStudioEdgesExecute(r ApiGetPartStudioEdgesRequest) (*BTExportTessellatedEdgesResponse327, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTExportTessellatedEdgesResponse327
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.GetPartStudioEdges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/tessellatededges"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	if r.partId != nil {
		t := *r.partId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("partId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("partId", parameterToString(t, "multi"))
		}
	}
	if r.angleTolerance != nil {
		localVarQueryParams.Add("angleTolerance", parameterToString(*r.angleTolerance, ""))
	}
	if r.chordTolerance != nil {
		localVarQueryParams.Add("chordTolerance", parameterToString(*r.chordTolerance, ""))
	}
	if r.precomputedLevelOfDetail != nil {
		localVarQueryParams.Add("precomputedLevelOfDetail", parameterToString(*r.precomputedLevelOfDetail, ""))
	}
	if r.edgeId != nil {
		t := *r.edgeId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("edgeId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("edgeId", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTExportTessellatedEdgesResponse327
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartStudioFacesRequest struct {
	ctx                              context.Context
	ApiService                       *PartStudioApiService
	did                              string
	wvm                              string
	wvmid                            string
	eid                              string
	linkDocumentId                   *string
	configuration                    *string
	rollbackBarIndex                 *int32
	elementMicroversionId            *string
	partId                           *[]string
	angleTolerance                   *float64
	chordTolerance                   *float64
	precomputedLevelOfDetail         *string
	faceId                           *[]string
	outputFaceAppearances            *bool
	maxFacetWidth                    *float64
	outputVertexNormals              *bool
	outputFacetNormals               *bool
	outputTextureCoordinates         *bool
	outputIndexTable                 *bool
	outputErrorFaces                 *bool
	combineCompositePartConstituents *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetPartStudioFacesRequest) LinkDocumentId(linkDocumentId string) ApiGetPartStudioFacesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetPartStudioFacesRequest) Configuration(configuration string) ApiGetPartStudioFacesRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiGetPartStudioFacesRequest) RollbackBarIndex(rollbackBarIndex int32) ApiGetPartStudioFacesRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

func (r ApiGetPartStudioFacesRequest) ElementMicroversionId(elementMicroversionId string) ApiGetPartStudioFacesRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiGetPartStudioFacesRequest) PartId(partId []string) ApiGetPartStudioFacesRequest {
	r.partId = &partId
	return r
}

func (r ApiGetPartStudioFacesRequest) AngleTolerance(angleTolerance float64) ApiGetPartStudioFacesRequest {
	r.angleTolerance = &angleTolerance
	return r
}

func (r ApiGetPartStudioFacesRequest) ChordTolerance(chordTolerance float64) ApiGetPartStudioFacesRequest {
	r.chordTolerance = &chordTolerance
	return r
}

func (r ApiGetPartStudioFacesRequest) PrecomputedLevelOfDetail(precomputedLevelOfDetail string) ApiGetPartStudioFacesRequest {
	r.precomputedLevelOfDetail = &precomputedLevelOfDetail
	return r
}

func (r ApiGetPartStudioFacesRequest) FaceId(faceId []string) ApiGetPartStudioFacesRequest {
	r.faceId = &faceId
	return r
}

func (r ApiGetPartStudioFacesRequest) OutputFaceAppearances(outputFaceAppearances bool) ApiGetPartStudioFacesRequest {
	r.outputFaceAppearances = &outputFaceAppearances
	return r
}

func (r ApiGetPartStudioFacesRequest) MaxFacetWidth(maxFacetWidth float64) ApiGetPartStudioFacesRequest {
	r.maxFacetWidth = &maxFacetWidth
	return r
}

func (r ApiGetPartStudioFacesRequest) OutputVertexNormals(outputVertexNormals bool) ApiGetPartStudioFacesRequest {
	r.outputVertexNormals = &outputVertexNormals
	return r
}

func (r ApiGetPartStudioFacesRequest) OutputFacetNormals(outputFacetNormals bool) ApiGetPartStudioFacesRequest {
	r.outputFacetNormals = &outputFacetNormals
	return r
}

func (r ApiGetPartStudioFacesRequest) OutputTextureCoordinates(outputTextureCoordinates bool) ApiGetPartStudioFacesRequest {
	r.outputTextureCoordinates = &outputTextureCoordinates
	return r
}

func (r ApiGetPartStudioFacesRequest) OutputIndexTable(outputIndexTable bool) ApiGetPartStudioFacesRequest {
	r.outputIndexTable = &outputIndexTable
	return r
}

func (r ApiGetPartStudioFacesRequest) OutputErrorFaces(outputErrorFaces bool) ApiGetPartStudioFacesRequest {
	r.outputErrorFaces = &outputErrorFaces
	return r
}

func (r ApiGetPartStudioFacesRequest) CombineCompositePartConstituents(combineCompositePartConstituents bool) ApiGetPartStudioFacesRequest {
	r.combineCompositePartConstituents = &combineCompositePartConstituents
	return r
}

func (r ApiGetPartStudioFacesRequest) Execute() (*BTExportTessellatedFacesResponse898, *http.Response, error) {
	return r.ApiService.GetPartStudioFacesExecute(r)
}

/*
GetPartStudioFaces Method for GetPartStudioFaces

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace id, version id, or document microversion id is specified below.
 @param wvmid The id of the workspace, version, or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @return ApiGetPartStudioFacesRequest
*/
func (a *PartStudioApiService) GetPartStudioFaces(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetPartStudioFacesRequest {
	return ApiGetPartStudioFacesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTExportTessellatedFacesResponse898
func (a *PartStudioApiService) GetPartStudioFacesExecute(r ApiGetPartStudioFacesRequest) (*BTExportTessellatedFacesResponse898, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTExportTessellatedFacesResponse898
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.GetPartStudioFaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/tessellatedfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	if r.partId != nil {
		t := *r.partId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("partId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("partId", parameterToString(t, "multi"))
		}
	}
	if r.angleTolerance != nil {
		localVarQueryParams.Add("angleTolerance", parameterToString(*r.angleTolerance, ""))
	}
	if r.chordTolerance != nil {
		localVarQueryParams.Add("chordTolerance", parameterToString(*r.chordTolerance, ""))
	}
	if r.precomputedLevelOfDetail != nil {
		localVarQueryParams.Add("precomputedLevelOfDetail", parameterToString(*r.precomputedLevelOfDetail, ""))
	}
	if r.faceId != nil {
		t := *r.faceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("faceId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("faceId", parameterToString(t, "multi"))
		}
	}
	if r.outputFaceAppearances != nil {
		localVarQueryParams.Add("outputFaceAppearances", parameterToString(*r.outputFaceAppearances, ""))
	}
	if r.maxFacetWidth != nil {
		localVarQueryParams.Add("maxFacetWidth", parameterToString(*r.maxFacetWidth, ""))
	}
	if r.outputVertexNormals != nil {
		localVarQueryParams.Add("outputVertexNormals", parameterToString(*r.outputVertexNormals, ""))
	}
	if r.outputFacetNormals != nil {
		localVarQueryParams.Add("outputFacetNormals", parameterToString(*r.outputFacetNormals, ""))
	}
	if r.outputTextureCoordinates != nil {
		localVarQueryParams.Add("outputTextureCoordinates", parameterToString(*r.outputTextureCoordinates, ""))
	}
	if r.outputIndexTable != nil {
		localVarQueryParams.Add("outputIndexTable", parameterToString(*r.outputIndexTable, ""))
	}
	if r.outputErrorFaces != nil {
		localVarQueryParams.Add("outputErrorFaces", parameterToString(*r.outputErrorFaces, ""))
	}
	if r.combineCompositePartConstituents != nil {
		localVarQueryParams.Add("combineCompositePartConstituents", parameterToString(*r.combineCompositePartConstituents, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTExportTessellatedFacesResponse898
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartStudioFeatureSpecsRequest struct {
	ctx        context.Context
	ApiService *PartStudioApiService
	did        string
	wvm        string
	wvmid      string
	eid        string
}

func (r ApiGetPartStudioFeatureSpecsRequest) Execute() (*BTFeatureSpecsResponse664, *http.Response, error) {
	return r.ApiService.GetPartStudioFeatureSpecsExecute(r)
}

/*
GetPartStudioFeatureSpecs Retrieve feature specifications of the Part Studio by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did Document ID.
 @param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
 @param wvmid Workspace (w), Version (v) or Microversion (m) ID.
 @param eid Element ID.
 @return ApiGetPartStudioFeatureSpecsRequest
*/
func (a *PartStudioApiService) GetPartStudioFeatureSpecs(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetPartStudioFeatureSpecsRequest {
	return ApiGetPartStudioFeatureSpecsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTFeatureSpecsResponse664
func (a *PartStudioApiService) GetPartStudioFeatureSpecsExecute(r ApiGetPartStudioFeatureSpecsRequest) (*BTFeatureSpecsResponse664, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTFeatureSpecsResponse664
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.GetPartStudioFeatureSpecs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/featurespecs"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTFeatureSpecsResponse664
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartStudioFeaturesRequest struct {
	ctx                context.Context
	ApiService         *PartStudioApiService
	did                string
	wvm                string
	wvmid              string
	eid                string
	includeGeometryIds *bool
	featureId          *[]string
	linkDocumentId     *string
	noSketchGeometry   *bool
}

func (r ApiGetPartStudioFeaturesRequest) IncludeGeometryIds(includeGeometryIds bool) ApiGetPartStudioFeaturesRequest {
	r.includeGeometryIds = &includeGeometryIds
	return r
}

// ID of a feature; repeat query param to add more than one
func (r ApiGetPartStudioFeaturesRequest) FeatureId(featureId []string) ApiGetPartStudioFeaturesRequest {
	r.featureId = &featureId
	return r
}

// Id of document that links to the document being accessed. This may provide additional access rights to the document. Allowed only with version (v) path parameter.
func (r ApiGetPartStudioFeaturesRequest) LinkDocumentId(linkDocumentId string) ApiGetPartStudioFeaturesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// Whether or not to output simple sketch info without geometry
func (r ApiGetPartStudioFeaturesRequest) NoSketchGeometry(noSketchGeometry bool) ApiGetPartStudioFeaturesRequest {
	r.noSketchGeometry = &noSketchGeometry
	return r
}

func (r ApiGetPartStudioFeaturesRequest) Execute() (*BTFeatureListResponse2457, *http.Response, error) {
	return r.ApiService.GetPartStudioFeaturesExecute(r)
}

/*
GetPartStudioFeatures Retrieve a feature list of parts or a Part Studio by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did Document ID.
 @param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
 @param wvmid Workspace (w), Version (v) or Microversion (m) ID.
 @param eid Element ID.
 @return ApiGetPartStudioFeaturesRequest
*/
func (a *PartStudioApiService) GetPartStudioFeatures(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetPartStudioFeaturesRequest {
	return ApiGetPartStudioFeaturesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTFeatureListResponse2457
func (a *PartStudioApiService) GetPartStudioFeaturesExecute(r ApiGetPartStudioFeaturesRequest) (*BTFeatureListResponse2457, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTFeatureListResponse2457
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.GetPartStudioFeatures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeGeometryIds != nil {
		localVarQueryParams.Add("includeGeometryIds", parameterToString(*r.includeGeometryIds, ""))
	}
	if r.featureId != nil {
		t := *r.featureId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("featureId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("featureId", parameterToString(t, "multi"))
		}
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.noSketchGeometry != nil {
		localVarQueryParams.Add("noSketchGeometry", parameterToString(*r.noSketchGeometry, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTFeatureListResponse2457
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartStudioMassPropertiesRequest struct {
	ctx                      context.Context
	ApiService               *PartStudioApiService
	did                      string
	wvm                      string
	wvmid                    string
	eid                      string
	linkDocumentId           *string
	configuration            *string
	rollbackBarIndex         *int32
	elementMicroversionId    *string
	partId                   *[]string
	massAsGroup              *bool
	useMassPropertyOverrides *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetPartStudioMassPropertiesRequest) LinkDocumentId(linkDocumentId string) ApiGetPartStudioMassPropertiesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetPartStudioMassPropertiesRequest) Configuration(configuration string) ApiGetPartStudioMassPropertiesRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiGetPartStudioMassPropertiesRequest) RollbackBarIndex(rollbackBarIndex int32) ApiGetPartStudioMassPropertiesRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

func (r ApiGetPartStudioMassPropertiesRequest) ElementMicroversionId(elementMicroversionId string) ApiGetPartStudioMassPropertiesRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiGetPartStudioMassPropertiesRequest) PartId(partId []string) ApiGetPartStudioMassPropertiesRequest {
	r.partId = &partId
	return r
}

// If true, specified parts will be evaluated as a single object instead of individually
func (r ApiGetPartStudioMassPropertiesRequest) MassAsGroup(massAsGroup bool) ApiGetPartStudioMassPropertiesRequest {
	r.massAsGroup = &massAsGroup
	return r
}

// If true, use the user mass property overrides when calculated mass properties
func (r ApiGetPartStudioMassPropertiesRequest) UseMassPropertyOverrides(useMassPropertyOverrides bool) ApiGetPartStudioMassPropertiesRequest {
	r.useMassPropertyOverrides = &useMassPropertyOverrides
	return r
}

func (r ApiGetPartStudioMassPropertiesRequest) Execute() (*BTMassPropertiesBulkInfo, *http.Response, error) {
	return r.ApiService.GetPartStudioMassPropertiesExecute(r)
}

/*
GetPartStudioMassProperties Retrieve mass properties of the Part Studio by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace id, version id, or document microversion id is specified below.
 @param wvmid The id of the workspace, version, or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @return ApiGetPartStudioMassPropertiesRequest
*/
func (a *PartStudioApiService) GetPartStudioMassProperties(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetPartStudioMassPropertiesRequest {
	return ApiGetPartStudioMassPropertiesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTMassPropertiesBulkInfo
func (a *PartStudioApiService) GetPartStudioMassPropertiesExecute(r ApiGetPartStudioMassPropertiesRequest) (*BTMassPropertiesBulkInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTMassPropertiesBulkInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.GetPartStudioMassProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/massproperties"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	if r.partId != nil {
		t := *r.partId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("partId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("partId", parameterToString(t, "multi"))
		}
	}
	if r.massAsGroup != nil {
		localVarQueryParams.Add("massAsGroup", parameterToString(*r.massAsGroup, ""))
	}
	if r.useMassPropertyOverrides != nil {
		localVarQueryParams.Add("useMassPropertyOverrides", parameterToString(*r.useMassPropertyOverrides, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTMassPropertiesBulkInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartStudioNamedViewsRequest struct {
	ctx                    context.Context
	ApiService             *PartStudioApiService
	did                    string
	eid                    string
	linkDocumentId         *string
	skipPerspective        *bool
	includeSectionCutViews *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetPartStudioNamedViewsRequest) LinkDocumentId(linkDocumentId string) ApiGetPartStudioNamedViewsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetPartStudioNamedViewsRequest) SkipPerspective(skipPerspective bool) ApiGetPartStudioNamedViewsRequest {
	r.skipPerspective = &skipPerspective
	return r
}

func (r ApiGetPartStudioNamedViewsRequest) IncludeSectionCutViews(includeSectionCutViews bool) ApiGetPartStudioNamedViewsRequest {
	r.includeSectionCutViews = &includeSectionCutViews
	return r
}

func (r ApiGetPartStudioNamedViewsRequest) Execute() (*BTNamedViewsInfo, *http.Response, error) {
	return r.ApiService.GetPartStudioNamedViewsExecute(r)
}

/*
GetPartStudioNamedViews Method for GetPartStudioNamedViews

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param eid
 @return ApiGetPartStudioNamedViewsRequest
*/
func (a *PartStudioApiService) GetPartStudioNamedViews(ctx context.Context, did string, eid string) ApiGetPartStudioNamedViewsRequest {
	return ApiGetPartStudioNamedViewsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTNamedViewsInfo
func (a *PartStudioApiService) GetPartStudioNamedViewsExecute(r ApiGetPartStudioNamedViewsRequest) (*BTNamedViewsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTNamedViewsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.GetPartStudioNamedViews")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/e/{eid}/namedViews"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.skipPerspective != nil {
		localVarQueryParams.Add("skipPerspective", parameterToString(*r.skipPerspective, ""))
	}
	if r.includeSectionCutViews != nil {
		localVarQueryParams.Add("includeSectionCutViews", parameterToString(*r.includeSectionCutViews, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTNamedViewsInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartStudioShadedViewsRequest struct {
	ctx             context.Context
	ApiService      *PartStudioApiService
	did             string
	wvm             string
	wvmid           string
	eid             string
	viewMatrix      *string
	outputHeight    *int32
	outputWidth     *int32
	pixelSize       *float64
	edges           *string
	showAllParts    *bool
	includeSurfaces *bool
	useAntiAliasing *bool
	includeWires    *bool
	configuration   *string
	linkDocumentId  *string
}

// 12-number view matrix (comma-separated), or one of the following named views: top, bottom, front, back, left, right The 12 entries in the view matrix form three rows and four columns, which is a linear transformation applied to the model itself. The matrix&#39;s first three columns maps the coordinate axes of the model to the coordinate axes of the view, and the fourth column translates the origin (in meters). The view coordinates have x pointing right, y pointing up, and z pointing towards the viewer, while a front view of the model has x pointing right, y pointing away from the viewer, and z pointing up. For example, the identity matrix viewMatrix&#x3D;1,0,0,0,0,1,0,0,0,0,1,0 corresponds to the top view, and viewMatrix&#x3D;0.612,0.612,0,0,-0.354,0.354,0.707,0,0.707,-0.707,0.707,0 corresponds (approximately) to the isometric view. The first three columns of the view matrix should be orthonormal and have a positive determinant.  If this is not the case, view behavior may be undefined.
func (r ApiGetPartStudioShadedViewsRequest) ViewMatrix(viewMatrix string) ApiGetPartStudioShadedViewsRequest {
	r.viewMatrix = &viewMatrix
	return r
}

// Output image height (in pixels)
func (r ApiGetPartStudioShadedViewsRequest) OutputHeight(outputHeight int32) ApiGetPartStudioShadedViewsRequest {
	r.outputHeight = &outputHeight
	return r
}

// Output image width (in pixels)
func (r ApiGetPartStudioShadedViewsRequest) OutputWidth(outputWidth int32) ApiGetPartStudioShadedViewsRequest {
	r.outputWidth = &outputWidth
	return r
}

// Height and width represented by each pixel (in meters). If the value is 0, the display will be sized to fit the output image dimensions.
func (r ApiGetPartStudioShadedViewsRequest) PixelSize(pixelSize float64) ApiGetPartStudioShadedViewsRequest {
	r.pixelSize = &pixelSize
	return r
}

// The treatment to be applied to edges in the display. Options are show: show visible edges, hide: hide visible edges.
func (r ApiGetPartStudioShadedViewsRequest) Edges(edges string) ApiGetPartStudioShadedViewsRequest {
	r.edges = &edges
	return r
}

// Whether or not all parts should be shown in the element, regardless of user setting. If false, the visibility setting made by the user will be reflected in the image. If true, all parts will be shown.
func (r ApiGetPartStudioShadedViewsRequest) ShowAllParts(showAllParts bool) ApiGetPartStudioShadedViewsRequest {
	r.showAllParts = &showAllParts
	return r
}

// Whether or not surfaces should be shown in the element. It is applicable only when showAllParts is true. If false, surfaces will be excluded. If true, all surfaces will be shown.
func (r ApiGetPartStudioShadedViewsRequest) IncludeSurfaces(includeSurfaces bool) ApiGetPartStudioShadedViewsRequest {
	r.includeSurfaces = &includeSurfaces
	return r
}

// If true, an anti-aliasing factor will be used to smooth model boundaries in the final image result. If false, the image will be rasterized at the given resolution. Setting to true can have negative performance implications with respect to rendering time and memory usage. If a high-resolution image is requested and anti-aliasing is turned on, the server may not be able to fulfill the request.
func (r ApiGetPartStudioShadedViewsRequest) UseAntiAliasing(useAntiAliasing bool) ApiGetPartStudioShadedViewsRequest {
	r.useAntiAliasing = &useAntiAliasing
	return r
}

func (r ApiGetPartStudioShadedViewsRequest) IncludeWires(includeWires bool) ApiGetPartStudioShadedViewsRequest {
	r.includeWires = &includeWires
	return r
}

// Configuration string.
func (r ApiGetPartStudioShadedViewsRequest) Configuration(configuration string) ApiGetPartStudioShadedViewsRequest {
	r.configuration = &configuration
	return r
}

// Id of document that links to the document being accessed. This may provide additional access rights to the document. Allowed only with version (v) path parameter.
func (r ApiGetPartStudioShadedViewsRequest) LinkDocumentId(linkDocumentId string) ApiGetPartStudioShadedViewsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetPartStudioShadedViewsRequest) Execute() (*BTShadedViewsInfo, *http.Response, error) {
	return r.ApiService.GetPartStudioShadedViewsExecute(r)
}

/*
GetPartStudioShadedViews Retrieve shaded views of the Part Studio by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did Document ID.
 @param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
 @param wvmid Workspace (w), Version (v) or Microversion (m) ID.
 @param eid Element ID.
 @return ApiGetPartStudioShadedViewsRequest
*/
func (a *PartStudioApiService) GetPartStudioShadedViews(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetPartStudioShadedViewsRequest {
	return ApiGetPartStudioShadedViewsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTShadedViewsInfo
func (a *PartStudioApiService) GetPartStudioShadedViewsExecute(r ApiGetPartStudioShadedViewsRequest) (*BTShadedViewsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTShadedViewsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.GetPartStudioShadedViews")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/shadedviews"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.viewMatrix != nil {
		localVarQueryParams.Add("viewMatrix", parameterToString(*r.viewMatrix, ""))
	}
	if r.outputHeight != nil {
		localVarQueryParams.Add("outputHeight", parameterToString(*r.outputHeight, ""))
	}
	if r.outputWidth != nil {
		localVarQueryParams.Add("outputWidth", parameterToString(*r.outputWidth, ""))
	}
	if r.pixelSize != nil {
		localVarQueryParams.Add("pixelSize", parameterToString(*r.pixelSize, ""))
	}
	if r.edges != nil {
		localVarQueryParams.Add("edges", parameterToString(*r.edges, ""))
	}
	if r.showAllParts != nil {
		localVarQueryParams.Add("showAllParts", parameterToString(*r.showAllParts, ""))
	}
	if r.includeSurfaces != nil {
		localVarQueryParams.Add("includeSurfaces", parameterToString(*r.includeSurfaces, ""))
	}
	if r.useAntiAliasing != nil {
		localVarQueryParams.Add("useAntiAliasing", parameterToString(*r.useAntiAliasing, ""))
	}
	if r.includeWires != nil {
		localVarQueryParams.Add("includeWires", parameterToString(*r.includeWires, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTShadedViewsInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateIdsRequest struct {
	ctx                   context.Context
	ApiService            *PartStudioApiService
	did                   string
	wvm                   string
	wvmid                 string
	eid                   string
	bTIdTranslationParams *BTIdTranslationParams
}

func (r ApiTranslateIdsRequest) BTIdTranslationParams(bTIdTranslationParams BTIdTranslationParams) ApiTranslateIdsRequest {
	r.bTIdTranslationParams = &bTIdTranslationParams
	return r
}

func (r ApiTranslateIdsRequest) Execute() (*BTIdTranslationInfo, *http.Response, error) {
	return r.ApiService.TranslateIdsExecute(r)
}

/*
TranslateIds Create Part Studio ID translation by document ID, workspace or version or microversion ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did Document ID.
 @param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
 @param wvmid Workspace (w), Version (v) or Microversion (m) ID.
 @param eid Element ID.
 @return ApiTranslateIdsRequest
*/
func (a *PartStudioApiService) TranslateIds(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiTranslateIdsRequest {
	return ApiTranslateIdsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTIdTranslationInfo
func (a *PartStudioApiService) TranslateIdsExecute(r ApiTranslateIdsRequest) (*BTIdTranslationInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTIdTranslationInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.TranslateIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/idtranslations"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bTIdTranslationParams == nil {
		return localVarReturnValue, nil, reportError("bTIdTranslationParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTIdTranslationParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTIdTranslationInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFeaturesRequest struct {
	ctx                      context.Context
	ApiService               *PartStudioApiService
	did                      string
	wid                      string
	eid                      string
	bTUpdateFeaturesCall1748 *BTUpdateFeaturesCall1748
}

// feature The serialized feature definition
func (r ApiUpdateFeaturesRequest) BTUpdateFeaturesCall1748(bTUpdateFeaturesCall1748 BTUpdateFeaturesCall1748) ApiUpdateFeaturesRequest {
	r.bTUpdateFeaturesCall1748 = &bTUpdateFeaturesCall1748
	return r
}

func (r ApiUpdateFeaturesRequest) Execute() (*BTUpdateFeaturesResponse1333, *http.Response, error) {
	return r.ApiService.UpdateFeaturesExecute(r)
}

/*
UpdateFeatures Update features by document ID, workspace ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did Document ID.
 @param wid Workspace ID.
 @param eid Element ID.
 @return ApiUpdateFeaturesRequest
*/
func (a *PartStudioApiService) UpdateFeatures(ctx context.Context, did string, wid string, eid string) ApiUpdateFeaturesRequest {
	return ApiUpdateFeaturesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTUpdateFeaturesResponse1333
func (a *PartStudioApiService) UpdateFeaturesExecute(r ApiUpdateFeaturesRequest) (*BTUpdateFeaturesResponse1333, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTUpdateFeaturesResponse1333
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.UpdateFeatures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/w/{wid}/e/{eid}/features/updates"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTUpdateFeaturesCall1748
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTUpdateFeaturesResponse1333
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePartStudioFeatureRequest struct {
	ctx                         context.Context
	ApiService                  *PartStudioApiService
	did                         string
	wid                         string
	eid                         string
	fid                         string
	bTFeatureDefinitionCall1406 *BTFeatureDefinitionCall1406
}

// feature The serialized feature definition
func (r ApiUpdatePartStudioFeatureRequest) BTFeatureDefinitionCall1406(bTFeatureDefinitionCall1406 BTFeatureDefinitionCall1406) ApiUpdatePartStudioFeatureRequest {
	r.bTFeatureDefinitionCall1406 = &bTFeatureDefinitionCall1406
	return r
}

func (r ApiUpdatePartStudioFeatureRequest) Execute() (*BTFeatureDefinitionResponse1617, *http.Response, error) {
	return r.ApiService.UpdatePartStudioFeatureExecute(r)
}

/*
UpdatePartStudioFeature Update feature by document ID, workspace ID, tab ID, and feature ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did Document ID.
 @param wid Workspace ID.
 @param eid Element ID.
 @param fid The id of the feature being updated. This id should be URL encoded and must match the featureId found in the serialized structure
 @return ApiUpdatePartStudioFeatureRequest
*/
func (a *PartStudioApiService) UpdatePartStudioFeature(ctx context.Context, did string, wid string, eid string, fid string) ApiUpdatePartStudioFeatureRequest {
	return ApiUpdatePartStudioFeatureRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
		fid:        fid,
	}
}

// Execute executes the request
//  @return BTFeatureDefinitionResponse1617
func (a *PartStudioApiService) UpdatePartStudioFeatureExecute(r ApiUpdatePartStudioFeatureRequest) (*BTFeatureDefinitionResponse1617, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTFeatureDefinitionResponse1617
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.UpdatePartStudioFeature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/w/{wid}/e/{eid}/features/featureid/{fid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fid"+"}", url.PathEscape(parameterToString(r.fid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTFeatureDefinitionCall1406
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTFeatureDefinitionResponse1617
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateRollbackRequest struct {
	ctx        context.Context
	ApiService *PartStudioApiService
	did        string
	wid        string
	eid        string
	body       *string
}

// The index at which the rollback index should be placed. Features  with entry index (0-based) higher than or equal to the value are rolled back. Value of -1 is treated  as an alias for \&quot;end of feature list\&quot;. Otherwise the value must be in the range 0 to the number of  entries in the feature list
func (r ApiUpdateRollbackRequest) Body(body string) ApiUpdateRollbackRequest {
	r.body = &body
	return r
}

func (r ApiUpdateRollbackRequest) Execute() (*BTSetFeatureRollbackResponse1042, *http.Response, error) {
	return r.ApiService.UpdateRollbackExecute(r)
}

/*
UpdateRollback Update feature rollback by document ID, workspace ID, and tab ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did Document ID.
 @param wid Workspace ID.
 @param eid Element ID.
 @return ApiUpdateRollbackRequest
*/
func (a *PartStudioApiService) UpdateRollback(ctx context.Context, did string, wid string, eid string) ApiUpdateRollbackRequest {
	return ApiUpdateRollbackRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wid:        wid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return BTSetFeatureRollbackResponse1042
func (a *PartStudioApiService) UpdateRollbackExecute(r ApiUpdateRollbackRequest) (*BTSetFeatureRollbackResponse1042, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTSetFeatureRollbackResponse1042
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartStudioApiService.UpdateRollback")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/partstudios/d/{did}/w/{wid}/e/{eid}/features/rollback"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", url.PathEscape(parameterToString(r.wid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTSetFeatureRollbackResponse1042
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
