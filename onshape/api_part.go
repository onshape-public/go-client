/*
Onshape REST API

## Welcome to the Onshape REST API Explorer  To use this API explorer, sign in to your [Onshape](https://cad.onshape.com) account in another tab, then click the **Try it out** button below (it toggles to a **Cancel** button when selected).  See the **[API Explorer Guide](https://onshape-public.github.io/docs/api-intro/explorer/)** for help navigating this API Explorer, including **[authentication](https://onshape-public.github.io/docs/api-intro/explorer/#authentication)**.  **Tip:** To ensure the current session isn't used when trying other authentication techniques, make sure to [remove the Onshape cookie](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site) as per the instructions for your browser. Alternatively, you can use a private or incognito window.  ## See Also  * [Onshape API Guide](https://onshape-public.github.io/docs/): Our full suite of developer guides, to be used as an accompaniment to this API Explorer. * [Onshape Developer Portal](https://dev-portal.onshape.com/): The Onshape portal for managing your API keys, OAuth2 credentials, your Onshape applications, and your Onshape App Store entries. * [Authentication Guide](https://onshape-public.github.io/docs/auth/): Our guide to using API keys, request signatures, and OAuth2 in  your Onshape applications.

Contact: api-support@onshape.zendesk.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package onshape

import (
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// PartAPIService PartAPI service
type PartAPIService service

type ApiExportPSRequest struct {
	ctx            context.Context
	ApiService     *PartAPIService
	did            string
	wvm            string
	wvmid          string
	eid            string
	partid         string
	version        *string
	configuration  *string
	linkDocumentId *string
}

func (r ApiExportPSRequest) Version(version string) ApiExportPSRequest {
	r.version = &version
	return r
}

func (r ApiExportPSRequest) Configuration(configuration string) ApiExportPSRequest {
	r.configuration = &configuration
	return r
}

func (r ApiExportPSRequest) LinkDocumentId(linkDocumentId string) ApiExportPSRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiExportPSRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExportPSExecute(r)
}

/*
ExportPS Export a part as a Parasolid file.

Returns a 307 redirect from which to download the exported file. See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/) for more details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param wvm
	@param wvmid
	@param eid
	@param partid
	@return ApiExportPSRequest
*/
func (a *PartAPIService) ExportPS(ctx context.Context, did string, wvm string, wvmid string, eid string, partid string) ApiExportPSRequest {
	return ApiExportPSRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		partid:     partid,
	}
}

// Execute executes the request
func (a *PartAPIService) ExportPSExecute(r ApiExportPSRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartAPIService.ExportPS")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/parasolid"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partid"+"}", url.PathEscape(parameterToString(r.partid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.version != nil {
		localVarQueryParams.Add("version", parameterToString(*r.version, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 307 {
			var v HttpFile
			err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExportPartGltfRequest struct {
	ctx                      context.Context
	ApiService               *PartAPIService
	did                      string
	wvm                      string
	wvmid                    string
	eid                      string
	partid                   string
	linkDocumentId           *string
	configuration            *string
	rollbackBarIndex         *int32
	elementMicroversionId    *string
	angleTolerance           *float64
	chordTolerance           *float64
	precomputedLevelOfDetail *string
	outputSeparateFaceNodes  *bool
	faceId                   *[]string
	outputFaceAppearances    *bool
	maxFacetWidth            *float64
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiExportPartGltfRequest) LinkDocumentId(linkDocumentId string) ApiExportPartGltfRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;). See the [Configurations API Guide](https://onshape-public.github.io/docs/api-adv/configs/) for details.
func (r ApiExportPartGltfRequest) Configuration(configuration string) ApiExportPartGltfRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiExportPartGltfRequest) RollbackBarIndex(rollbackBarIndex int32) ApiExportPartGltfRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

// A specific element microversion in which to evaluate the request.
func (r ApiExportPartGltfRequest) ElementMicroversionId(elementMicroversionId string) ApiExportPartGltfRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiExportPartGltfRequest) AngleTolerance(angleTolerance float64) ApiExportPartGltfRequest {
	r.angleTolerance = &angleTolerance
	return r
}

func (r ApiExportPartGltfRequest) ChordTolerance(chordTolerance float64) ApiExportPartGltfRequest {
	r.chordTolerance = &chordTolerance
	return r
}

func (r ApiExportPartGltfRequest) PrecomputedLevelOfDetail(precomputedLevelOfDetail string) ApiExportPartGltfRequest {
	r.precomputedLevelOfDetail = &precomputedLevelOfDetail
	return r
}

func (r ApiExportPartGltfRequest) OutputSeparateFaceNodes(outputSeparateFaceNodes bool) ApiExportPartGltfRequest {
	r.outputSeparateFaceNodes = &outputSeparateFaceNodes
	return r
}

func (r ApiExportPartGltfRequest) FaceId(faceId []string) ApiExportPartGltfRequest {
	r.faceId = &faceId
	return r
}

func (r ApiExportPartGltfRequest) OutputFaceAppearances(outputFaceAppearances bool) ApiExportPartGltfRequest {
	r.outputFaceAppearances = &outputFaceAppearances
	return r
}

func (r ApiExportPartGltfRequest) MaxFacetWidth(maxFacetWidth float64) ApiExportPartGltfRequest {
	r.maxFacetWidth = &maxFacetWidth
	return r
}

func (r ApiExportPartGltfRequest) Execute() (*GlTF, *http.Response, error) {
	return r.ApiService.ExportPartGltfExecute(r)
}

/*
ExportPartGltf Export a part as a glTF file.

Returns a 307 redirect from which to download the exported file. See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/) for more details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@param partid
	@return ApiExportPartGltfRequest
*/
func (a *PartAPIService) ExportPartGltf(ctx context.Context, did string, wvm string, wvmid string, eid string, partid string) ApiExportPartGltfRequest {
	return ApiExportPartGltfRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		partid:     partid,
	}
}

// Execute executes the request
//
//	@return GlTF
func (a *PartAPIService) ExportPartGltfExecute(r ApiExportPartGltfRequest) (*GlTF, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GlTF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartAPIService.ExportPartGltf")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/gltf"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partid"+"}", url.PathEscape(parameterToString(r.partid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	if r.angleTolerance != nil {
		localVarQueryParams.Add("angleTolerance", parameterToString(*r.angleTolerance, ""))
	}
	if r.chordTolerance != nil {
		localVarQueryParams.Add("chordTolerance", parameterToString(*r.chordTolerance, ""))
	}
	if r.precomputedLevelOfDetail != nil {
		localVarQueryParams.Add("precomputedLevelOfDetail", parameterToString(*r.precomputedLevelOfDetail, ""))
	}
	if r.outputSeparateFaceNodes != nil {
		localVarQueryParams.Add("outputSeparateFaceNodes", parameterToString(*r.outputSeparateFaceNodes, ""))
	}
	if r.faceId != nil {
		t := *r.faceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("faceId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("faceId", parameterToString(t, "multi"))
		}
	}
	if r.outputFaceAppearances != nil {
		localVarQueryParams.Add("outputFaceAppearances", parameterToString(*r.outputFaceAppearances, ""))
	}
	if r.maxFacetWidth != nil {
		localVarQueryParams.Add("maxFacetWidth", parameterToString(*r.maxFacetWidth, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"model/gltf+json;charset=UTF-8;qs=0.08", "model/gltf-binary;qs=0.08"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportStlRequest struct {
	ctx            context.Context
	ApiService     *PartAPIService
	did            string
	wvm            string
	wvmid          string
	eid            string
	partid         string
	mode           *string
	grouping       *bool
	scale          *float64
	units          *string
	angleTolerance *float64
	chordTolerance *float64
	maxFacetWidth  *float64
	minFacetWidth  *float64
	configuration  *string
	linkDocumentId *string
}

func (r ApiExportStlRequest) Mode(mode string) ApiExportStlRequest {
	r.mode = &mode
	return r
}

func (r ApiExportStlRequest) Grouping(grouping bool) ApiExportStlRequest {
	r.grouping = &grouping
	return r
}

func (r ApiExportStlRequest) Scale(scale float64) ApiExportStlRequest {
	r.scale = &scale
	return r
}

func (r ApiExportStlRequest) Units(units string) ApiExportStlRequest {
	r.units = &units
	return r
}

func (r ApiExportStlRequest) AngleTolerance(angleTolerance float64) ApiExportStlRequest {
	r.angleTolerance = &angleTolerance
	return r
}

func (r ApiExportStlRequest) ChordTolerance(chordTolerance float64) ApiExportStlRequest {
	r.chordTolerance = &chordTolerance
	return r
}

func (r ApiExportStlRequest) MaxFacetWidth(maxFacetWidth float64) ApiExportStlRequest {
	r.maxFacetWidth = &maxFacetWidth
	return r
}

func (r ApiExportStlRequest) MinFacetWidth(minFacetWidth float64) ApiExportStlRequest {
	r.minFacetWidth = &minFacetWidth
	return r
}

func (r ApiExportStlRequest) Configuration(configuration string) ApiExportStlRequest {
	r.configuration = &configuration
	return r
}

func (r ApiExportStlRequest) LinkDocumentId(linkDocumentId string) ApiExportStlRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiExportStlRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ExportStlExecute(r)
}

/*
ExportStl Export a part as an STL file.

Returns a 307 redirect from which to download the exported file. See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/) for more details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param wvm
	@param wvmid
	@param eid
	@param partid
	@return ApiExportStlRequest
*/
func (a *PartAPIService) ExportStl(ctx context.Context, did string, wvm string, wvmid string, eid string, partid string) ApiExportStlRequest {
	return ApiExportStlRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		partid:     partid,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *PartAPIService) ExportStlExecute(r ApiExportStlRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartAPIService.ExportStl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/stl"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partid"+"}", url.PathEscape(parameterToString(r.partid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.mode != nil {
		localVarQueryParams.Add("mode", parameterToString(*r.mode, ""))
	}
	if r.grouping != nil {
		localVarQueryParams.Add("grouping", parameterToString(*r.grouping, ""))
	}
	if r.scale != nil {
		localVarQueryParams.Add("scale", parameterToString(*r.scale, ""))
	}
	if r.units != nil {
		localVarQueryParams.Add("units", parameterToString(*r.units, ""))
	}
	if r.angleTolerance != nil {
		localVarQueryParams.Add("angleTolerance", parameterToString(*r.angleTolerance, ""))
	}
	if r.chordTolerance != nil {
		localVarQueryParams.Add("chordTolerance", parameterToString(*r.chordTolerance, ""))
	}
	if r.maxFacetWidth != nil {
		localVarQueryParams.Add("maxFacetWidth", parameterToString(*r.maxFacetWidth, ""))
	}
	if r.minFacetWidth != nil {
		localVarQueryParams.Add("minFacetWidth", parameterToString(*r.minFacetWidth, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBendTableRequest struct {
	ctx            context.Context
	ApiService     *PartAPIService
	did            string
	wvm            string
	wvmid          string
	eid            string
	partid         string
	linkDocumentId *string
}

func (r ApiGetBendTableRequest) LinkDocumentId(linkDocumentId string) ApiGetBendTableRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetBendTableRequest) Execute() (*BTTableResponse1546, *http.Response, error) {
	return r.ApiService.GetBendTableExecute(r)
}

/*
GetBendTable Get a part's sheet metal bend table.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param wvm
	@param wvmid
	@param eid
	@param partid
	@return ApiGetBendTableRequest
*/
func (a *PartAPIService) GetBendTable(ctx context.Context, did string, wvm string, wvmid string, eid string, partid string) ApiGetBendTableRequest {
	return ApiGetBendTableRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		partid:     partid,
	}
}

// Execute executes the request
//
//	@return BTTableResponse1546
func (a *PartAPIService) GetBendTableExecute(r ApiGetBendTableRequest) (*BTTableResponse1546, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTTableResponse1546
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartAPIService.GetBendTable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/sheetmetal/bendtable"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partid"+"}", url.PathEscape(parameterToString(r.partid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTTableResponse1546
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBodyDetailsRequest struct {
	ctx                   context.Context
	ApiService            *PartAPIService
	did                   string
	wvm                   string
	wvmid                 string
	eid                   string
	partid                string
	linkDocumentId        *string
	configuration         *string
	rollbackBarIndex      *int32
	elementMicroversionId *string
	includeGeometricData  *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetBodyDetailsRequest) LinkDocumentId(linkDocumentId string) ApiGetBodyDetailsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;). See the [Configurations API Guide](https://onshape-public.github.io/docs/api-adv/configs/) for details.
func (r ApiGetBodyDetailsRequest) Configuration(configuration string) ApiGetBodyDetailsRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiGetBodyDetailsRequest) RollbackBarIndex(rollbackBarIndex int32) ApiGetBodyDetailsRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

// A specific element microversion in which to evaluate the request.
func (r ApiGetBodyDetailsRequest) ElementMicroversionId(elementMicroversionId string) ApiGetBodyDetailsRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

// Whether or not geometric data should be included in the response.
func (r ApiGetBodyDetailsRequest) IncludeGeometricData(includeGeometricData bool) ApiGetBodyDetailsRequest {
	r.includeGeometricData = &includeGeometricData
	return r
}

func (r ApiGetBodyDetailsRequest) Execute() (*BTExportModelBodiesResponse734, *http.Response, error) {
	return r.ApiService.GetBodyDetailsExecute(r)
}

/*
GetBodyDetails Get a part's body details.

All coordinates are in meters (m).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@param partid
	@return ApiGetBodyDetailsRequest
*/
func (a *PartAPIService) GetBodyDetails(ctx context.Context, did string, wvm string, wvmid string, eid string, partid string) ApiGetBodyDetailsRequest {
	return ApiGetBodyDetailsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		partid:     partid,
	}
}

// Execute executes the request
//
//	@return BTExportModelBodiesResponse734
func (a *PartAPIService) GetBodyDetailsExecute(r ApiGetBodyDetailsRequest) (*BTExportModelBodiesResponse734, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTExportModelBodiesResponse734
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartAPIService.GetBodyDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/bodydetails"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partid"+"}", url.PathEscape(parameterToString(r.partid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	if r.includeGeometricData != nil {
		localVarQueryParams.Add("includeGeometricData", parameterToString(*r.includeGeometricData, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTExportModelBodiesResponse734
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBoundingBoxesRequest struct {
	ctx            context.Context
	ApiService     *PartAPIService
	did            string
	wvm            string
	wvmid          string
	eid            string
	partid         string
	includeHidden  *bool
	configuration  *string
	linkDocumentId *string
}

func (r ApiGetBoundingBoxesRequest) IncludeHidden(includeHidden bool) ApiGetBoundingBoxesRequest {
	r.includeHidden = &includeHidden
	return r
}

func (r ApiGetBoundingBoxesRequest) Configuration(configuration string) ApiGetBoundingBoxesRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetBoundingBoxesRequest) LinkDocumentId(linkDocumentId string) ApiGetBoundingBoxesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetBoundingBoxesRequest) Execute() (*BTBoundingBoxInfo, *http.Response, error) {
	return r.ApiService.GetBoundingBoxesExecute(r)
}

/*
GetBoundingBoxes Get a part's bounding box details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param wvm
	@param wvmid
	@param eid
	@param partid
	@return ApiGetBoundingBoxesRequest
*/
func (a *PartAPIService) GetBoundingBoxes(ctx context.Context, did string, wvm string, wvmid string, eid string, partid string) ApiGetBoundingBoxesRequest {
	return ApiGetBoundingBoxesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		partid:     partid,
	}
}

// Execute executes the request
//
//	@return BTBoundingBoxInfo
func (a *PartAPIService) GetBoundingBoxesExecute(r ApiGetBoundingBoxesRequest) (*BTBoundingBoxInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTBoundingBoxInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartAPIService.GetBoundingBoxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/boundingboxes"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partid"+"}", url.PathEscape(parameterToString(r.partid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeHidden != nil {
		localVarQueryParams.Add("includeHidden", parameterToString(*r.includeHidden, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTBoundingBoxInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEdgesRequest struct {
	ctx                      context.Context
	ApiService               *PartAPIService
	did                      string
	wvm                      string
	wvmid                    string
	eid                      string
	partid                   string
	linkDocumentId           *string
	configuration            *string
	rollbackBarIndex         *int32
	elementMicroversionId    *string
	angleTolerance           *float64
	chordTolerance           *float64
	precomputedLevelOfDetail *string
	edgeId                   *[]string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetEdgesRequest) LinkDocumentId(linkDocumentId string) ApiGetEdgesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;). See the [Configurations API Guide](https://onshape-public.github.io/docs/api-adv/configs/) for details.
func (r ApiGetEdgesRequest) Configuration(configuration string) ApiGetEdgesRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiGetEdgesRequest) RollbackBarIndex(rollbackBarIndex int32) ApiGetEdgesRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

// A specific element microversion in which to evaluate the request.
func (r ApiGetEdgesRequest) ElementMicroversionId(elementMicroversionId string) ApiGetEdgesRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiGetEdgesRequest) AngleTolerance(angleTolerance float64) ApiGetEdgesRequest {
	r.angleTolerance = &angleTolerance
	return r
}

func (r ApiGetEdgesRequest) ChordTolerance(chordTolerance float64) ApiGetEdgesRequest {
	r.chordTolerance = &chordTolerance
	return r
}

func (r ApiGetEdgesRequest) PrecomputedLevelOfDetail(precomputedLevelOfDetail string) ApiGetEdgesRequest {
	r.precomputedLevelOfDetail = &precomputedLevelOfDetail
	return r
}

func (r ApiGetEdgesRequest) EdgeId(edgeId []string) ApiGetEdgesRequest {
	r.edgeId = &edgeId
	return r
}

func (r ApiGetEdgesRequest) Execute() (*BTExportTessellatedEdgesResponse327, *http.Response, error) {
	return r.ApiService.GetEdgesExecute(r)
}

/*
GetEdges Get a list of a part's tessellation edges.

Returns the coordinates (in meters) of each edge's endpoints.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@param partid
	@return ApiGetEdgesRequest
*/
func (a *PartAPIService) GetEdges(ctx context.Context, did string, wvm string, wvmid string, eid string, partid string) ApiGetEdgesRequest {
	return ApiGetEdgesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		partid:     partid,
	}
}

// Execute executes the request
//
//	@return BTExportTessellatedEdgesResponse327
func (a *PartAPIService) GetEdgesExecute(r ApiGetEdgesRequest) (*BTExportTessellatedEdgesResponse327, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTExportTessellatedEdgesResponse327
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartAPIService.GetEdges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/tessellatededges"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partid"+"}", url.PathEscape(parameterToString(r.partid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	if r.angleTolerance != nil {
		localVarQueryParams.Add("angleTolerance", parameterToString(*r.angleTolerance, ""))
	}
	if r.chordTolerance != nil {
		localVarQueryParams.Add("chordTolerance", parameterToString(*r.chordTolerance, ""))
	}
	if r.precomputedLevelOfDetail != nil {
		localVarQueryParams.Add("precomputedLevelOfDetail", parameterToString(*r.precomputedLevelOfDetail, ""))
	}
	if r.edgeId != nil {
		t := *r.edgeId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("edgeId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("edgeId", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTExportTessellatedEdgesResponse327
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFaces1Request struct {
	ctx                              context.Context
	ApiService                       *PartAPIService
	did                              string
	wvm                              string
	wvmid                            string
	eid                              string
	partid                           string
	linkDocumentId                   *string
	configuration                    *string
	rollbackBarIndex                 *int32
	elementMicroversionId            *string
	angleTolerance                   *float64
	chordTolerance                   *float64
	precomputedLevelOfDetail         *string
	faceId                           *[]string
	outputFaceAppearances            *bool
	maxFacetWidth                    *float64
	outputVertexNormals              *bool
	outputFacetNormals               *bool
	outputTextureCoordinates         *bool
	outputIndexTable                 *bool
	outputErrorFaces                 *bool
	combineCompositePartConstituents *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetFaces1Request) LinkDocumentId(linkDocumentId string) ApiGetFaces1Request {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;). See the [Configurations API Guide](https://onshape-public.github.io/docs/api-adv/configs/) for details.
func (r ApiGetFaces1Request) Configuration(configuration string) ApiGetFaces1Request {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiGetFaces1Request) RollbackBarIndex(rollbackBarIndex int32) ApiGetFaces1Request {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

// A specific element microversion in which to evaluate the request.
func (r ApiGetFaces1Request) ElementMicroversionId(elementMicroversionId string) ApiGetFaces1Request {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiGetFaces1Request) AngleTolerance(angleTolerance float64) ApiGetFaces1Request {
	r.angleTolerance = &angleTolerance
	return r
}

func (r ApiGetFaces1Request) ChordTolerance(chordTolerance float64) ApiGetFaces1Request {
	r.chordTolerance = &chordTolerance
	return r
}

func (r ApiGetFaces1Request) PrecomputedLevelOfDetail(precomputedLevelOfDetail string) ApiGetFaces1Request {
	r.precomputedLevelOfDetail = &precomputedLevelOfDetail
	return r
}

func (r ApiGetFaces1Request) FaceId(faceId []string) ApiGetFaces1Request {
	r.faceId = &faceId
	return r
}

func (r ApiGetFaces1Request) OutputFaceAppearances(outputFaceAppearances bool) ApiGetFaces1Request {
	r.outputFaceAppearances = &outputFaceAppearances
	return r
}

func (r ApiGetFaces1Request) MaxFacetWidth(maxFacetWidth float64) ApiGetFaces1Request {
	r.maxFacetWidth = &maxFacetWidth
	return r
}

func (r ApiGetFaces1Request) OutputVertexNormals(outputVertexNormals bool) ApiGetFaces1Request {
	r.outputVertexNormals = &outputVertexNormals
	return r
}

func (r ApiGetFaces1Request) OutputFacetNormals(outputFacetNormals bool) ApiGetFaces1Request {
	r.outputFacetNormals = &outputFacetNormals
	return r
}

func (r ApiGetFaces1Request) OutputTextureCoordinates(outputTextureCoordinates bool) ApiGetFaces1Request {
	r.outputTextureCoordinates = &outputTextureCoordinates
	return r
}

func (r ApiGetFaces1Request) OutputIndexTable(outputIndexTable bool) ApiGetFaces1Request {
	r.outputIndexTable = &outputIndexTable
	return r
}

func (r ApiGetFaces1Request) OutputErrorFaces(outputErrorFaces bool) ApiGetFaces1Request {
	r.outputErrorFaces = &outputErrorFaces
	return r
}

func (r ApiGetFaces1Request) CombineCompositePartConstituents(combineCompositePartConstituents bool) ApiGetFaces1Request {
	r.combineCompositePartConstituents = &combineCompositePartConstituents
	return r
}

func (r ApiGetFaces1Request) Execute() (*BTExportTessellatedFacesResponse898, *http.Response, error) {
	return r.ApiService.GetFaces1Execute(r)
}

/*
GetFaces1 Get a list of a part's tessellation faces.

Coordinates are in meters (m).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@param eid The id of the element in which to perform the operation.
	@param partid
	@return ApiGetFaces1Request
*/
func (a *PartAPIService) GetFaces1(ctx context.Context, did string, wvm string, wvmid string, eid string, partid string) ApiGetFaces1Request {
	return ApiGetFaces1Request{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		partid:     partid,
	}
}

// Execute executes the request
//
//	@return BTExportTessellatedFacesResponse898
func (a *PartAPIService) GetFaces1Execute(r ApiGetFaces1Request) (*BTExportTessellatedFacesResponse898, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTExportTessellatedFacesResponse898
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartAPIService.GetFaces1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/tessellatedfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partid"+"}", url.PathEscape(parameterToString(r.partid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	if r.angleTolerance != nil {
		localVarQueryParams.Add("angleTolerance", parameterToString(*r.angleTolerance, ""))
	}
	if r.chordTolerance != nil {
		localVarQueryParams.Add("chordTolerance", parameterToString(*r.chordTolerance, ""))
	}
	if r.precomputedLevelOfDetail != nil {
		localVarQueryParams.Add("precomputedLevelOfDetail", parameterToString(*r.precomputedLevelOfDetail, ""))
	}
	if r.faceId != nil {
		t := *r.faceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("faceId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("faceId", parameterToString(t, "multi"))
		}
	}
	if r.outputFaceAppearances != nil {
		localVarQueryParams.Add("outputFaceAppearances", parameterToString(*r.outputFaceAppearances, ""))
	}
	if r.maxFacetWidth != nil {
		localVarQueryParams.Add("maxFacetWidth", parameterToString(*r.maxFacetWidth, ""))
	}
	if r.outputVertexNormals != nil {
		localVarQueryParams.Add("outputVertexNormals", parameterToString(*r.outputVertexNormals, ""))
	}
	if r.outputFacetNormals != nil {
		localVarQueryParams.Add("outputFacetNormals", parameterToString(*r.outputFacetNormals, ""))
	}
	if r.outputTextureCoordinates != nil {
		localVarQueryParams.Add("outputTextureCoordinates", parameterToString(*r.outputTextureCoordinates, ""))
	}
	if r.outputIndexTable != nil {
		localVarQueryParams.Add("outputIndexTable", parameterToString(*r.outputIndexTable, ""))
	}
	if r.outputErrorFaces != nil {
		localVarQueryParams.Add("outputErrorFaces", parameterToString(*r.outputErrorFaces, ""))
	}
	if r.combineCompositePartConstituents != nil {
		localVarQueryParams.Add("combineCompositePartConstituents", parameterToString(*r.combineCompositePartConstituents, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTExportTessellatedFacesResponse898
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMassPropertiesRequest struct {
	ctx                      context.Context
	ApiService               *PartAPIService
	did                      string
	wvm                      string
	wvmid                    string
	eid                      string
	partid                   string
	linkDocumentId           *string
	configuration            *string
	rollbackBarIndex         *int32
	elementMicroversionId    *string
	inferMetadataOwner       *bool
	useMassPropertyOverrides *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetMassPropertiesRequest) LinkDocumentId(linkDocumentId string) ApiGetMassPropertiesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;). See the [Configurations API Guide](https://onshape-public.github.io/docs/api-adv/configs/) for details.
func (r ApiGetMassPropertiesRequest) Configuration(configuration string) ApiGetMassPropertiesRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiGetMassPropertiesRequest) RollbackBarIndex(rollbackBarIndex int32) ApiGetMassPropertiesRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

// A specific element microversion in which to evaluate the request.
func (r ApiGetMassPropertiesRequest) ElementMicroversionId(elementMicroversionId string) ApiGetMassPropertiesRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiGetMassPropertiesRequest) InferMetadataOwner(inferMetadataOwner bool) ApiGetMassPropertiesRequest {
	r.inferMetadataOwner = &inferMetadataOwner
	return r
}

// If true, use the user mass property overrides when calculated mass properties
func (r ApiGetMassPropertiesRequest) UseMassPropertyOverrides(useMassPropertyOverrides bool) ApiGetMassPropertiesRequest {
	r.useMassPropertyOverrides = &useMassPropertyOverrides
	return r
}

func (r ApiGetMassPropertiesRequest) Execute() (*BTMassPropertiesBulkInfo, *http.Response, error) {
	return r.ApiService.GetMassPropertiesExecute(r)
}

/*
GetMassProperties Get a part's mass properties.

Parts must have density. The returned schema includes the same information as in the Onshape [Mass Properties Tool](https://cad.onshape.com/help/Content/massprops-ps.htm).
When three values are returned:

  - The first is the calculated value.

  - The second is the minimum possible value, considering tolerance.

  - The third is the maximum possible value, considering tolerance.

    @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
    @param did The id of the document in which to perform the operation.
    @param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
    @param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
    @param eid The id of the element in which to perform the operation.
    @param partid
    @return ApiGetMassPropertiesRequest
*/
func (a *PartAPIService) GetMassProperties(ctx context.Context, did string, wvm string, wvmid string, eid string, partid string) ApiGetMassPropertiesRequest {
	return ApiGetMassPropertiesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		partid:     partid,
	}
}

// Execute executes the request
//
//	@return BTMassPropertiesBulkInfo
func (a *PartAPIService) GetMassPropertiesExecute(r ApiGetMassPropertiesRequest) (*BTMassPropertiesBulkInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTMassPropertiesBulkInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartAPIService.GetMassProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/massproperties"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partid"+"}", url.PathEscape(parameterToString(r.partid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	if r.inferMetadataOwner != nil {
		localVarQueryParams.Add("inferMetadataOwner", parameterToString(*r.inferMetadataOwner, ""))
	}
	if r.useMassPropertyOverrides != nil {
		localVarQueryParams.Add("useMassPropertyOverrides", parameterToString(*r.useMassPropertyOverrides, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTMassPropertiesBulkInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartShadedViewsRequest struct {
	ctx             context.Context
	ApiService      *PartAPIService
	did             string
	wvm             string
	wvmid           string
	eid             string
	partid          string
	viewMatrix      *string
	outputHeight    *int32
	outputWidth     *int32
	pixelSize       *float64
	edges           *string
	useAntiAliasing *bool
	configuration   *string
	linkDocumentId  *string
}

func (r ApiGetPartShadedViewsRequest) ViewMatrix(viewMatrix string) ApiGetPartShadedViewsRequest {
	r.viewMatrix = &viewMatrix
	return r
}

func (r ApiGetPartShadedViewsRequest) OutputHeight(outputHeight int32) ApiGetPartShadedViewsRequest {
	r.outputHeight = &outputHeight
	return r
}

func (r ApiGetPartShadedViewsRequest) OutputWidth(outputWidth int32) ApiGetPartShadedViewsRequest {
	r.outputWidth = &outputWidth
	return r
}

func (r ApiGetPartShadedViewsRequest) PixelSize(pixelSize float64) ApiGetPartShadedViewsRequest {
	r.pixelSize = &pixelSize
	return r
}

func (r ApiGetPartShadedViewsRequest) Edges(edges string) ApiGetPartShadedViewsRequest {
	r.edges = &edges
	return r
}

func (r ApiGetPartShadedViewsRequest) UseAntiAliasing(useAntiAliasing bool) ApiGetPartShadedViewsRequest {
	r.useAntiAliasing = &useAntiAliasing
	return r
}

func (r ApiGetPartShadedViewsRequest) Configuration(configuration string) ApiGetPartShadedViewsRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetPartShadedViewsRequest) LinkDocumentId(linkDocumentId string) ApiGetPartShadedViewsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetPartShadedViewsRequest) Execute() (*BTShadedViewsInfo, *http.Response, error) {
	return r.ApiService.GetPartShadedViewsExecute(r)
}

/*
GetPartShadedViews Get a part's shaded views.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did
	@param wvm
	@param wvmid
	@param eid
	@param partid
	@return ApiGetPartShadedViewsRequest
*/
func (a *PartAPIService) GetPartShadedViews(ctx context.Context, did string, wvm string, wvmid string, eid string, partid string) ApiGetPartShadedViewsRequest {
	return ApiGetPartShadedViewsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		partid:     partid,
	}
}

// Execute executes the request
//
//	@return BTShadedViewsInfo
func (a *PartAPIService) GetPartShadedViewsExecute(r ApiGetPartShadedViewsRequest) (*BTShadedViewsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTShadedViewsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartAPIService.GetPartShadedViews")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/shadedviews"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partid"+"}", url.PathEscape(parameterToString(r.partid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.viewMatrix != nil {
		localVarQueryParams.Add("viewMatrix", parameterToString(*r.viewMatrix, ""))
	}
	if r.outputHeight != nil {
		localVarQueryParams.Add("outputHeight", parameterToString(*r.outputHeight, ""))
	}
	if r.outputWidth != nil {
		localVarQueryParams.Add("outputWidth", parameterToString(*r.outputWidth, ""))
	}
	if r.pixelSize != nil {
		localVarQueryParams.Add("pixelSize", parameterToString(*r.pixelSize, ""))
	}
	if r.edges != nil {
		localVarQueryParams.Add("edges", parameterToString(*r.edges, ""))
	}
	if r.useAntiAliasing != nil {
		localVarQueryParams.Add("useAntiAliasing", parameterToString(*r.useAntiAliasing, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTShadedViewsInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartsWMVRequest struct {
	ctx                     context.Context
	ApiService              *PartAPIService
	did                     string
	wvm                     string
	wvmid                   string
	elementId               *string
	linkDocumentId          *string
	configuration           *string
	withThumbnails          *bool
	includePropertyDefaults *bool
	includeFlatParts        *bool
}

// The id of the element in which to perform the operation.
func (r ApiGetPartsWMVRequest) ElementId(elementId string) ApiGetPartsWMVRequest {
	r.elementId = &elementId
	return r
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetPartsWMVRequest) LinkDocumentId(linkDocumentId string) ApiGetPartsWMVRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetPartsWMVRequest) Configuration(configuration string) ApiGetPartsWMVRequest {
	r.configuration = &configuration
	return r
}

// Whether or not to include thumbnails (not supported for microversion)
func (r ApiGetPartsWMVRequest) WithThumbnails(withThumbnails bool) ApiGetPartsWMVRequest {
	r.withThumbnails = &withThumbnails
	return r
}

// If true, include metadata schema property defaults in response
func (r ApiGetPartsWMVRequest) IncludePropertyDefaults(includePropertyDefaults bool) ApiGetPartsWMVRequest {
	r.includePropertyDefaults = &includePropertyDefaults
	return r
}

func (r ApiGetPartsWMVRequest) IncludeFlatParts(includeFlatParts bool) ApiGetPartsWMVRequest {
	r.includeFlatParts = &includeFlatParts
	return r
}

func (r ApiGetPartsWMVRequest) Execute() ([]BTPartMetadataInfo, *http.Response, error) {
	return r.ApiService.GetPartsWMVExecute(r)
}

/*
GetPartsWMV Get all parts in a workspace, version, or microversion.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did The id of the document in which to perform the operation.
	@param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
	@param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
	@return ApiGetPartsWMVRequest
*/
func (a *PartAPIService) GetPartsWMV(ctx context.Context, did string, wvm string, wvmid string) ApiGetPartsWMVRequest {
	return ApiGetPartsWMVRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
	}
}

// Execute executes the request
//
//	@return []BTPartMetadataInfo
func (a *PartAPIService) GetPartsWMVExecute(r ApiGetPartsWMVRequest) ([]BTPartMetadataInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []BTPartMetadataInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartAPIService.GetPartsWMV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.elementId == nil {
		return localVarReturnValue, nil, reportError("elementId is required and must be specified")
	}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	localVarQueryParams.Add("elementId", parameterToString(*r.elementId, ""))
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.withThumbnails != nil {
		localVarQueryParams.Add("withThumbnails", parameterToString(*r.withThumbnails, ""))
	}
	if r.includePropertyDefaults != nil {
		localVarQueryParams.Add("includePropertyDefaults", parameterToString(*r.includePropertyDefaults, ""))
	}
	if r.includeFlatParts != nil {
		localVarQueryParams.Add("includeFlatParts", parameterToString(*r.includeFlatParts, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v []BTPartMetadataInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartsWMVERequest struct {
	ctx                     context.Context
	ApiService              *PartAPIService
	did                     string
	wvm                     string
	wvmid                   string
	eid                     string
	withThumbnails          *bool
	includePropertyDefaults *bool
	includeFlatParts        *bool
	configuration           *string
	linkDocumentId          *string
}

// Whether or not to include thumbnails (not supported for microversion)
func (r ApiGetPartsWMVERequest) WithThumbnails(withThumbnails bool) ApiGetPartsWMVERequest {
	r.withThumbnails = &withThumbnails
	return r
}

// If true, include metadata schema property defaults in response
func (r ApiGetPartsWMVERequest) IncludePropertyDefaults(includePropertyDefaults bool) ApiGetPartsWMVERequest {
	r.includePropertyDefaults = &includePropertyDefaults
	return r
}

func (r ApiGetPartsWMVERequest) IncludeFlatParts(includeFlatParts bool) ApiGetPartsWMVERequest {
	r.includeFlatParts = &includeFlatParts
	return r
}

// URL-encoded string of configuration values (separated by &#x60;;&#x60;). See the [Configurations API Guide](https://onshape-public.github.io/docs/api-adv/configs/) for details.
func (r ApiGetPartsWMVERequest) Configuration(configuration string) ApiGetPartsWMVERequest {
	r.configuration = &configuration
	return r
}

// Id of document that links to the document being accessed. This may provide additional access rights to the document. Allowed only with version (v) path parameter.
func (r ApiGetPartsWMVERequest) LinkDocumentId(linkDocumentId string) ApiGetPartsWMVERequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetPartsWMVERequest) Execute() ([]BTPartMetadataInfo, *http.Response, error) {
	return r.ApiService.GetPartsWMVEExecute(r)
}

/*
GetPartsWMVE Get all parts in an element.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param did Document ID.
	@param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
	@param wvmid Workspace (w), Version (v) or Microversion (m) ID.
	@param eid Element ID.
	@return ApiGetPartsWMVERequest
*/
func (a *PartAPIService) GetPartsWMVE(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetPartsWMVERequest {
	return ApiGetPartsWMVERequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//
//	@return []BTPartMetadataInfo
func (a *PartAPIService) GetPartsWMVEExecute(r ApiGetPartsWMVERequest) ([]BTPartMetadataInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []BTPartMetadataInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartAPIService.GetPartsWMVE")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}/e/{eid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withThumbnails != nil {
		localVarQueryParams.Add("withThumbnails", parameterToString(*r.withThumbnails, ""))
	}
	if r.includePropertyDefaults != nil {
		localVarQueryParams.Add("includePropertyDefaults", parameterToString(*r.includePropertyDefaults, ""))
	}
	if r.includeFlatParts != nil {
		localVarQueryParams.Add("includeFlatParts", parameterToString(*r.includeFlatParts, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v []BTPartMetadataInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := io.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
