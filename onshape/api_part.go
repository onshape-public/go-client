/*
Onshape REST API

The Onshape REST API consumed by all client. # Authorization The simplest way to authorize and enable the **Try it out** functionality is to sign in to Onshape and use the current session. The **Authorize** button enables other authorization techniques. To ensure the current session isn't used when trying other authentication techniques, make sure to remove the Onshape cookie as per the instructions for your particular browser. Alternatively, a private or incognito window may be used. Here's [how to remove a specific cookie on Chrome](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site). - **Current Session** authorization is enabled by default if the browser is already signed in to [Onshape](/). - **OAuth2** authorization uses an Onshape OAuth2 app created on the [Onshape Developer Portal](https://dev-portal.onshape.com/oauthApps). The redirect URL field should include `https://cad.onshape.com/glassworks/explorer/oauth2-redirect.html`. - **API Key** authorization using basic authentication is also available. The keys can be generated in the [Onshape Developer Portal](https://dev-portal.onshape.com/keys). In the authentication dialog, enter the access key in the `Username` field, and enter the secret key in the `Password` field. Basic authentication should only be used during the development process since sharing API Keys provides the same level of access as a username and password.

API version: 1.170.23604-b59b123004e9
Contact: api-support@onshape.zendesk.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package onshape

import (
	"context"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// PartApiService PartApi service
type PartApiService service

type ApiExportPSRequest struct {
	ctx            context.Context
	ApiService     *PartApiService
	did            string
	wvm            string
	wvmid          string
	eid            string
	partid         string
	version        *string
	configuration  *string
	linkDocumentId *string
}

func (r ApiExportPSRequest) Version(version string) ApiExportPSRequest {
	r.version = &version
	return r
}

func (r ApiExportPSRequest) Configuration(configuration string) ApiExportPSRequest {
	r.configuration = &configuration
	return r
}

func (r ApiExportPSRequest) LinkDocumentId(linkDocumentId string) ApiExportPSRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiExportPSRequest) Execute() (*HttpFile, *http.Response, error) {
	return r.ApiService.ExportPSExecute(r)
}

/*
ExportPS Export a part as a Parasolid file.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wvm
 @param wvmid
 @param eid
 @param partid
 @return ApiExportPSRequest
*/
func (a *PartApiService) ExportPS(ctx context.Context, did string, wvm string, wvmid string, eid string, partid string) ApiExportPSRequest {
	return ApiExportPSRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		partid:     partid,
	}
}

// Execute executes the request
//  @return HttpFile
func (a *PartApiService) ExportPSExecute(r ApiExportPSRequest) (*HttpFile, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *HttpFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartApiService.ExportPS")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/parasolid"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partid"+"}", url.PathEscape(parameterToString(r.partid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.version != nil {
		localVarQueryParams.Add("version", parameterToString(*r.version, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportPartGltfRequest struct {
	ctx                      context.Context
	ApiService               *PartApiService
	did                      string
	wvm                      string
	wvmid                    string
	eid                      string
	partid                   string
	linkDocumentId           *string
	configuration            *string
	rollbackBarIndex         *int32
	elementMicroversionId    *string
	angleTolerance           *float64
	chordTolerance           *float64
	precomputedLevelOfDetail *string
	outputSeparateFaceNodes  *bool
	faceId                   *[]string
	outputFaceAppearances    *bool
	maxFacetWidth            *float64
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiExportPartGltfRequest) LinkDocumentId(linkDocumentId string) ApiExportPartGltfRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiExportPartGltfRequest) Configuration(configuration string) ApiExportPartGltfRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiExportPartGltfRequest) RollbackBarIndex(rollbackBarIndex int32) ApiExportPartGltfRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

// A specific element microversion in which to evaluate the request.
func (r ApiExportPartGltfRequest) ElementMicroversionId(elementMicroversionId string) ApiExportPartGltfRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiExportPartGltfRequest) AngleTolerance(angleTolerance float64) ApiExportPartGltfRequest {
	r.angleTolerance = &angleTolerance
	return r
}

func (r ApiExportPartGltfRequest) ChordTolerance(chordTolerance float64) ApiExportPartGltfRequest {
	r.chordTolerance = &chordTolerance
	return r
}

func (r ApiExportPartGltfRequest) PrecomputedLevelOfDetail(precomputedLevelOfDetail string) ApiExportPartGltfRequest {
	r.precomputedLevelOfDetail = &precomputedLevelOfDetail
	return r
}

func (r ApiExportPartGltfRequest) OutputSeparateFaceNodes(outputSeparateFaceNodes bool) ApiExportPartGltfRequest {
	r.outputSeparateFaceNodes = &outputSeparateFaceNodes
	return r
}

func (r ApiExportPartGltfRequest) FaceId(faceId []string) ApiExportPartGltfRequest {
	r.faceId = &faceId
	return r
}

func (r ApiExportPartGltfRequest) OutputFaceAppearances(outputFaceAppearances bool) ApiExportPartGltfRequest {
	r.outputFaceAppearances = &outputFaceAppearances
	return r
}

func (r ApiExportPartGltfRequest) MaxFacetWidth(maxFacetWidth float64) ApiExportPartGltfRequest {
	r.maxFacetWidth = &maxFacetWidth
	return r
}

func (r ApiExportPartGltfRequest) Execute() (*HttpFile, *http.Response, error) {
	return r.ApiService.ExportPartGltfExecute(r)
}

/*
ExportPartGltf Export a part as a glTF file.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
 @param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @param partid
 @return ApiExportPartGltfRequest
*/
func (a *PartApiService) ExportPartGltf(ctx context.Context, did string, wvm string, wvmid string, eid string, partid string) ApiExportPartGltfRequest {
	return ApiExportPartGltfRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		partid:     partid,
	}
}

// Execute executes the request
//  @return HttpFile
func (a *PartApiService) ExportPartGltfExecute(r ApiExportPartGltfRequest) (*HttpFile, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *HttpFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartApiService.ExportPartGltf")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/gltf"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partid"+"}", url.PathEscape(parameterToString(r.partid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	if r.angleTolerance != nil {
		localVarQueryParams.Add("angleTolerance", parameterToString(*r.angleTolerance, ""))
	}
	if r.chordTolerance != nil {
		localVarQueryParams.Add("chordTolerance", parameterToString(*r.chordTolerance, ""))
	}
	if r.precomputedLevelOfDetail != nil {
		localVarQueryParams.Add("precomputedLevelOfDetail", parameterToString(*r.precomputedLevelOfDetail, ""))
	}
	if r.outputSeparateFaceNodes != nil {
		localVarQueryParams.Add("outputSeparateFaceNodes", parameterToString(*r.outputSeparateFaceNodes, ""))
	}
	if r.faceId != nil {
		t := *r.faceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("faceId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("faceId", parameterToString(t, "multi"))
		}
	}
	if r.outputFaceAppearances != nil {
		localVarQueryParams.Add("outputFaceAppearances", parameterToString(*r.outputFaceAppearances, ""))
	}
	if r.maxFacetWidth != nil {
		localVarQueryParams.Add("maxFacetWidth", parameterToString(*r.maxFacetWidth, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"model/gltf-binary;qs=0.08"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportStlRequest struct {
	ctx            context.Context
	ApiService     *PartApiService
	did            string
	wvm            string
	wvmid          string
	eid            string
	partid         string
	mode           *string
	grouping       *bool
	scale          *float64
	units          *string
	angleTolerance *float64
	chordTolerance *float64
	maxFacetWidth  *float64
	minFacetWidth  *float64
	configuration  *string
	linkDocumentId *string
}

func (r ApiExportStlRequest) Mode(mode string) ApiExportStlRequest {
	r.mode = &mode
	return r
}

func (r ApiExportStlRequest) Grouping(grouping bool) ApiExportStlRequest {
	r.grouping = &grouping
	return r
}

func (r ApiExportStlRequest) Scale(scale float64) ApiExportStlRequest {
	r.scale = &scale
	return r
}

func (r ApiExportStlRequest) Units(units string) ApiExportStlRequest {
	r.units = &units
	return r
}

func (r ApiExportStlRequest) AngleTolerance(angleTolerance float64) ApiExportStlRequest {
	r.angleTolerance = &angleTolerance
	return r
}

func (r ApiExportStlRequest) ChordTolerance(chordTolerance float64) ApiExportStlRequest {
	r.chordTolerance = &chordTolerance
	return r
}

func (r ApiExportStlRequest) MaxFacetWidth(maxFacetWidth float64) ApiExportStlRequest {
	r.maxFacetWidth = &maxFacetWidth
	return r
}

func (r ApiExportStlRequest) MinFacetWidth(minFacetWidth float64) ApiExportStlRequest {
	r.minFacetWidth = &minFacetWidth
	return r
}

func (r ApiExportStlRequest) Configuration(configuration string) ApiExportStlRequest {
	r.configuration = &configuration
	return r
}

func (r ApiExportStlRequest) LinkDocumentId(linkDocumentId string) ApiExportStlRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiExportStlRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ExportStlExecute(r)
}

/*
ExportStl Export a part to an STL file.

Returns a 307 redirect.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wvm
 @param wvmid
 @param eid
 @param partid
 @return ApiExportStlRequest
*/
func (a *PartApiService) ExportStl(ctx context.Context, did string, wvm string, wvmid string, eid string, partid string) ApiExportStlRequest {
	return ApiExportStlRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		partid:     partid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PartApiService) ExportStlExecute(r ApiExportStlRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartApiService.ExportStl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/stl"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partid"+"}", url.PathEscape(parameterToString(r.partid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.mode != nil {
		localVarQueryParams.Add("mode", parameterToString(*r.mode, ""))
	}
	if r.grouping != nil {
		localVarQueryParams.Add("grouping", parameterToString(*r.grouping, ""))
	}
	if r.scale != nil {
		localVarQueryParams.Add("scale", parameterToString(*r.scale, ""))
	}
	if r.units != nil {
		localVarQueryParams.Add("units", parameterToString(*r.units, ""))
	}
	if r.angleTolerance != nil {
		localVarQueryParams.Add("angleTolerance", parameterToString(*r.angleTolerance, ""))
	}
	if r.chordTolerance != nil {
		localVarQueryParams.Add("chordTolerance", parameterToString(*r.chordTolerance, ""))
	}
	if r.maxFacetWidth != nil {
		localVarQueryParams.Add("maxFacetWidth", parameterToString(*r.maxFacetWidth, ""))
	}
	if r.minFacetWidth != nil {
		localVarQueryParams.Add("minFacetWidth", parameterToString(*r.minFacetWidth, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v map[string]interface{}
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBendTableRequest struct {
	ctx            context.Context
	ApiService     *PartApiService
	did            string
	wvm            string
	wvmid          string
	eid            string
	partid         string
	linkDocumentId *string
}

func (r ApiGetBendTableRequest) LinkDocumentId(linkDocumentId string) ApiGetBendTableRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetBendTableRequest) Execute() (*BTTableResponse1546, *http.Response, error) {
	return r.ApiService.GetBendTableExecute(r)
}

/*
GetBendTable Get a part's sheet metal bend table.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wvm
 @param wvmid
 @param eid
 @param partid
 @return ApiGetBendTableRequest
*/
func (a *PartApiService) GetBendTable(ctx context.Context, did string, wvm string, wvmid string, eid string, partid string) ApiGetBendTableRequest {
	return ApiGetBendTableRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		partid:     partid,
	}
}

// Execute executes the request
//  @return BTTableResponse1546
func (a *PartApiService) GetBendTableExecute(r ApiGetBendTableRequest) (*BTTableResponse1546, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTTableResponse1546
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartApiService.GetBendTable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/sheetmetal/bendtable"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partid"+"}", url.PathEscape(parameterToString(r.partid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTTableResponse1546
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBodyDetailsRequest struct {
	ctx                   context.Context
	ApiService            *PartApiService
	did                   string
	wvm                   string
	wvmid                 string
	eid                   string
	partid                string
	linkDocumentId        *string
	configuration         *string
	rollbackBarIndex      *int32
	elementMicroversionId *string
	includeGeometricData  *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetBodyDetailsRequest) LinkDocumentId(linkDocumentId string) ApiGetBodyDetailsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetBodyDetailsRequest) Configuration(configuration string) ApiGetBodyDetailsRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiGetBodyDetailsRequest) RollbackBarIndex(rollbackBarIndex int32) ApiGetBodyDetailsRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

// A specific element microversion in which to evaluate the request.
func (r ApiGetBodyDetailsRequest) ElementMicroversionId(elementMicroversionId string) ApiGetBodyDetailsRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

// Whether or not geometric data should be included in the response.
func (r ApiGetBodyDetailsRequest) IncludeGeometricData(includeGeometricData bool) ApiGetBodyDetailsRequest {
	r.includeGeometricData = &includeGeometricData
	return r
}

func (r ApiGetBodyDetailsRequest) Execute() (*BTExportModelBodiesResponse734, *http.Response, error) {
	return r.ApiService.GetBodyDetailsExecute(r)
}

/*
GetBodyDetails Get a part's body details.

All coordinates are in meters (m).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
 @param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @param partid
 @return ApiGetBodyDetailsRequest
*/
func (a *PartApiService) GetBodyDetails(ctx context.Context, did string, wvm string, wvmid string, eid string, partid string) ApiGetBodyDetailsRequest {
	return ApiGetBodyDetailsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		partid:     partid,
	}
}

// Execute executes the request
//  @return BTExportModelBodiesResponse734
func (a *PartApiService) GetBodyDetailsExecute(r ApiGetBodyDetailsRequest) (*BTExportModelBodiesResponse734, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTExportModelBodiesResponse734
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartApiService.GetBodyDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/bodydetails"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partid"+"}", url.PathEscape(parameterToString(r.partid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	if r.includeGeometricData != nil {
		localVarQueryParams.Add("includeGeometricData", parameterToString(*r.includeGeometricData, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTExportModelBodiesResponse734
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBoundingBoxesRequest struct {
	ctx            context.Context
	ApiService     *PartApiService
	did            string
	wvm            string
	wvmid          string
	eid            string
	partid         string
	includeHidden  *bool
	configuration  *string
	linkDocumentId *string
}

func (r ApiGetBoundingBoxesRequest) IncludeHidden(includeHidden bool) ApiGetBoundingBoxesRequest {
	r.includeHidden = &includeHidden
	return r
}

func (r ApiGetBoundingBoxesRequest) Configuration(configuration string) ApiGetBoundingBoxesRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetBoundingBoxesRequest) LinkDocumentId(linkDocumentId string) ApiGetBoundingBoxesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetBoundingBoxesRequest) Execute() (*BTBoundingBoxInfo, *http.Response, error) {
	return r.ApiService.GetBoundingBoxesExecute(r)
}

/*
GetBoundingBoxes Get a part's bounding box details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wvm
 @param wvmid
 @param eid
 @param partid
 @return ApiGetBoundingBoxesRequest
*/
func (a *PartApiService) GetBoundingBoxes(ctx context.Context, did string, wvm string, wvmid string, eid string, partid string) ApiGetBoundingBoxesRequest {
	return ApiGetBoundingBoxesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		partid:     partid,
	}
}

// Execute executes the request
//  @return BTBoundingBoxInfo
func (a *PartApiService) GetBoundingBoxesExecute(r ApiGetBoundingBoxesRequest) (*BTBoundingBoxInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTBoundingBoxInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartApiService.GetBoundingBoxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/boundingboxes"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partid"+"}", url.PathEscape(parameterToString(r.partid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeHidden != nil {
		localVarQueryParams.Add("includeHidden", parameterToString(*r.includeHidden, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTBoundingBoxInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEdgesRequest struct {
	ctx                      context.Context
	ApiService               *PartApiService
	did                      string
	wvm                      string
	wvmid                    string
	eid                      string
	partid                   string
	linkDocumentId           *string
	configuration            *string
	rollbackBarIndex         *int32
	elementMicroversionId    *string
	angleTolerance           *float64
	chordTolerance           *float64
	precomputedLevelOfDetail *string
	edgeId                   *[]string
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetEdgesRequest) LinkDocumentId(linkDocumentId string) ApiGetEdgesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetEdgesRequest) Configuration(configuration string) ApiGetEdgesRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiGetEdgesRequest) RollbackBarIndex(rollbackBarIndex int32) ApiGetEdgesRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

// A specific element microversion in which to evaluate the request.
func (r ApiGetEdgesRequest) ElementMicroversionId(elementMicroversionId string) ApiGetEdgesRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiGetEdgesRequest) AngleTolerance(angleTolerance float64) ApiGetEdgesRequest {
	r.angleTolerance = &angleTolerance
	return r
}

func (r ApiGetEdgesRequest) ChordTolerance(chordTolerance float64) ApiGetEdgesRequest {
	r.chordTolerance = &chordTolerance
	return r
}

func (r ApiGetEdgesRequest) PrecomputedLevelOfDetail(precomputedLevelOfDetail string) ApiGetEdgesRequest {
	r.precomputedLevelOfDetail = &precomputedLevelOfDetail
	return r
}

func (r ApiGetEdgesRequest) EdgeId(edgeId []string) ApiGetEdgesRequest {
	r.edgeId = &edgeId
	return r
}

func (r ApiGetEdgesRequest) Execute() (*BTExportTessellatedEdgesResponse327, *http.Response, error) {
	return r.ApiService.GetEdgesExecute(r)
}

/*
GetEdges Get a list of a part's tessellation edges.

Returns the coordinates (in meters) of each edge's endpoints.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
 @param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @param partid
 @return ApiGetEdgesRequest
*/
func (a *PartApiService) GetEdges(ctx context.Context, did string, wvm string, wvmid string, eid string, partid string) ApiGetEdgesRequest {
	return ApiGetEdgesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		partid:     partid,
	}
}

// Execute executes the request
//  @return BTExportTessellatedEdgesResponse327
func (a *PartApiService) GetEdgesExecute(r ApiGetEdgesRequest) (*BTExportTessellatedEdgesResponse327, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTExportTessellatedEdgesResponse327
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartApiService.GetEdges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/tessellatededges"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partid"+"}", url.PathEscape(parameterToString(r.partid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	if r.angleTolerance != nil {
		localVarQueryParams.Add("angleTolerance", parameterToString(*r.angleTolerance, ""))
	}
	if r.chordTolerance != nil {
		localVarQueryParams.Add("chordTolerance", parameterToString(*r.chordTolerance, ""))
	}
	if r.precomputedLevelOfDetail != nil {
		localVarQueryParams.Add("precomputedLevelOfDetail", parameterToString(*r.precomputedLevelOfDetail, ""))
	}
	if r.edgeId != nil {
		t := *r.edgeId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("edgeId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("edgeId", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTExportTessellatedEdgesResponse327
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFaces1Request struct {
	ctx                              context.Context
	ApiService                       *PartApiService
	did                              string
	wvm                              string
	wvmid                            string
	eid                              string
	partid                           string
	linkDocumentId                   *string
	configuration                    *string
	rollbackBarIndex                 *int32
	elementMicroversionId            *string
	angleTolerance                   *float64
	chordTolerance                   *float64
	precomputedLevelOfDetail         *string
	faceId                           *[]string
	outputFaceAppearances            *bool
	maxFacetWidth                    *float64
	outputVertexNormals              *bool
	outputFacetNormals               *bool
	outputTextureCoordinates         *bool
	outputIndexTable                 *bool
	outputErrorFaces                 *bool
	combineCompositePartConstituents *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetFaces1Request) LinkDocumentId(linkDocumentId string) ApiGetFaces1Request {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetFaces1Request) Configuration(configuration string) ApiGetFaces1Request {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiGetFaces1Request) RollbackBarIndex(rollbackBarIndex int32) ApiGetFaces1Request {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

// A specific element microversion in which to evaluate the request.
func (r ApiGetFaces1Request) ElementMicroversionId(elementMicroversionId string) ApiGetFaces1Request {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiGetFaces1Request) AngleTolerance(angleTolerance float64) ApiGetFaces1Request {
	r.angleTolerance = &angleTolerance
	return r
}

func (r ApiGetFaces1Request) ChordTolerance(chordTolerance float64) ApiGetFaces1Request {
	r.chordTolerance = &chordTolerance
	return r
}

func (r ApiGetFaces1Request) PrecomputedLevelOfDetail(precomputedLevelOfDetail string) ApiGetFaces1Request {
	r.precomputedLevelOfDetail = &precomputedLevelOfDetail
	return r
}

func (r ApiGetFaces1Request) FaceId(faceId []string) ApiGetFaces1Request {
	r.faceId = &faceId
	return r
}

func (r ApiGetFaces1Request) OutputFaceAppearances(outputFaceAppearances bool) ApiGetFaces1Request {
	r.outputFaceAppearances = &outputFaceAppearances
	return r
}

func (r ApiGetFaces1Request) MaxFacetWidth(maxFacetWidth float64) ApiGetFaces1Request {
	r.maxFacetWidth = &maxFacetWidth
	return r
}

func (r ApiGetFaces1Request) OutputVertexNormals(outputVertexNormals bool) ApiGetFaces1Request {
	r.outputVertexNormals = &outputVertexNormals
	return r
}

func (r ApiGetFaces1Request) OutputFacetNormals(outputFacetNormals bool) ApiGetFaces1Request {
	r.outputFacetNormals = &outputFacetNormals
	return r
}

func (r ApiGetFaces1Request) OutputTextureCoordinates(outputTextureCoordinates bool) ApiGetFaces1Request {
	r.outputTextureCoordinates = &outputTextureCoordinates
	return r
}

func (r ApiGetFaces1Request) OutputIndexTable(outputIndexTable bool) ApiGetFaces1Request {
	r.outputIndexTable = &outputIndexTable
	return r
}

func (r ApiGetFaces1Request) OutputErrorFaces(outputErrorFaces bool) ApiGetFaces1Request {
	r.outputErrorFaces = &outputErrorFaces
	return r
}

func (r ApiGetFaces1Request) CombineCompositePartConstituents(combineCompositePartConstituents bool) ApiGetFaces1Request {
	r.combineCompositePartConstituents = &combineCompositePartConstituents
	return r
}

func (r ApiGetFaces1Request) Execute() (*BTExportTessellatedFacesResponse898, *http.Response, error) {
	return r.ApiService.GetFaces1Execute(r)
}

/*
GetFaces1 Get a list of a part's tessellation faces.

Coordinates are in meters (m).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
 @param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @param partid
 @return ApiGetFaces1Request
*/
func (a *PartApiService) GetFaces1(ctx context.Context, did string, wvm string, wvmid string, eid string, partid string) ApiGetFaces1Request {
	return ApiGetFaces1Request{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		partid:     partid,
	}
}

// Execute executes the request
//  @return BTExportTessellatedFacesResponse898
func (a *PartApiService) GetFaces1Execute(r ApiGetFaces1Request) (*BTExportTessellatedFacesResponse898, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTExportTessellatedFacesResponse898
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartApiService.GetFaces1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/tessellatedfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partid"+"}", url.PathEscape(parameterToString(r.partid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	if r.angleTolerance != nil {
		localVarQueryParams.Add("angleTolerance", parameterToString(*r.angleTolerance, ""))
	}
	if r.chordTolerance != nil {
		localVarQueryParams.Add("chordTolerance", parameterToString(*r.chordTolerance, ""))
	}
	if r.precomputedLevelOfDetail != nil {
		localVarQueryParams.Add("precomputedLevelOfDetail", parameterToString(*r.precomputedLevelOfDetail, ""))
	}
	if r.faceId != nil {
		t := *r.faceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("faceId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("faceId", parameterToString(t, "multi"))
		}
	}
	if r.outputFaceAppearances != nil {
		localVarQueryParams.Add("outputFaceAppearances", parameterToString(*r.outputFaceAppearances, ""))
	}
	if r.maxFacetWidth != nil {
		localVarQueryParams.Add("maxFacetWidth", parameterToString(*r.maxFacetWidth, ""))
	}
	if r.outputVertexNormals != nil {
		localVarQueryParams.Add("outputVertexNormals", parameterToString(*r.outputVertexNormals, ""))
	}
	if r.outputFacetNormals != nil {
		localVarQueryParams.Add("outputFacetNormals", parameterToString(*r.outputFacetNormals, ""))
	}
	if r.outputTextureCoordinates != nil {
		localVarQueryParams.Add("outputTextureCoordinates", parameterToString(*r.outputTextureCoordinates, ""))
	}
	if r.outputIndexTable != nil {
		localVarQueryParams.Add("outputIndexTable", parameterToString(*r.outputIndexTable, ""))
	}
	if r.outputErrorFaces != nil {
		localVarQueryParams.Add("outputErrorFaces", parameterToString(*r.outputErrorFaces, ""))
	}
	if r.combineCompositePartConstituents != nil {
		localVarQueryParams.Add("combineCompositePartConstituents", parameterToString(*r.combineCompositePartConstituents, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTExportTessellatedFacesResponse898
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMassPropertiesRequest struct {
	ctx                      context.Context
	ApiService               *PartApiService
	did                      string
	wvm                      string
	wvmid                    string
	eid                      string
	partid                   string
	linkDocumentId           *string
	configuration            *string
	rollbackBarIndex         *int32
	elementMicroversionId    *string
	inferMetadataOwner       *bool
	useMassPropertyOverrides *bool
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetMassPropertiesRequest) LinkDocumentId(linkDocumentId string) ApiGetMassPropertiesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetMassPropertiesRequest) Configuration(configuration string) ApiGetMassPropertiesRequest {
	r.configuration = &configuration
	return r
}

// Index specifying the location of the rollback bar when the call is evaluated. A -1 indicates that it should be at the end of the featurelist.
func (r ApiGetMassPropertiesRequest) RollbackBarIndex(rollbackBarIndex int32) ApiGetMassPropertiesRequest {
	r.rollbackBarIndex = &rollbackBarIndex
	return r
}

// A specific element microversion in which to evaluate the request.
func (r ApiGetMassPropertiesRequest) ElementMicroversionId(elementMicroversionId string) ApiGetMassPropertiesRequest {
	r.elementMicroversionId = &elementMicroversionId
	return r
}

func (r ApiGetMassPropertiesRequest) InferMetadataOwner(inferMetadataOwner bool) ApiGetMassPropertiesRequest {
	r.inferMetadataOwner = &inferMetadataOwner
	return r
}

// If true, use the user mass property overrides when calculated mass properties
func (r ApiGetMassPropertiesRequest) UseMassPropertyOverrides(useMassPropertyOverrides bool) ApiGetMassPropertiesRequest {
	r.useMassPropertyOverrides = &useMassPropertyOverrides
	return r
}

func (r ApiGetMassPropertiesRequest) Execute() (*BTMassPropertiesBulkInfo, *http.Response, error) {
	return r.ApiService.GetMassPropertiesExecute(r)
}

/*
GetMassProperties Get a part's mass properties.

Parts must have density. If three mass properties are returned, the first is the calculated mass; the second and third are the minimum and maximum possible values considering tolerance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
 @param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
 @param eid The id of the element in which to perform the operation.
 @param partid
 @return ApiGetMassPropertiesRequest
*/
func (a *PartApiService) GetMassProperties(ctx context.Context, did string, wvm string, wvmid string, eid string, partid string) ApiGetMassPropertiesRequest {
	return ApiGetMassPropertiesRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		partid:     partid,
	}
}

// Execute executes the request
//  @return BTMassPropertiesBulkInfo
func (a *PartApiService) GetMassPropertiesExecute(r ApiGetMassPropertiesRequest) (*BTMassPropertiesBulkInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTMassPropertiesBulkInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartApiService.GetMassProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/massproperties"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partid"+"}", url.PathEscape(parameterToString(r.partid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.rollbackBarIndex != nil {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(*r.rollbackBarIndex, ""))
	}
	if r.elementMicroversionId != nil {
		localVarQueryParams.Add("elementMicroversionId", parameterToString(*r.elementMicroversionId, ""))
	}
	if r.inferMetadataOwner != nil {
		localVarQueryParams.Add("inferMetadataOwner", parameterToString(*r.inferMetadataOwner, ""))
	}
	if r.useMassPropertyOverrides != nil {
		localVarQueryParams.Add("useMassPropertyOverrides", parameterToString(*r.useMassPropertyOverrides, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTMassPropertiesBulkInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartShadedViewsRequest struct {
	ctx             context.Context
	ApiService      *PartApiService
	did             string
	wvm             string
	wvmid           string
	eid             string
	partid          string
	viewMatrix      *string
	outputHeight    *int32
	outputWidth     *int32
	pixelSize       *float64
	edges           *string
	useAntiAliasing *bool
	configuration   *string
	linkDocumentId  *string
}

func (r ApiGetPartShadedViewsRequest) ViewMatrix(viewMatrix string) ApiGetPartShadedViewsRequest {
	r.viewMatrix = &viewMatrix
	return r
}

func (r ApiGetPartShadedViewsRequest) OutputHeight(outputHeight int32) ApiGetPartShadedViewsRequest {
	r.outputHeight = &outputHeight
	return r
}

func (r ApiGetPartShadedViewsRequest) OutputWidth(outputWidth int32) ApiGetPartShadedViewsRequest {
	r.outputWidth = &outputWidth
	return r
}

func (r ApiGetPartShadedViewsRequest) PixelSize(pixelSize float64) ApiGetPartShadedViewsRequest {
	r.pixelSize = &pixelSize
	return r
}

func (r ApiGetPartShadedViewsRequest) Edges(edges string) ApiGetPartShadedViewsRequest {
	r.edges = &edges
	return r
}

func (r ApiGetPartShadedViewsRequest) UseAntiAliasing(useAntiAliasing bool) ApiGetPartShadedViewsRequest {
	r.useAntiAliasing = &useAntiAliasing
	return r
}

func (r ApiGetPartShadedViewsRequest) Configuration(configuration string) ApiGetPartShadedViewsRequest {
	r.configuration = &configuration
	return r
}

func (r ApiGetPartShadedViewsRequest) LinkDocumentId(linkDocumentId string) ApiGetPartShadedViewsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetPartShadedViewsRequest) Execute() (*BTShadedViewsInfo, *http.Response, error) {
	return r.ApiService.GetPartShadedViewsExecute(r)
}

/*
GetPartShadedViews Get a part's shaded views.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did
 @param wvm
 @param wvmid
 @param eid
 @param partid
 @return ApiGetPartShadedViewsRequest
*/
func (a *PartApiService) GetPartShadedViews(ctx context.Context, did string, wvm string, wvmid string, eid string, partid string) ApiGetPartShadedViewsRequest {
	return ApiGetPartShadedViewsRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
		partid:     partid,
	}
}

// Execute executes the request
//  @return BTShadedViewsInfo
func (a *PartApiService) GetPartShadedViewsExecute(r ApiGetPartShadedViewsRequest) (*BTShadedViewsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BTShadedViewsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartApiService.GetPartShadedViews")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/shadedviews"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partid"+"}", url.PathEscape(parameterToString(r.partid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.viewMatrix != nil {
		localVarQueryParams.Add("viewMatrix", parameterToString(*r.viewMatrix, ""))
	}
	if r.outputHeight != nil {
		localVarQueryParams.Add("outputHeight", parameterToString(*r.outputHeight, ""))
	}
	if r.outputWidth != nil {
		localVarQueryParams.Add("outputWidth", parameterToString(*r.outputWidth, ""))
	}
	if r.pixelSize != nil {
		localVarQueryParams.Add("pixelSize", parameterToString(*r.pixelSize, ""))
	}
	if r.edges != nil {
		localVarQueryParams.Add("edges", parameterToString(*r.edges, ""))
	}
	if r.useAntiAliasing != nil {
		localVarQueryParams.Add("useAntiAliasing", parameterToString(*r.useAntiAliasing, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v BTShadedViewsInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartsWMVRequest struct {
	ctx                     context.Context
	ApiService              *PartApiService
	did                     string
	wvm                     string
	wvmid                   string
	elementId               *string
	linkDocumentId          *string
	configuration           *string
	withThumbnails          *bool
	includePropertyDefaults *bool
	includeFlatParts        *bool
}

// The id of the element in which to perform the operation.
func (r ApiGetPartsWMVRequest) ElementId(elementId string) ApiGetPartsWMVRequest {
	r.elementId = &elementId
	return r
}

// The id of the document through which the above document should be accessed; only applicable when accessing a version of the document. This allows a user who has access to document a to see data from document b, as long as document b has been linked to document a by a user who has permission to both.
func (r ApiGetPartsWMVRequest) LinkDocumentId(linkDocumentId string) ApiGetPartsWMVRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetPartsWMVRequest) Configuration(configuration string) ApiGetPartsWMVRequest {
	r.configuration = &configuration
	return r
}

// Whether or not to include thumbnails (not supported for microversion)
func (r ApiGetPartsWMVRequest) WithThumbnails(withThumbnails bool) ApiGetPartsWMVRequest {
	r.withThumbnails = &withThumbnails
	return r
}

// If true, include metadata schema property defaults in response
func (r ApiGetPartsWMVRequest) IncludePropertyDefaults(includePropertyDefaults bool) ApiGetPartsWMVRequest {
	r.includePropertyDefaults = &includePropertyDefaults
	return r
}

func (r ApiGetPartsWMVRequest) IncludeFlatParts(includeFlatParts bool) ApiGetPartsWMVRequest {
	r.includeFlatParts = &includeFlatParts
	return r
}

func (r ApiGetPartsWMVRequest) Execute() ([]BTPartMetadataInfo, *http.Response, error) {
	return r.ApiService.GetPartsWMVExecute(r)
}

/*
GetPartsWMV Get all parts in a workspace, version, or microversion.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did The id of the document in which to perform the operation.
 @param wvm Indicates which of workspace (w), version (v), or document microversion (m) id is specified below.
 @param wvmid The id of the workspace, version or document microversion in which the operation should be performed.
 @return ApiGetPartsWMVRequest
*/
func (a *PartApiService) GetPartsWMV(ctx context.Context, did string, wvm string, wvmid string) ApiGetPartsWMVRequest {
	return ApiGetPartsWMVRequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
	}
}

// Execute executes the request
//  @return []BTPartMetadataInfo
func (a *PartApiService) GetPartsWMVExecute(r ApiGetPartsWMVRequest) ([]BTPartMetadataInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []BTPartMetadataInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartApiService.GetPartsWMV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.elementId == nil {
		return localVarReturnValue, nil, reportError("elementId is required and must be specified")
	}

	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	localVarQueryParams.Add("elementId", parameterToString(*r.elementId, ""))
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.withThumbnails != nil {
		localVarQueryParams.Add("withThumbnails", parameterToString(*r.withThumbnails, ""))
	}
	if r.includePropertyDefaults != nil {
		localVarQueryParams.Add("includePropertyDefaults", parameterToString(*r.includePropertyDefaults, ""))
	}
	if r.includeFlatParts != nil {
		localVarQueryParams.Add("includeFlatParts", parameterToString(*r.includeFlatParts, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v []BTPartMetadataInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartsWMVERequest struct {
	ctx                     context.Context
	ApiService              *PartApiService
	did                     string
	wvm                     string
	wvmid                   string
	eid                     string
	withThumbnails          *bool
	includePropertyDefaults *bool
	includeFlatParts        *bool
	configuration           *string
	linkDocumentId          *string
}

// Whether or not to include thumbnails (not supported for microversion)
func (r ApiGetPartsWMVERequest) WithThumbnails(withThumbnails bool) ApiGetPartsWMVERequest {
	r.withThumbnails = &withThumbnails
	return r
}

// If true, include metadata schema property defaults in response
func (r ApiGetPartsWMVERequest) IncludePropertyDefaults(includePropertyDefaults bool) ApiGetPartsWMVERequest {
	r.includePropertyDefaults = &includePropertyDefaults
	return r
}

func (r ApiGetPartsWMVERequest) IncludeFlatParts(includeFlatParts bool) ApiGetPartsWMVERequest {
	r.includeFlatParts = &includeFlatParts
	return r
}

// Configuration string.
func (r ApiGetPartsWMVERequest) Configuration(configuration string) ApiGetPartsWMVERequest {
	r.configuration = &configuration
	return r
}

// Id of document that links to the document being accessed. This may provide additional access rights to the document. Allowed only with version (v) path parameter.
func (r ApiGetPartsWMVERequest) LinkDocumentId(linkDocumentId string) ApiGetPartsWMVERequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r ApiGetPartsWMVERequest) Execute() ([]BTPartMetadataInfo, *http.Response, error) {
	return r.ApiService.GetPartsWMVEExecute(r)
}

/*
GetPartsWMVE Get all parts in an element.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param did Document ID.
 @param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
 @param wvmid Workspace (w), Version (v) or Microversion (m) ID.
 @param eid Element ID.
 @return ApiGetPartsWMVERequest
*/
func (a *PartApiService) GetPartsWMVE(ctx context.Context, did string, wvm string, wvmid string, eid string) ApiGetPartsWMVERequest {
	return ApiGetPartsWMVERequest{
		ApiService: a,
		ctx:        ctx,
		did:        did,
		wvm:        wvm,
		wvmid:      wvmid,
		eid:        eid,
	}
}

// Execute executes the request
//  @return []BTPartMetadataInfo
func (a *PartApiService) GetPartsWMVEExecute(r ApiGetPartsWMVERequest) ([]BTPartMetadataInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []BTPartMetadataInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartApiService.GetPartsWMVE")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parts/d/{did}/{wvm}/{wvmid}/e/{eid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", url.PathEscape(parameterToString(r.did, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", url.PathEscape(parameterToString(r.wvm, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", url.PathEscape(parameterToString(r.wvmid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", url.PathEscape(parameterToString(r.eid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withThumbnails != nil {
		localVarQueryParams.Add("withThumbnails", parameterToString(*r.withThumbnails, ""))
	}
	if r.includePropertyDefaults != nil {
		localVarQueryParams.Add("includePropertyDefaults", parameterToString(*r.includePropertyDefaults, ""))
	}
	if r.includeFlatParts != nil {
		localVarQueryParams.Add("includeFlatParts", parameterToString(*r.includeFlatParts, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	var _ io.Reader

	if localVarHTTPResponse.StatusCode >= 300 {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v []BTPartMetadataInfo
		err = a.client.decode(&v, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, &localVarHTTPResponse.Body, localVarHTTPResponse.Header.Get("Content-Type"))

	if err != nil {
		localVarBody, _ := ioutil.ReadAll(localVarHTTPResponse.Body)

		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
